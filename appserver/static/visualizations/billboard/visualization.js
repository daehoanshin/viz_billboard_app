define(["api/SplunkVisualizationBase","api/SplunkVisualizationUtils"], function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__) { return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	    __webpack_require__(1),
	    __webpack_require__(2),
	    __webpack_require__(3),
	    __webpack_require__(4),
	    __webpack_require__(5),
	    __webpack_require__(37)
	  ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    $,
	    _,
	    SplunkVisualizationBase,
	    SplunkVisualizationUtils,
	    d3,
	    billboard
	  ) {

	    return SplunkVisualizationBase.extend({

	      initialize: function () {
	        // Save this.$el for convenience
	        this.$el = $(this.el);

	        // Add a css selector class
	        this.$el.addClass('splunk-billboard');
	      },

	      getInitialDataParams: function () {
	        return ({
	          outputMode: SplunkVisualizationBase.ROW_MAJOR_OUTPUT_MODE,
	          count: 10000
	        });
	      },

	      /* formatData: function (data) {
	        // Format data
	        console.log(data);
	        if (data.rows.length < 1) {
	          return false;
	        }
	        var datum = SplunkVisualizationUtils.escapeHtml(parseFloat(data.rows[0][0]));

	        console.log(datum);

	        if (_.isNaN(datum)) {
	          throw new SplunkVisualizationBase.VisualizationError("This viz is only supports number");
	        }
	        return data;
	      }, */

	      updateView: function (data, config) {
	        console.log(data);
	        console.log(config);

	        if (data.rows.length < 1) {
	          return false;
	        }

	        var datas = [];
	        data.fields.forEach(function (el, idx) {
	          datas[idx] = new Array(el.name);
	        });

	        data.rows.forEach(function (el) {
	          for (i = 0; i < el.length; i++) {
	            datas[i].push(el[i])
	          }
	        });
	        let timeFormat = "";
	        let bindId = config["display.visualizations.custom.viz_billboard_app.billboard.bindId"]

	        if (bindId == undefined) {
	          return false;
	        }

	        // 날짜  YYYY-MM-DD
	        var dayRegExp = /^(19|20)\d{2}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[0-1])$/;

	        // 복합 YYYY-MM-DD HH24:mm (중간 공백)
	        var dayTimeRegExp = /^(19|20|21)\d{2}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[0-1])\s([1-9]|[01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/;

	        console.log(bindId);

	        if (dayRegExp.test(datas[0][1])) {
	          timeFormat = "%Y-%m-%d";
	        }

	        if (dayTimeRegExp.test(datas[0][1])) {
	          timeFormat = "%Y-%m-%d %H:%M:%S";
	        }

	        var chart = billboard.bb.generate({
	          data: {
	            x: "x",
	            xFormat: timeFormat,
	            columns: datas
	          },
	          axis: {
	            x: {
	              type: "timeseries",
	              tick: {
	                format: timeFormat
	              }
	            }
	          },
	          tooltip: {
	            linked: true
	          },
	          bindto: bindId
	        });
	      }
	    });
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}

			return key === undefined || hasOwn.call( obj, key );
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define('underscore', factory) :
	  (function() {
	  	var current = global._;
	  	var exports = factory();
	  	global._ = exports;
	  	exports.noConflict = function() { global._ = current; return exports; };
	  })();
	}(this, (function () {

	  //     Underscore.js 1.10.2
	  //     https://underscorejs.org
	  //     (c) 2009-2020 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	  //     Underscore may be freely distributed under the MIT license.

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` (`self`) in the browser, `global`
	  // on the server, or `this` in some virtual machines. We use `self`
	  // instead of `window` for `WebWorker` support.
	  var root = typeof self == 'object' && self.self === self && self ||
	            typeof global == 'object' && global.global === global && global ||
	            Function('return this')() ||
	            {};

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

	  // Create quick reference variables for speed access to core prototypes.
	  var push = ArrayProto.push,
	      slice = ArrayProto.slice,
	      toString = ObjProto.toString,
	      hasOwnProperty = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var nativeIsArray = Array.isArray,
	      nativeKeys = Object.keys,
	      nativeCreate = Object.create;

	  // Create references to these builtin functions because we override them.
	  var _isNaN = root.isNaN,
	      _isFinite = root.isFinite;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // The Underscore object. All exported functions below are added to it in the
	  // modules/index-all.js using the mixin function.
	  function _(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  }

	  // Current version.
	  var VERSION = _.VERSION = '1.10.2';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  function optimizeCb(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      // The 2-argument case is omitted because we’re not using it.
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  }

	  // An internal function to generate callbacks that can be applied to each
	  // element in a collection, returning the desired result — either `identity`,
	  // an arbitrary callback, a property matcher, or a property accessor.
	  function baseIteratee(value, context, argCount) {
	    if (value == null) return identity;
	    if (isFunction(value)) return optimizeCb(value, context, argCount);
	    if (isObject(value) && !isArray(value)) return matcher(value);
	    return property(value);
	  }

	  // External wrapper for our callback generator. Users may customize
	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
	  // This abstraction hides the internal-only argCount argument.
	  _.iteratee = iteratee;
	  function iteratee(value, context) {
	    return baseIteratee(value, context, Infinity);
	  }

	  // The function we actually call internally. It invokes _.iteratee if
	  // overridden, otherwise baseIteratee.
	  function cb(value, context, argCount) {
	    if (_.iteratee !== iteratee) return _.iteratee(value, context);
	    return baseIteratee(value, context, argCount);
	  }

	  // Some functions take a variable number of arguments, or a few expected
	  // arguments at the beginning and then a variable number of values to operate
	  // on. This helper accumulates all remaining arguments past the function’s
	  // argument length (or an explicit `startIndex`), into an array that becomes
	  // the last argument. Similar to ES6’s "rest parameter".
	  function restArguments(func, startIndex) {
	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
	    return function() {
	      var length = Math.max(arguments.length - startIndex, 0),
	          rest = Array(length),
	          index = 0;
	      for (; index < length; index++) {
	        rest[index] = arguments[index + startIndex];
	      }
	      switch (startIndex) {
	        case 0: return func.call(this, rest);
	        case 1: return func.call(this, arguments[0], rest);
	        case 2: return func.call(this, arguments[0], arguments[1], rest);
	      }
	      var args = Array(startIndex + 1);
	      for (index = 0; index < startIndex; index++) {
	        args[index] = arguments[index];
	      }
	      args[startIndex] = rest;
	      return func.apply(this, args);
	    };
	  }

	  // An internal function for creating a new object that inherits from another.
	  function baseCreate(prototype) {
	    if (!isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  }

	  function shallowProperty(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  }

	  function _has(obj, path) {
	    return obj != null && hasOwnProperty.call(obj, path);
	  }

	  function deepGet(obj, path) {
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      if (obj == null) return void 0;
	      obj = obj[path[i]];
	    }
	    return length ? obj : void 0;
	  }

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object.
	  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = shallowProperty('length');
	  function isArrayLike(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  }

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  function each(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var _keys = keys(obj);
	      for (i = 0, length = _keys.length; i < length; i++) {
	        iteratee(obj[_keys[i]], _keys[i], obj);
	      }
	    }
	    return obj;
	  }

	  // Return the results of applying the iteratee to each element.
	  function map(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var _keys = !isArrayLike(obj) && keys(obj),
	        length = (_keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys ? _keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  }

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Wrap code that reassigns argument variables in a separate function than
	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
	    var reducer = function(obj, iteratee, memo, initial) {
	      var _keys = !isArrayLike(obj) && keys(obj),
	          length = (_keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      if (!initial) {
	        memo = obj[_keys ? _keys[index] : index];
	        index += dir;
	      }
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = _keys ? _keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    };

	    return function(obj, iteratee, memo, context) {
	      var initial = arguments.length >= 3;
	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  var reduce = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  var reduceRight = createReduce(-1);

	  // Return the first value which passes a truth test.
	  function find(obj, predicate, context) {
	    var keyFinder = isArrayLike(obj) ? findIndex : findKey;
	    var key = keyFinder(obj, predicate, context);
	    if (key !== void 0 && key !== -1) return obj[key];
	  }

	  // Return all the elements that pass a truth test.
	  function filter(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  }

	  // Return all the elements for which a truth test fails.
	  function reject(obj, predicate, context) {
	    return filter(obj, negate(cb(predicate)), context);
	  }

	  // Determine whether all of the elements match a truth test.
	  function every(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var _keys = !isArrayLike(obj) && keys(obj),
	        length = (_keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys ? _keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  }

	  // Determine if at least one element in the object matches a truth test.
	  function some(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var _keys = !isArrayLike(obj) && keys(obj),
	        length = (_keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys ? _keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  }

	  // Determine if the array or object contains a given item (using `===`).
	  function contains(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return indexOf(obj, item, fromIndex) >= 0;
	  }

	  // Invoke a method (with arguments) on every item in a collection.
	  var invoke = restArguments(function(obj, path, args) {
	    var contextPath, func;
	    if (isFunction(path)) {
	      func = path;
	    } else if (isArray(path)) {
	      contextPath = path.slice(0, -1);
	      path = path[path.length - 1];
	    }
	    return map(obj, function(context) {
	      var method = func;
	      if (!method) {
	        if (contextPath && contextPath.length) {
	          context = deepGet(context, contextPath);
	        }
	        if (context == null) return void 0;
	        method = context[path];
	      }
	      return method == null ? method : method.apply(context, args);
	    });
	  });

	  // Convenience version of a common use case of `map`: fetching a property.
	  function pluck(obj, key) {
	    return map(obj, property(key));
	  }

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  function where(obj, attrs) {
	    return filter(obj, matcher(attrs));
	  }

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  function findWhere(obj, attrs) {
	    return find(obj, matcher(attrs));
	  }

	  // Return the maximum element (or element-based computation).
	  function max(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  }

	  // Return the minimum element (or element-based computation).
	  function min(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  }

	  // Shuffle a collection.
	  function shuffle(obj) {
	    return sample(obj, Infinity);
	  }

	  // Sample **n** random values from a collection using the modern version of the
	  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  function sample(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = values(obj);
	      return obj[random(obj.length - 1)];
	    }
	    var sample = isArrayLike(obj) ? clone(obj) : values(obj);
	    var length = getLength(sample);
	    n = Math.max(Math.min(n, length), 0);
	    var last = length - 1;
	    for (var index = 0; index < n; index++) {
	      var rand = random(index, last);
	      var temp = sample[index];
	      sample[index] = sample[rand];
	      sample[rand] = temp;
	    }
	    return sample.slice(0, n);
	  }

	  // Sort the object's values by a criterion produced by an iteratee.
	  function sortBy(obj, iteratee, context) {
	    var index = 0;
	    iteratee = cb(iteratee, context);
	    return pluck(map(obj, function(value, key, list) {
	      return {
	        value: value,
	        index: index++,
	        criteria: iteratee(value, key, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  }

	  // An internal function used for aggregate "group by" operations.
	  function group(behavior, partition) {
	    return function(obj, iteratee, context) {
	      var result = partition ? [[], []] : {};
	      iteratee = cb(iteratee, context);
	      each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  }

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  var groupBy = group(function(result, value, key) {
	    if (_has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  var indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  var countBy = group(function(result, value, key) {
	    if (_has(result, key)) result[key]++; else result[key] = 1;
	  });

	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
	  // Safely create a real, live array from anything iterable.
	  function toArray(obj) {
	    if (!obj) return [];
	    if (isArray(obj)) return slice.call(obj);
	    if (isString(obj)) {
	      // Keep surrogate pair characters together
	      return obj.match(reStrSymbol);
	    }
	    if (isArrayLike(obj)) return map(obj, identity);
	    return values(obj);
	  }

	  // Return the number of elements in an object.
	  function size(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : keys(obj).length;
	  }

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  var partition = group(function(result, value, pass) {
	    result[pass ? 0 : 1].push(value);
	  }, true);

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. The **guard** check allows it to work with `map`.
	  function first(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[0];
	    return initial(array, array.length - n);
	  }

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  function initial(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  }

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  function last(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[array.length - 1];
	    return rest(array, Math.max(0, array.length - n));
	  }

	  // Returns everything but the first entry of the array. Especially useful on
	  // the arguments object. Passing an **n** will return the rest N values in the
	  // array.
	  function rest(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  }

	  // Trim out all falsy values from an array.
	  function compact(array) {
	    return filter(array, Boolean);
	  }

	  // Internal implementation of a recursive `flatten` function.
	  function _flatten(input, shallow, strict, output) {
	    output = output || [];
	    var idx = output.length;
	    for (var i = 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (isArray(value) || isArguments(value))) {
	        // Flatten current level of array or arguments object.
	        if (shallow) {
	          var j = 0, len = value.length;
	          while (j < len) output[idx++] = value[j++];
	        } else {
	          _flatten(value, shallow, strict, output);
	          idx = output.length;
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  }

	  // Flatten out an array, either recursively (by default), or just one level.
	  function flatten(array, shallow) {
	    return _flatten(array, shallow, false);
	  }

	  // Return a version of the array that does not contain the specified value(s).
	  var without = restArguments(function(array, otherArrays) {
	    return difference(array, otherArrays);
	  });

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // The faster algorithm will not work with an iteratee if the iteratee
	  // is not a one-to-one function, so providing an iteratee will disable
	  // the faster algorithm.
	  function uniq(array, isSorted, iteratee, context) {
	    if (!isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted && !iteratee) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  var union = restArguments(function(arrays) {
	    return uniq(_flatten(arrays, true, true));
	  });

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  function intersection(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (contains(result, item)) continue;
	      var j;
	      for (j = 1; j < argsLength; j++) {
	        if (!contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  }

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  var difference = restArguments(function(array, rest) {
	    rest = _flatten(rest, true, true);
	    return filter(array, function(value){
	      return !contains(rest, value);
	    });
	  });

	  // Complement of zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices.
	  function unzip(array) {
	    var length = array && max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = pluck(array, index);
	    }
	    return result;
	  }

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  var zip = restArguments(unzip);

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values. Passing by pairs is the reverse of pairs.
	  function object(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  }

	  // Generator function to create the findIndex and findLastIndex functions.
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test.
	  var findIndex = createPredicateIndexFinder(1);
	  var findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  function sortedIndex(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  }

	  // Generator function to create the indexOf and lastIndexOf functions.
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	          i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  var indexOf = createIndexFinder(1, findIndex, sortedIndex);
	  var lastIndexOf = createIndexFinder(-1, findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](https://docs.python.org/library/functions.html#range).
	  function range(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    if (!step) {
	      step = stop < start ? -1 : 1;
	    }

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  }

	  // Chunk a single array into multiple arrays, each containing `count` or fewer
	  // items.
	  function chunk(array, count) {
	    if (count == null || count < 1) return [];
	    var result = [];
	    var i = 0, length = array.length;
	    while (i < length) {
	      result.push(slice.call(array, i, i += count));
	    }
	    return result;
	  }

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments.
	  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (isObject(result)) return result;
	    return self;
	  }

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  var bind = restArguments(function(func, context, args) {
	    if (!isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var bound = restArguments(function(callArgs) {
	      return executeBound(func, bound, context, this, args.concat(callArgs));
	    });
	    return bound;
	  });

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder by default, allowing any combination of arguments to be
	  // pre-filled. Set `partial.placeholder` for a custom placeholder argument.
	  var partial = restArguments(function(func, boundArgs) {
	    var placeholder = partial.placeholder;
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  });

	  partial.placeholder = _;

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  var bindAll = restArguments(function(obj, _keys) {
	    _keys = _flatten(_keys, false, false);
	    var index = _keys.length;
	    if (index < 1) throw new Error('bindAll must be passed function names');
	    while (index--) {
	      var key = _keys[index];
	      obj[key] = bind(obj[key], obj);
	    }
	  });

	  // Memoize an expensive function by storing its results.
	  function memoize(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  }

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  var delay = restArguments(function(func, wait, args) {
	    return setTimeout(function() {
	      return func.apply(null, args);
	    }, wait);
	  });

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  var defer = partial(delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  function throttle(func, wait, options) {
	    var timeout, context, args, result;
	    var previous = 0;
	    if (!options) options = {};

	    var later = function() {
	      previous = options.leading === false ? 0 : now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };

	    var throttled = function() {
	      var _now = now();
	      if (!previous && options.leading === false) previous = _now;
	      var remaining = wait - (_now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = _now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };

	    throttled.cancel = function() {
	      clearTimeout(timeout);
	      previous = 0;
	      timeout = context = args = null;
	    };

	    return throttled;
	  }

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  function debounce(func, wait, immediate) {
	    var timeout, result;

	    var later = function(context, args) {
	      timeout = null;
	      if (args) result = func.apply(context, args);
	    };

	    var debounced = restArguments(function(args) {
	      if (timeout) clearTimeout(timeout);
	      if (immediate) {
	        var callNow = !timeout;
	        timeout = setTimeout(later, wait);
	        if (callNow) result = func.apply(this, args);
	      } else {
	        timeout = delay(later, wait, this, args);
	      }

	      return result;
	    });

	    debounced.cancel = function() {
	      clearTimeout(timeout);
	      timeout = null;
	    };

	    return debounced;
	  }

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  function wrap(func, wrapper) {
	    return partial(wrapper, func);
	  }

	  // Returns a negated version of the passed-in predicate.
	  function negate(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  }

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  function compose() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  }

	  // Returns a function that will only be executed on and after the Nth call.
	  function after(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  }

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  function before(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  }

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  var once = partial(before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, _keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = isFunction(constructor) && constructor.prototype || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_has(obj, prop) && !contains(_keys, prop)) _keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !contains(_keys, prop)) {
	        _keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
	  function keys(obj) {
	    if (!isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var _keys = [];
	    for (var key in obj) if (_has(obj, key)) _keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, _keys);
	    return _keys;
	  }

	  // Retrieve all the property names of an object.
	  function allKeys(obj) {
	    if (!isObject(obj)) return [];
	    var _keys = [];
	    for (var key in obj) _keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, _keys);
	    return _keys;
	  }

	  // Retrieve the values of an object's properties.
	  function values(obj) {
	    var _keys = keys(obj);
	    var length = _keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[_keys[i]];
	    }
	    return values;
	  }

	  // Returns the results of applying the iteratee to each element of the object.
	  // In contrast to map it returns an object.
	  function mapObject(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var _keys = keys(obj),
	        length = _keys.length,
	        results = {};
	    for (var index = 0; index < length; index++) {
	      var currentKey = _keys[index];
	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  }

	  // Convert an object into a list of `[key, value]` pairs.
	  // The opposite of object.
	  function pairs(obj) {
	    var _keys = keys(obj);
	    var length = _keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [_keys[i], obj[_keys[i]]];
	    }
	    return pairs;
	  }

	  // Invert the keys and values of an object. The values must be serializable.
	  function invert(obj) {
	    var result = {};
	    var _keys = keys(obj);
	    for (var i = 0, length = _keys.length; i < length; i++) {
	      result[obj[_keys[i]]] = _keys[i];
	    }
	    return result;
	  }

	  // Return a sorted list of the function names available on the object.
	  function functions(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  }

	  // An internal function for creating assigner functions.
	  function createAssigner(keysFunc, defaults) {
	    return function(obj) {
	      var length = arguments.length;
	      if (defaults) obj = Object(obj);
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            _keys = keysFunc(source),
	            l = _keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = _keys[i];
	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  }

	  // Extend a given object with all the properties in passed-in object(s).
	  var extend = createAssigner(allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s).
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  var extendOwn = createAssigner(keys);

	  // Returns the first key on an object that passes a predicate test.
	  function findKey(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var _keys = keys(obj), key;
	    for (var i = 0, length = _keys.length; i < length; i++) {
	      key = _keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  }

	  // Internal pick helper function to determine if `obj` has key `key`.
	  function keyInObj(value, key, obj) {
	    return key in obj;
	  }

	  // Return a copy of the object only containing the whitelisted properties.
	  var pick = restArguments(function(obj, _keys) {
	    var result = {}, iteratee = _keys[0];
	    if (obj == null) return result;
	    if (isFunction(iteratee)) {
	      if (_keys.length > 1) iteratee = optimizeCb(iteratee, _keys[1]);
	      _keys = allKeys(obj);
	    } else {
	      iteratee = keyInObj;
	      _keys = _flatten(_keys, false, false);
	      obj = Object(obj);
	    }
	    for (var i = 0, length = _keys.length; i < length; i++) {
	      var key = _keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  });

	  // Return a copy of the object without the blacklisted properties.
	  var omit = restArguments(function(obj, _keys) {
	    var iteratee = _keys[0], context;
	    if (isFunction(iteratee)) {
	      iteratee = negate(iteratee);
	      if (_keys.length > 1) context = _keys[1];
	    } else {
	      _keys = map(_flatten(_keys, false, false), String);
	      iteratee = function(value, key) {
	        return !contains(_keys, key);
	      };
	    }
	    return pick(obj, iteratee, context);
	  });

	  // Fill in a given object with default properties.
	  var defaults = createAssigner(allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  function create(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) extendOwn(result, props);
	    return result;
	  }

	  // Create a (shallow-cloned) duplicate of an object.
	  function clone(obj) {
	    if (!isObject(obj)) return obj;
	    return isArray(obj) ? obj.slice() : extend({}, obj);
	  }

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  function tap(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  }

	  // Returns whether an object has a given set of `key:value` pairs.
	  function isMatch(object, attrs) {
	    var _keys = keys(attrs), length = _keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = _keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  }


	  // Internal recursive comparison function for `isEqual`.
	  function eq(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // `null` or `undefined` only equal to itself (strict comparison).
	    if (a == null || b == null) return false;
	    // `NaN`s are equivalent, but non-reflexive.
	    if (a !== a) return b !== b;
	    // Exhaust primitive checks
	    var type = typeof a;
	    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
	    return deepEq(a, b, aStack, bStack);
	  }

	  // Internal recursive comparison function for `isEqual`.
	  function deepEq(a, b, aStack, bStack) {
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN.
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	      case '[object Symbol]':
	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&
	                               isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var _keys = keys(a), key;
	      length = _keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = _keys[length];
	        if (!(_has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  }

	  // Perform a deep comparison to check if two objects are equal.
	  function isEqual(a, b) {
	    return eq(a, b);
	  }

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  function isEmpty(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (isArray(obj) || isString(obj) || isArguments(obj))) return obj.length === 0;
	    return keys(obj).length === 0;
	  }

	  // Is a given value a DOM element?
	  function isElement(obj) {
	    return !!(obj && obj.nodeType === 1);
	  }

	  // Internal function for creating a toString-based type tester.
	  function tagTester(name) {
	    return function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  }

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  var isArray = nativeIsArray || tagTester('Array');

	  // Is a given variable an object?
	  function isObject(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  }

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
	  var isArguments = tagTester('Arguments');
	  var isFunction = tagTester('Function');
	  var isString = tagTester('String');
	  var isNumber = tagTester('Number');
	  var isDate = tagTester('Date');
	  var isRegExp = tagTester('RegExp');
	  var isError = tagTester('Error');
	  var isSymbol = tagTester('Symbol');
	  var isMap = tagTester('Map');
	  var isWeakMap = tagTester('WeakMap');
	  var isSet = tagTester('Set');
	  var isWeakSet = tagTester('WeakSet');

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  (function() {
	    if (!isArguments(arguments)) {
	      isArguments = function(obj) {
	        return _has(obj, 'callee');
	      };
	    }
	  }());

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
	  var nodelist = root.document && root.document.childNodes;
	  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
	    isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  function isFinite(obj) {
	    return !isSymbol(obj) && _isFinite(obj) && !_isNaN(parseFloat(obj));
	  }

	  // Is the given value `NaN`?
	  function isNaN(obj) {
	    return isNumber(obj) && _isNaN(obj);
	  }

	  // Is a given value a boolean?
	  function isBoolean(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  }

	  // Is a given value equal to null?
	  function isNull(obj) {
	    return obj === null;
	  }

	  // Is a given variable undefined?
	  function isUndefined(obj) {
	    return obj === void 0;
	  }

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  function has(obj, path) {
	    if (!isArray(path)) {
	      return _has(obj, path);
	    }
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      var key = path[i];
	      if (obj == null || !hasOwnProperty.call(obj, key)) {
	        return false;
	      }
	      obj = obj[key];
	    }
	    return !!length;
	  }

	  // Utility Functions
	  // -----------------

	  // Keep the identity function around for default iteratees.
	  function identity(value) {
	    return value;
	  }

	  // Predicate-generating functions. Often useful outside of Underscore.
	  function constant(value) {
	    return function() {
	      return value;
	    };
	  }

	  function noop(){}

	  // Creates a function that, when passed an object, will traverse that object’s
	  // properties down the given `path`, specified as an array of keys or indexes.
	  function property(path) {
	    if (!isArray(path)) {
	      return shallowProperty(path);
	    }
	    return function(obj) {
	      return deepGet(obj, path);
	    };
	  }

	  // Generates a function for a given object that returns a given property.
	  function propertyOf(obj) {
	    if (obj == null) {
	      return function(){};
	    }
	    return function(path) {
	      return !isArray(path) ? obj[path] : deepGet(obj, path);
	    };
	  }

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  function matcher(attrs) {
	    attrs = extendOwn({}, attrs);
	    return function(obj) {
	      return isMatch(obj, attrs);
	    };
	  }

	  // Run a function **n** times.
	  function times(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  }

	  // Return a random integer between min and max (inclusive).
	  function random(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  }

	  // A (possibly faster) way to get the current timestamp as an integer.
	  var now = Date.now || function() {
	    return new Date().getTime();
	  };

	  // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  function createEscaper(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped.
	    var source = '(?:' + keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  }
	  var escape = createEscaper(escapeMap);
	  var unescape = createEscaper(unescapeMap);

	  // Traverses the children of `obj` along `path`. If a child is a function, it
	  // is invoked with its parent as context. Returns the value of the final
	  // child, or `fallback` if any child is undefined.
	  function result(obj, path, fallback) {
	    if (!isArray(path)) path = [path];
	    var length = path.length;
	    if (!length) {
	      return isFunction(fallback) ? fallback.call(obj) : fallback;
	    }
	    for (var i = 0; i < length; i++) {
	      var prop = obj == null ? void 0 : obj[path[i]];
	      if (prop === void 0) {
	        prop = fallback;
	        i = length; // Ensure we don't continue iterating.
	      }
	      obj = isFunction(prop) ? prop.call(obj) : prop;
	    }
	    return obj;
	  }

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  function uniqueId(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  }

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  var templateSettings = _.templateSettings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'": "'",
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  function template(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offset.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    var render;
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  }

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  function chain(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  }

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  function chainResult(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  }

	  // Add your own custom functions to the Underscore object.
	  function mixin(obj) {
	    each(functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return chainResult(this, func.apply(_, args));
	      };
	    });
	    return _;
	  }

	  // Add all mutator Array functions to the wrapper.
	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return chainResult(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return chainResult(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return String(this._wrapped);
	  };

	  var allExports = ({
	    'default': _,
	    VERSION: VERSION,
	    iteratee: iteratee,
	    restArguments: restArguments,
	    each: each,
	    forEach: each,
	    map: map,
	    collect: map,
	    reduce: reduce,
	    foldl: reduce,
	    inject: reduce,
	    reduceRight: reduceRight,
	    foldr: reduceRight,
	    find: find,
	    detect: find,
	    filter: filter,
	    select: filter,
	    reject: reject,
	    every: every,
	    all: every,
	    some: some,
	    any: some,
	    contains: contains,
	    includes: contains,
	    include: contains,
	    invoke: invoke,
	    pluck: pluck,
	    where: where,
	    findWhere: findWhere,
	    max: max,
	    min: min,
	    shuffle: shuffle,
	    sample: sample,
	    sortBy: sortBy,
	    groupBy: groupBy,
	    indexBy: indexBy,
	    countBy: countBy,
	    toArray: toArray,
	    size: size,
	    partition: partition,
	    first: first,
	    head: first,
	    take: first,
	    initial: initial,
	    last: last,
	    rest: rest,
	    tail: rest,
	    drop: rest,
	    compact: compact,
	    flatten: flatten,
	    without: without,
	    uniq: uniq,
	    unique: uniq,
	    union: union,
	    intersection: intersection,
	    difference: difference,
	    unzip: unzip,
	    zip: zip,
	    object: object,
	    findIndex: findIndex,
	    findLastIndex: findLastIndex,
	    sortedIndex: sortedIndex,
	    indexOf: indexOf,
	    lastIndexOf: lastIndexOf,
	    range: range,
	    chunk: chunk,
	    bind: bind,
	    partial: partial,
	    bindAll: bindAll,
	    memoize: memoize,
	    delay: delay,
	    defer: defer,
	    throttle: throttle,
	    debounce: debounce,
	    wrap: wrap,
	    negate: negate,
	    compose: compose,
	    after: after,
	    before: before,
	    once: once,
	    keys: keys,
	    allKeys: allKeys,
	    values: values,
	    mapObject: mapObject,
	    pairs: pairs,
	    invert: invert,
	    functions: functions,
	    methods: functions,
	    extend: extend,
	    extendOwn: extendOwn,
	    assign: extendOwn,
	    findKey: findKey,
	    pick: pick,
	    omit: omit,
	    defaults: defaults,
	    create: create,
	    clone: clone,
	    tap: tap,
	    isMatch: isMatch,
	    isEqual: isEqual,
	    isEmpty: isEmpty,
	    isElement: isElement,
	    isArray: isArray,
	    isObject: isObject,
	    isArguments: isArguments,
	    isFunction: isFunction,
	    isString: isString,
	    isNumber: isNumber,
	    isDate: isDate,
	    isRegExp: isRegExp,
	    isError: isError,
	    isSymbol: isSymbol,
	    isMap: isMap,
	    isWeakMap: isWeakMap,
	    isSet: isSet,
	    isWeakSet: isWeakSet,
	    isFinite: isFinite,
	    isNaN: isNaN,
	    isBoolean: isBoolean,
	    isNull: isNull,
	    isUndefined: isUndefined,
	    has: has,
	    identity: identity,
	    constant: constant,
	    noop: noop,
	    property: property,
	    propertyOf: propertyOf,
	    matcher: matcher,
	    matches: matcher,
	    times: times,
	    random: random,
	    now: now,
	    escape: escape,
	    unescape: unescape,
	    result: result,
	    uniqueId: uniqueId,
	    templateSettings: templateSettings,
	    template: template,
	    chain: chain,
	    mixin: mixin
	  });

	  // Add all of the Underscore functions to the wrapper object.
	  var _$1 = mixin(allExports);
	  // Legacy Node.js API
	  _$1._ = _$1;

	  return _$1;

	})));
	//# sourceMappingURL=underscore.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', { value: true });

	var d3Array = __webpack_require__(6);
	var d3Axis = __webpack_require__(7);
	var d3Brush = __webpack_require__(8);
	var d3Chord = __webpack_require__(17);
	var d3Collection = __webpack_require__(19);
	var d3Color = __webpack_require__(13);
	var d3Contour = __webpack_require__(20);
	var d3Dispatch = __webpack_require__(9);
	var d3Drag = __webpack_require__(10);
	var d3Dsv = __webpack_require__(21);
	var d3Ease = __webpack_require__(16);
	var d3Fetch = __webpack_require__(22);
	var d3Force = __webpack_require__(23);
	var d3Format = __webpack_require__(25);
	var d3Geo = __webpack_require__(26);
	var d3Hierarchy = __webpack_require__(27);
	var d3Interpolate = __webpack_require__(12);
	var d3Path = __webpack_require__(18);
	var d3Polygon = __webpack_require__(28);
	var d3Quadtree = __webpack_require__(24);
	var d3Random = __webpack_require__(29);
	var d3Scale = __webpack_require__(30);
	var d3ScaleChromatic = __webpack_require__(33);
	var d3Selection = __webpack_require__(11);
	var d3Shape = __webpack_require__(34);
	var d3Time = __webpack_require__(31);
	var d3TimeFormat = __webpack_require__(32);
	var d3Timer = __webpack_require__(15);
	var d3Transition = __webpack_require__(14);
	var d3Voronoi = __webpack_require__(35);
	var d3Zoom = __webpack_require__(36);

	var version = "5.16.0";

	Object.keys(d3Array).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Array[k];
			}
		});
	});
	Object.keys(d3Axis).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Axis[k];
			}
		});
	});
	Object.keys(d3Brush).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Brush[k];
			}
		});
	});
	Object.keys(d3Chord).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Chord[k];
			}
		});
	});
	Object.keys(d3Collection).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Collection[k];
			}
		});
	});
	Object.keys(d3Color).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Color[k];
			}
		});
	});
	Object.keys(d3Contour).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Contour[k];
			}
		});
	});
	Object.keys(d3Dispatch).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Dispatch[k];
			}
		});
	});
	Object.keys(d3Drag).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Drag[k];
			}
		});
	});
	Object.keys(d3Dsv).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Dsv[k];
			}
		});
	});
	Object.keys(d3Ease).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Ease[k];
			}
		});
	});
	Object.keys(d3Fetch).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Fetch[k];
			}
		});
	});
	Object.keys(d3Force).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Force[k];
			}
		});
	});
	Object.keys(d3Format).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Format[k];
			}
		});
	});
	Object.keys(d3Geo).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Geo[k];
			}
		});
	});
	Object.keys(d3Hierarchy).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Hierarchy[k];
			}
		});
	});
	Object.keys(d3Interpolate).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Interpolate[k];
			}
		});
	});
	Object.keys(d3Path).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Path[k];
			}
		});
	});
	Object.keys(d3Polygon).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Polygon[k];
			}
		});
	});
	Object.keys(d3Quadtree).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Quadtree[k];
			}
		});
	});
	Object.keys(d3Random).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Random[k];
			}
		});
	});
	Object.keys(d3Scale).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Scale[k];
			}
		});
	});
	Object.keys(d3ScaleChromatic).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3ScaleChromatic[k];
			}
		});
	});
	Object.keys(d3Selection).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Selection[k];
			}
		});
	});
	Object.keys(d3Shape).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Shape[k];
			}
		});
	});
	Object.keys(d3Time).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Time[k];
			}
		});
	});
	Object.keys(d3TimeFormat).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3TimeFormat[k];
			}
		});
	});
	Object.keys(d3Timer).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Timer[k];
			}
		});
	});
	Object.keys(d3Transition).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Transition[k];
			}
		});
	});
	Object.keys(d3Voronoi).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Voronoi[k];
			}
		});
	});
	Object.keys(d3Zoom).forEach(function (k) {
		if (k !== 'default') Object.defineProperty(exports, k, {
			enumerable: true,
			get: function () {
				return d3Zoom[k];
			}
		});
	});
	exports.version = version;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	function pairs(array, f) {
	  if (f == null) f = pair;
	  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	  while (i < n) pairs[i] = f(p, p = array[++i]);
	  return pairs;
	}

	function pair(a, b) {
	  return [a, b];
	}

	function cross(values0, values1, reduce) {
	  var n0 = values0.length,
	      n1 = values1.length,
	      values = new Array(n0 * n1),
	      i0,
	      i1,
	      i,
	      value0;

	  if (reduce == null) reduce = pair;

	  for (i0 = i = 0; i0 < n0; ++i0) {
	    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	      values[i] = reduce(value0, values1[i1]);
	    }
	  }

	  return values;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function deviation(array, f) {
	  var v = variance(array, f);
	  return v ? Math.sqrt(v) : v;
	}

	function extent(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  return [min, max];
	}

	var array = Array.prototype;

	var slice = array.slice;
	var map = array.map;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function identity(x) {
	  return x;
	}

	function range(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sturges(values) {
	  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	}

	function histogram() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	}

	function quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function freedmanDiaconis(values, min, max) {
	  values = map.call(values, number).sort(ascending);
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	}

	function scott(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	}

	function max(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	}

	function mean(values, valueof) {
	  var n = values.length,
	      m = n,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) sum += value;
	      else --m;
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	      else --m;
	    }
	  }

	  if (m) return sum / m;
	}

	function median(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      numbers = [];

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        numbers.push(value);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        numbers.push(value);
	      }
	    }
	  }

	  return quantile(numbers.sort(ascending), 0.5);
	}

	function merge(arrays) {
	  var n = arrays.length,
	      m,
	      i = -1,
	      j = 0,
	      merged,
	      array;

	  while (++i < n) j += arrays[i].length;
	  merged = new Array(j);

	  while (--n >= 0) {
	    array = arrays[n];
	    m = array.length;
	    while (--m >= 0) {
	      merged[--j] = array[m];
	    }
	  }

	  return merged;
	}

	function min(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	function permute(array, indexes) {
	  var i = indexes.length, permutes = new Array(i);
	  while (i--) permutes[i] = array[indexes[i]];
	  return permutes;
	}

	function scan(values, compare) {
	  if (!(n = values.length)) return;
	  var n,
	      i = 0,
	      j = 0,
	      xi,
	      xj = values[j];

	  if (compare == null) compare = ascending;

	  while (++i < n) {
	    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	      xj = xi, j = i;
	    }
	  }

	  if (compare(xj, xj) === 0) return j;
	}

	function shuffle(array, i0, i1) {
	  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	}

	function sum(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	    }
	  }

	  else {
	    while (++i < n) {
	      if (value = +valueof(values[i], i, values)) sum += value;
	    }
	  }

	  return sum;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	exports.bisect = bisectRight;
	exports.bisectRight = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.ascending = ascending;
	exports.bisector = bisector;
	exports.cross = cross;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.histogram = histogram;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.max = max;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.range = range;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.ticks = ticks;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-axis/ v1.0.12 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var slice = Array.prototype.slice;

	function identity(x) {
	  return x;
	}

	var top = 1,
	    right = 2,
	    bottom = 3,
	    left = 4,
	    epsilon = 1e-6;

	function translateX(x) {
	  return "translate(" + (x + 0.5) + ",0)";
	}

	function translateY(y) {
	  return "translate(0," + (y + 0.5) + ")";
	}

	function number(scale) {
	  return function(d) {
	    return +scale(d);
	  };
	}

	function center(scale) {
	  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
	  if (scale.round()) offset = Math.round(offset);
	  return function(d) {
	    return +scale(d) + offset;
	  };
	}

	function entering() {
	  return !this.__axis;
	}

	function axis(orient, scale) {
	  var tickArguments = [],
	      tickValues = null,
	      tickFormat = null,
	      tickSizeInner = 6,
	      tickSizeOuter = 6,
	      tickPadding = 3,
	      k = orient === top || orient === left ? -1 : 1,
	      x = orient === left || orient === right ? "x" : "y",
	      transform = orient === top || orient === bottom ? translateX : translateY;

	  function axis(context) {
	    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
	        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
	        spacing = Math.max(tickSizeInner, 0) + tickPadding,
	        range = scale.range(),
	        range0 = +range[0] + 0.5,
	        range1 = +range[range.length - 1] + 0.5,
	        position = (scale.bandwidth ? center : number)(scale.copy()),
	        selection = context.selection ? context.selection() : context,
	        path = selection.selectAll(".domain").data([null]),
	        tick = selection.selectAll(".tick").data(values, scale).order(),
	        tickExit = tick.exit(),
	        tickEnter = tick.enter().append("g").attr("class", "tick"),
	        line = tick.select("line"),
	        text = tick.select("text");

	    path = path.merge(path.enter().insert("path", ".tick")
	        .attr("class", "domain")
	        .attr("stroke", "currentColor"));

	    tick = tick.merge(tickEnter);

	    line = line.merge(tickEnter.append("line")
	        .attr("stroke", "currentColor")
	        .attr(x + "2", k * tickSizeInner));

	    text = text.merge(tickEnter.append("text")
	        .attr("fill", "currentColor")
	        .attr(x, k * spacing)
	        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

	    if (context !== selection) {
	      path = path.transition(context);
	      tick = tick.transition(context);
	      line = line.transition(context);
	      text = text.transition(context);

	      tickExit = tickExit.transition(context)
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

	      tickEnter
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
	    }

	    tickExit.remove();

	    path
	        .attr("d", orient === left || orient == right
	            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
	            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

	    tick
	        .attr("opacity", 1)
	        .attr("transform", function(d) { return transform(position(d)); });

	    line
	        .attr(x + "2", k * tickSizeInner);

	    text
	        .attr(x, k * spacing)
	        .text(format);

	    selection.filter(entering)
	        .attr("fill", "none")
	        .attr("font-size", 10)
	        .attr("font-family", "sans-serif")
	        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

	    selection
	        .each(function() { this.__axis = position; });
	  }

	  axis.scale = function(_) {
	    return arguments.length ? (scale = _, axis) : scale;
	  };

	  axis.ticks = function() {
	    return tickArguments = slice.call(arguments), axis;
	  };

	  axis.tickArguments = function(_) {
	    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
	  };

	  axis.tickValues = function(_) {
	    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
	  };

	  axis.tickFormat = function(_) {
	    return arguments.length ? (tickFormat = _, axis) : tickFormat;
	  };

	  axis.tickSize = function(_) {
	    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeInner = function(_) {
	    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeOuter = function(_) {
	    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
	  };

	  axis.tickPadding = function(_) {
	    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
	  };

	  return axis;
	}

	function axisTop(scale) {
	  return axis(top, scale);
	}

	function axisRight(scale) {
	  return axis(right, scale);
	}

	function axisBottom(scale) {
	  return axis(bottom, scale);
	}

	function axisLeft(scale) {
	  return axis(left, scale);
	}

	exports.axisTop = axisTop;
	exports.axisRight = axisRight;
	exports.axisBottom = axisBottom;
	exports.axisLeft = axisLeft;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-brush/ v1.1.5 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(9), __webpack_require__(10), __webpack_require__(12), __webpack_require__(11), __webpack_require__(14)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function BrushEvent(target, type, selection) {
	  this.target = target;
	  this.type = type;
	  this.selection = selection;
	}

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	function noevent() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	}

	var MODE_DRAG = {name: "drag"},
	    MODE_SPACE = {name: "space"},
	    MODE_HANDLE = {name: "handle"},
	    MODE_CENTER = {name: "center"};

	function number1(e) {
	  return [+e[0], +e[1]];
	}

	function number2(e) {
	  return [number1(e[0]), number1(e[1])];
	}

	function toucher(identifier) {
	  return function(target) {
	    return d3Selection.touch(target, d3Selection.event.touches, identifier);
	  };
	}

	var X = {
	  name: "x",
	  handles: ["w", "e"].map(type),
	  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
	  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
	};

	var Y = {
	  name: "y",
	  handles: ["n", "s"].map(type),
	  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
	  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
	};

	var XY = {
	  name: "xy",
	  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
	  input: function(xy) { return xy == null ? null : number2(xy); },
	  output: function(xy) { return xy; }
	};

	var cursors = {
	  overlay: "crosshair",
	  selection: "move",
	  n: "ns-resize",
	  e: "ew-resize",
	  s: "ns-resize",
	  w: "ew-resize",
	  nw: "nwse-resize",
	  ne: "nesw-resize",
	  se: "nwse-resize",
	  sw: "nesw-resize"
	};

	var flipX = {
	  e: "w",
	  w: "e",
	  nw: "ne",
	  ne: "nw",
	  se: "sw",
	  sw: "se"
	};

	var flipY = {
	  n: "s",
	  s: "n",
	  nw: "sw",
	  ne: "se",
	  se: "ne",
	  sw: "nw"
	};

	var signsX = {
	  overlay: +1,
	  selection: +1,
	  n: null,
	  e: +1,
	  s: null,
	  w: -1,
	  nw: -1,
	  ne: +1,
	  se: +1,
	  sw: -1
	};

	var signsY = {
	  overlay: +1,
	  selection: +1,
	  n: -1,
	  e: null,
	  s: +1,
	  w: null,
	  nw: -1,
	  ne: -1,
	  se: +1,
	  sw: +1
	};

	function type(t) {
	  return {type: t};
	}

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
	}

	function defaultExtent() {
	  var svg = this.ownerSVGElement || this;
	  if (svg.hasAttribute("viewBox")) {
	    svg = svg.viewBox.baseVal;
	    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
	  }
	  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
	}

	function defaultTouchable() {
	  return navigator.maxTouchPoints || ("ontouchstart" in this);
	}

	// Like d3.local, but with the name “__brush” rather than auto-generated.
	function local(node) {
	  while (!node.__brush) if (!(node = node.parentNode)) return;
	  return node.__brush;
	}

	function empty(extent) {
	  return extent[0][0] === extent[1][0]
	      || extent[0][1] === extent[1][1];
	}

	function brushSelection(node) {
	  var state = node.__brush;
	  return state ? state.dim.output(state.selection) : null;
	}

	function brushX() {
	  return brush$1(X);
	}

	function brushY() {
	  return brush$1(Y);
	}

	function brush() {
	  return brush$1(XY);
	}

	function brush$1(dim) {
	  var extent = defaultExtent,
	      filter = defaultFilter,
	      touchable = defaultTouchable,
	      keys = true,
	      listeners = d3Dispatch.dispatch("start", "brush", "end"),
	      handleSize = 6,
	      touchending;

	  function brush(group) {
	    var overlay = group
	        .property("__brush", initialize)
	      .selectAll(".overlay")
	      .data([type("overlay")]);

	    overlay.enter().append("rect")
	        .attr("class", "overlay")
	        .attr("pointer-events", "all")
	        .attr("cursor", cursors.overlay)
	      .merge(overlay)
	        .each(function() {
	          var extent = local(this).extent;
	          d3Selection.select(this)
	              .attr("x", extent[0][0])
	              .attr("y", extent[0][1])
	              .attr("width", extent[1][0] - extent[0][0])
	              .attr("height", extent[1][1] - extent[0][1]);
	        });

	    group.selectAll(".selection")
	      .data([type("selection")])
	      .enter().append("rect")
	        .attr("class", "selection")
	        .attr("cursor", cursors.selection)
	        .attr("fill", "#777")
	        .attr("fill-opacity", 0.3)
	        .attr("stroke", "#fff")
	        .attr("shape-rendering", "crispEdges");

	    var handle = group.selectAll(".handle")
	      .data(dim.handles, function(d) { return d.type; });

	    handle.exit().remove();

	    handle.enter().append("rect")
	        .attr("class", function(d) { return "handle handle--" + d.type; })
	        .attr("cursor", function(d) { return cursors[d.type]; });

	    group
	        .each(redraw)
	        .attr("fill", "none")
	        .attr("pointer-events", "all")
	        .on("mousedown.brush", started)
	      .filter(touchable)
	        .on("touchstart.brush", started)
	        .on("touchmove.brush", touchmoved)
	        .on("touchend.brush touchcancel.brush", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  brush.move = function(group, selection) {
	    if (group.selection) {
	      group
	          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
	          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
	          .tween("brush", function() {
	            var that = this,
	                state = that.__brush,
	                emit = emitter(that, arguments),
	                selection0 = state.selection,
	                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
	                i = d3Interpolate.interpolate(selection0, selection1);

	            function tween(t) {
	              state.selection = t === 1 && selection1 === null ? null : i(t);
	              redraw.call(that);
	              emit.brush();
	            }

	            return selection0 !== null && selection1 !== null ? tween : tween(1);
	          });
	    } else {
	      group
	          .each(function() {
	            var that = this,
	                args = arguments,
	                state = that.__brush,
	                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
	                emit = emitter(that, args).beforestart();

	            d3Transition.interrupt(that);
	            state.selection = selection1 === null ? null : selection1;
	            redraw.call(that);
	            emit.start().brush().end();
	          });
	    }
	  };

	  brush.clear = function(group) {
	    brush.move(group, null);
	  };

	  function redraw() {
	    var group = d3Selection.select(this),
	        selection = local(this).selection;

	    if (selection) {
	      group.selectAll(".selection")
	          .style("display", null)
	          .attr("x", selection[0][0])
	          .attr("y", selection[0][1])
	          .attr("width", selection[1][0] - selection[0][0])
	          .attr("height", selection[1][1] - selection[0][1]);

	      group.selectAll(".handle")
	          .style("display", null)
	          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
	          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
	          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
	          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
	    }

	    else {
	      group.selectAll(".selection,.handle")
	          .style("display", "none")
	          .attr("x", null)
	          .attr("y", null)
	          .attr("width", null)
	          .attr("height", null);
	    }
	  }

	  function emitter(that, args, clean) {
	    return (!clean && that.__brush.emitter) || new Emitter(that, args);
	  }

	  function Emitter(that, args) {
	    this.that = that;
	    this.args = args;
	    this.state = that.__brush;
	    this.active = 0;
	  }

	  Emitter.prototype = {
	    beforestart: function() {
	      if (++this.active === 1) this.state.emitter = this, this.starting = true;
	      return this;
	    },
	    start: function() {
	      if (this.starting) this.starting = false, this.emit("start");
	      else this.emit("brush");
	      return this;
	    },
	    brush: function() {
	      this.emit("brush");
	      return this;
	    },
	    end: function() {
	      if (--this.active === 0) delete this.state.emitter, this.emit("end");
	      return this;
	    },
	    emit: function(type) {
	      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
	    }
	  };

	  function started() {
	    if (touchending && !d3Selection.event.touches) return;
	    if (!filter.apply(this, arguments)) return;

	    var that = this,
	        type = d3Selection.event.target.__data__.type,
	        mode = (keys && d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
	        signX = dim === Y ? null : signsX[type],
	        signY = dim === X ? null : signsY[type],
	        state = local(that),
	        extent = state.extent,
	        selection = state.selection,
	        W = extent[0][0], w0, w1,
	        N = extent[0][1], n0, n1,
	        E = extent[1][0], e0, e1,
	        S = extent[1][1], s0, s1,
	        dx = 0,
	        dy = 0,
	        moving,
	        shifting = signX && signY && keys && d3Selection.event.shiftKey,
	        lockX,
	        lockY,
	        pointer = d3Selection.event.touches ? toucher(d3Selection.event.changedTouches[0].identifier) : d3Selection.mouse,
	        point0 = pointer(that),
	        point = point0,
	        emit = emitter(that, arguments, true).beforestart();

	    if (type === "overlay") {
	      if (selection) moving = true;
	      state.selection = selection = [
	        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
	        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
	      ];
	    } else {
	      w0 = selection[0][0];
	      n0 = selection[0][1];
	      e0 = selection[1][0];
	      s0 = selection[1][1];
	    }

	    w1 = w0;
	    n1 = n0;
	    e1 = e0;
	    s1 = s0;

	    var group = d3Selection.select(that)
	        .attr("pointer-events", "none");

	    var overlay = group.selectAll(".overlay")
	        .attr("cursor", cursors[type]);

	    if (d3Selection.event.touches) {
	      emit.moved = moved;
	      emit.ended = ended;
	    } else {
	      var view = d3Selection.select(d3Selection.event.view)
	          .on("mousemove.brush", moved, true)
	          .on("mouseup.brush", ended, true);
	      if (keys) view
	          .on("keydown.brush", keydowned, true)
	          .on("keyup.brush", keyupped, true);

	      d3Drag.dragDisable(d3Selection.event.view);
	    }

	    nopropagation();
	    d3Transition.interrupt(that);
	    redraw.call(that);
	    emit.start();

	    function moved() {
	      var point1 = pointer(that);
	      if (shifting && !lockX && !lockY) {
	        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
	        else lockX = true;
	      }
	      point = point1;
	      moving = true;
	      noevent();
	      move();
	    }

	    function move() {
	      var t;

	      dx = point[0] - point0[0];
	      dy = point[1] - point0[1];

	      switch (mode) {
	        case MODE_SPACE:
	        case MODE_DRAG: {
	          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
	          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
	          break;
	        }
	        case MODE_HANDLE: {
	          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
	          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
	          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
	          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
	          break;
	        }
	        case MODE_CENTER: {
	          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
	          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
	          break;
	        }
	      }

	      if (e1 < w1) {
	        signX *= -1;
	        t = w0, w0 = e0, e0 = t;
	        t = w1, w1 = e1, e1 = t;
	        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
	      }

	      if (s1 < n1) {
	        signY *= -1;
	        t = n0, n0 = s0, s0 = t;
	        t = n1, n1 = s1, s1 = t;
	        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
	      }

	      if (state.selection) selection = state.selection; // May be set by brush.move!
	      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
	      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

	      if (selection[0][0] !== w1
	          || selection[0][1] !== n1
	          || selection[1][0] !== e1
	          || selection[1][1] !== s1) {
	        state.selection = [[w1, n1], [e1, s1]];
	        redraw.call(that);
	        emit.brush();
	      }
	    }

	    function ended() {
	      nopropagation();
	      if (d3Selection.event.touches) {
	        if (d3Selection.event.touches.length) return;
	        if (touchending) clearTimeout(touchending);
	        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	      } else {
	        d3Drag.dragEnable(d3Selection.event.view, moving);
	        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
	      }
	      group.attr("pointer-events", "all");
	      overlay.attr("cursor", cursors.overlay);
	      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
	      if (empty(selection)) state.selection = null, redraw.call(that);
	      emit.end();
	    }

	    function keydowned() {
	      switch (d3Selection.event.keyCode) {
	        case 16: { // SHIFT
	          shifting = signX && signY;
	          break;
	        }
	        case 18: { // ALT
	          if (mode === MODE_HANDLE) {
	            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
	            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
	            mode = MODE_CENTER;
	            move();
	          }
	          break;
	        }
	        case 32: { // SPACE; takes priority over ALT
	          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
	            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
	            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
	            mode = MODE_SPACE;
	            overlay.attr("cursor", cursors.selection);
	            move();
	          }
	          break;
	        }
	        default: return;
	      }
	      noevent();
	    }

	    function keyupped() {
	      switch (d3Selection.event.keyCode) {
	        case 16: { // SHIFT
	          if (shifting) {
	            lockX = lockY = shifting = false;
	            move();
	          }
	          break;
	        }
	        case 18: { // ALT
	          if (mode === MODE_CENTER) {
	            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
	            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
	            mode = MODE_HANDLE;
	            move();
	          }
	          break;
	        }
	        case 32: { // SPACE
	          if (mode === MODE_SPACE) {
	            if (d3Selection.event.altKey) {
	              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
	              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
	              mode = MODE_CENTER;
	            } else {
	              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
	              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
	              mode = MODE_HANDLE;
	            }
	            overlay.attr("cursor", cursors[type]);
	            move();
	          }
	          break;
	        }
	        default: return;
	      }
	      noevent();
	    }
	  }

	  function touchmoved() {
	    emitter(this, arguments).moved();
	  }

	  function touchended() {
	    emitter(this, arguments).ended();
	  }

	  function initialize() {
	    var state = this.__brush || {selection: null};
	    state.extent = number2(extent.apply(this, arguments));
	    state.dim = dim;
	    return state;
	  }

	  brush.extent = function(_) {
	    return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
	  };

	  brush.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
	  };

	  brush.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush) : touchable;
	  };

	  brush.handleSize = function(_) {
	    return arguments.length ? (handleSize = +_, brush) : handleSize;
	  };

	  brush.keyModifiers = function(_) {
	    return arguments.length ? (keys = !!_, brush) : keys;
	  };

	  brush.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? brush : value;
	  };

	  return brush;
	}

	exports.brush = brush;
	exports.brushSelection = brushSelection;
	exports.brushX = brushX;
	exports.brushY = brushY;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-dispatch/ v1.0.6 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var noop = {value: function() {}};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }
	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {type: t, name: name};
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function(typename, callback) {
	    var _ = this._,
	        T = parseTypenames(typename + "", _),
	        t,
	        i = -1,
	        n = T.length;

	    // If no callback was specified, return the callback of the given type and name.
	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
	      return;
	    }

	    // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.
	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
	      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function() {
	    var copy = {}, _ = this._;
	    for (var t in _) copy[t] = _[t].slice();
	    return new Dispatch(copy);
	  },
	  call: function(type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function(type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }
	  if (callback != null) type.push({name: name, value: callback});
	  return type;
	}

	exports.dispatch = dispatch;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-drag/ v1.2.5 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(9), __webpack_require__(11)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
	}(this, function (exports, d3Dispatch, d3Selection) { 'use strict';

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	function noevent() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	}

	function nodrag(view) {
	  var root = view.document.documentElement,
	      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
	  if ("onselectstart" in root) {
	    selection.on("selectstart.drag", noevent, true);
	  } else {
	    root.__noselect = root.style.MozUserSelect;
	    root.style.MozUserSelect = "none";
	  }
	}

	function yesdrag(view, noclick) {
	  var root = view.document.documentElement,
	      selection = d3Selection.select(view).on("dragstart.drag", null);
	  if (noclick) {
	    selection.on("click.drag", noevent, true);
	    setTimeout(function() { selection.on("click.drag", null); }, 0);
	  }
	  if ("onselectstart" in root) {
	    selection.on("selectstart.drag", null);
	  } else {
	    root.style.MozUserSelect = root.__noselect;
	    delete root.__noselect;
	  }
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
	  this.target = target;
	  this.type = type;
	  this.subject = subject;
	  this.identifier = id;
	  this.active = active;
	  this.x = x;
	  this.y = y;
	  this.dx = dx;
	  this.dy = dy;
	  this._ = dispatch;
	}

	DragEvent.prototype.on = function() {
	  var value = this._.on.apply(this._, arguments);
	  return value === this._ ? this : value;
	};

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
	}

	function defaultContainer() {
	  return this.parentNode;
	}

	function defaultSubject(d) {
	  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
	}

	function defaultTouchable() {
	  return navigator.maxTouchPoints || ("ontouchstart" in this);
	}

	function drag() {
	  var filter = defaultFilter,
	      container = defaultContainer,
	      subject = defaultSubject,
	      touchable = defaultTouchable,
	      gestures = {},
	      listeners = d3Dispatch.dispatch("start", "drag", "end"),
	      active = 0,
	      mousedownx,
	      mousedowny,
	      mousemoving,
	      touchending,
	      clickDistance2 = 0;

	  function drag(selection) {
	    selection
	        .on("mousedown.drag", mousedowned)
	      .filter(touchable)
	        .on("touchstart.drag", touchstarted)
	        .on("touchmove.drag", touchmoved)
	        .on("touchend.drag touchcancel.drag", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
	    if (!gesture) return;
	    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
	    nodrag(d3Selection.event.view);
	    nopropagation();
	    mousemoving = false;
	    mousedownx = d3Selection.event.clientX;
	    mousedowny = d3Selection.event.clientY;
	    gesture("start");
	  }

	  function mousemoved() {
	    noevent();
	    if (!mousemoving) {
	      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
	      mousemoving = dx * dx + dy * dy > clickDistance2;
	    }
	    gestures.mouse("drag");
	  }

	  function mouseupped() {
	    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
	    yesdrag(d3Selection.event.view, mousemoving);
	    noevent();
	    gestures.mouse("end");
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var touches = d3Selection.event.changedTouches,
	        c = container.apply(this, arguments),
	        n = touches.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
	        nopropagation();
	        gesture("start");
	      }
	    }
	  }

	  function touchmoved() {
	    var touches = d3Selection.event.changedTouches,
	        n = touches.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches[i].identifier]) {
	        noevent();
	        gesture("drag");
	      }
	    }
	  }

	  function touchended() {
	    var touches = d3Selection.event.changedTouches,
	        n = touches.length, i, gesture;

	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches[i].identifier]) {
	        nopropagation();
	        gesture("end");
	      }
	    }
	  }

	  function beforestart(id, container, point, that, args) {
	    var p = point(container, id), s, dx, dy,
	        sublisteners = listeners.copy();

	    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
	      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
	      dx = s.x - p[0] || 0;
	      dy = s.y - p[1] || 0;
	      return true;
	    })) return;

	    return function gesture(type) {
	      var p0 = p, n;
	      switch (type) {
	        case "start": gestures[id] = gesture, n = active++; break;
	        case "end": delete gestures[id], --active; // nobreak
	        case "drag": p = point(container, id), n = active; break;
	      }
	      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
	    };
	  }

	  drag.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
	  };

	  drag.container = function(_) {
	    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
	  };

	  drag.subject = function(_) {
	    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
	  };

	  drag.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
	  };

	  drag.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? drag : value;
	  };

	  drag.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
	  };

	  return drag;
	}

	exports.drag = drag;
	exports.dragDisable = nodrag;
	exports.dragEnable = yesdrag;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-selection/ v1.4.1 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var xhtml = "http://www.w3.org/1999/xhtml";

	var namespaces = {
	  svg: "http://www.w3.org/2000/svg",
	  xhtml: xhtml,
	  xlink: "http://www.w3.org/1999/xlink",
	  xml: "http://www.w3.org/XML/1998/namespace",
	  xmlns: "http://www.w3.org/2000/xmlns/"
	};

	function namespace(name) {
	  var prefix = name += "", i = prefix.indexOf(":");
	  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
	}

	function creatorInherit(name) {
	  return function() {
	    var document = this.ownerDocument,
	        uri = this.namespaceURI;
	    return uri === xhtml && document.documentElement.namespaceURI === xhtml
	        ? document.createElement(name)
	        : document.createElementNS(uri, name);
	  };
	}

	function creatorFixed(fullname) {
	  return function() {
	    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	  };
	}

	function creator(name) {
	  var fullname = namespace(name);
	  return (fullname.local
	      ? creatorFixed
	      : creatorInherit)(fullname);
	}

	function none() {}

	function selector(selector) {
	  return selector == null ? none : function() {
	    return this.querySelector(selector);
	  };
	}

	function selection_select(select) {
	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function empty() {
	  return [];
	}

	function selectorAll(selector) {
	  return selector == null ? empty : function() {
	    return this.querySelectorAll(selector);
	  };
	}

	function selection_selectAll(select) {
	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        subgroups.push(select.call(node, node.__data__, i, group));
	        parents.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, parents);
	}

	function matcher(selector) {
	  return function() {
	    return this.matches(selector);
	  };
	}

	function selection_filter(match) {
	  if (typeof match !== "function") match = matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function sparse(update) {
	  return new Array(update.length);
	}

	function selection_enter() {
	  return new Selection(this._enter || this._groups.map(sparse), this._parents);
	}

	function EnterNode(parent, datum) {
	  this.ownerDocument = parent.ownerDocument;
	  this.namespaceURI = parent.namespaceURI;
	  this._next = null;
	  this._parent = parent;
	  this.__data__ = datum;
	}

	EnterNode.prototype = {
	  constructor: EnterNode,
	  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	  querySelector: function(selector) { return this._parent.querySelector(selector); },
	  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	};

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	var keyPrefix = "$"; // Protect against keys like “__proto__”.

	function bindIndex(parent, group, enter, update, exit, data) {
	  var i = 0,
	      node,
	      groupLength = group.length,
	      dataLength = data.length;

	  // Put any non-null nodes that fit into update.
	  // Put any null nodes into enter.
	  // Put any remaining data into enter.
	  for (; i < dataLength; ++i) {
	    if (node = group[i]) {
	      node.__data__ = data[i];
	      update[i] = node;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Put any non-null nodes that don’t fit into exit.
	  for (; i < groupLength; ++i) {
	    if (node = group[i]) {
	      exit[i] = node;
	    }
	  }
	}

	function bindKey(parent, group, enter, update, exit, data, key) {
	  var i,
	      node,
	      nodeByKeyValue = {},
	      groupLength = group.length,
	      dataLength = data.length,
	      keyValues = new Array(groupLength),
	      keyValue;

	  // Compute the key for each node.
	  // If multiple nodes have the same key, the duplicates are added to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if (node = group[i]) {
	      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	      if (keyValue in nodeByKeyValue) {
	        exit[i] = node;
	      } else {
	        nodeByKeyValue[keyValue] = node;
	      }
	    }
	  }

	  // Compute the key for each datum.
	  // If there a node associated with this key, join and add it to update.
	  // If there is not (or the key is a duplicate), add it to enter.
	  for (i = 0; i < dataLength; ++i) {
	    keyValue = keyPrefix + key.call(parent, data[i], i, data);
	    if (node = nodeByKeyValue[keyValue]) {
	      update[i] = node;
	      node.__data__ = data[i];
	      nodeByKeyValue[keyValue] = null;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Add any remaining nodes that were not bound to data to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	      exit[i] = node;
	    }
	  }
	}

	function selection_data(value, key) {
	  if (!value) {
	    data = new Array(this.size()), j = -1;
	    this.each(function(d) { data[++j] = d; });
	    return data;
	  }

	  var bind = key ? bindKey : bindIndex,
	      parents = this._parents,
	      groups = this._groups;

	  if (typeof value !== "function") value = constant(value);

	  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	    var parent = parents[j],
	        group = groups[j],
	        groupLength = group.length,
	        data = value.call(parent, parent && parent.__data__, j, parents),
	        dataLength = data.length,
	        enterGroup = enter[j] = new Array(dataLength),
	        updateGroup = update[j] = new Array(dataLength),
	        exitGroup = exit[j] = new Array(groupLength);

	    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	    // Now connect the enter nodes to their following update node, such that
	    // appendChild can insert the materialized enter node before this node,
	    // rather than at the end of the parent node.
	    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	      if (previous = enterGroup[i0]) {
	        if (i0 >= i1) i1 = i0 + 1;
	        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	        previous._next = next || null;
	      }
	    }
	  }

	  update = new Selection(update, parents);
	  update._enter = enter;
	  update._exit = exit;
	  return update;
	}

	function selection_exit() {
	  return new Selection(this._exit || this._groups.map(sparse), this._parents);
	}

	function selection_join(onenter, onupdate, onexit) {
	  var enter = this.enter(), update = this, exit = this.exit();
	  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
	  if (onupdate != null) update = onupdate(update);
	  if (onexit == null) exit.remove(); else onexit(exit);
	  return enter && update ? enter.merge(update).order() : update;
	}

	function selection_merge(selection) {

	  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Selection(merges, this._parents);
	}

	function selection_order() {

	  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	      if (node = group[i]) {
	        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
	        next = node;
	      }
	    }
	  }

	  return this;
	}

	function selection_sort(compare) {
	  if (!compare) compare = ascending;

	  function compareNode(a, b) {
	    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	  }

	  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        sortgroup[i] = node;
	      }
	    }
	    sortgroup.sort(compareNode);
	  }

	  return new Selection(sortgroups, this._parents).order();
	}

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function selection_call() {
	  var callback = arguments[0];
	  arguments[0] = this;
	  callback.apply(null, arguments);
	  return this;
	}

	function selection_nodes() {
	  var nodes = new Array(this.size()), i = -1;
	  this.each(function() { nodes[++i] = this; });
	  return nodes;
	}

	function selection_node() {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	      var node = group[i];
	      if (node) return node;
	    }
	  }

	  return null;
	}

	function selection_size() {
	  var size = 0;
	  this.each(function() { ++size; });
	  return size;
	}

	function selection_empty() {
	  return !this.node();
	}

	function selection_each(callback) {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) callback.call(node, node.__data__, i, group);
	    }
	  }

	  return this;
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, value) {
	  return function() {
	    this.setAttribute(name, value);
	  };
	}

	function attrConstantNS(fullname, value) {
	  return function() {
	    this.setAttributeNS(fullname.space, fullname.local, value);
	  };
	}

	function attrFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttribute(name);
	    else this.setAttribute(name, v);
	  };
	}

	function attrFunctionNS(fullname, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	    else this.setAttributeNS(fullname.space, fullname.local, v);
	  };
	}

	function selection_attr(name, value) {
	  var fullname = namespace(name);

	  if (arguments.length < 2) {
	    var node = this.node();
	    return fullname.local
	        ? node.getAttributeNS(fullname.space, fullname.local)
	        : node.getAttribute(fullname);
	  }

	  return this.each((value == null
	      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)
	      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
	}

	function defaultView(node) {
	  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	      || (node.document && node) // node is a Window
	      || node.defaultView; // node is a Document
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, value, priority) {
	  return function() {
	    this.style.setProperty(name, value, priority);
	  };
	}

	function styleFunction(name, value, priority) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.style.removeProperty(name);
	    else this.style.setProperty(name, v, priority);
	  };
	}

	function selection_style(name, value, priority) {
	  return arguments.length > 1
	      ? this.each((value == null
	            ? styleRemove : typeof value === "function"
	            ? styleFunction
	            : styleConstant)(name, value, priority == null ? "" : priority))
	      : styleValue(this.node(), name);
	}

	function styleValue(node, name) {
	  return node.style.getPropertyValue(name)
	      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
	}

	function propertyRemove(name) {
	  return function() {
	    delete this[name];
	  };
	}

	function propertyConstant(name, value) {
	  return function() {
	    this[name] = value;
	  };
	}

	function propertyFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) delete this[name];
	    else this[name] = v;
	  };
	}

	function selection_property(name, value) {
	  return arguments.length > 1
	      ? this.each((value == null
	          ? propertyRemove : typeof value === "function"
	          ? propertyFunction
	          : propertyConstant)(name, value))
	      : this.node()[name];
	}

	function classArray(string) {
	  return string.trim().split(/^|\s+/);
	}

	function classList(node) {
	  return node.classList || new ClassList(node);
	}

	function ClassList(node) {
	  this._node = node;
	  this._names = classArray(node.getAttribute("class") || "");
	}

	ClassList.prototype = {
	  add: function(name) {
	    var i = this._names.indexOf(name);
	    if (i < 0) {
	      this._names.push(name);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  remove: function(name) {
	    var i = this._names.indexOf(name);
	    if (i >= 0) {
	      this._names.splice(i, 1);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  contains: function(name) {
	    return this._names.indexOf(name) >= 0;
	  }
	};

	function classedAdd(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.add(names[i]);
	}

	function classedRemove(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.remove(names[i]);
	}

	function classedTrue(names) {
	  return function() {
	    classedAdd(this, names);
	  };
	}

	function classedFalse(names) {
	  return function() {
	    classedRemove(this, names);
	  };
	}

	function classedFunction(names, value) {
	  return function() {
	    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	  };
	}

	function selection_classed(name, value) {
	  var names = classArray(name + "");

	  if (arguments.length < 2) {
	    var list = classList(this.node()), i = -1, n = names.length;
	    while (++i < n) if (!list.contains(names[i])) return false;
	    return true;
	  }

	  return this.each((typeof value === "function"
	      ? classedFunction : value
	      ? classedTrue
	      : classedFalse)(names, value));
	}

	function textRemove() {
	  this.textContent = "";
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.textContent = v == null ? "" : v;
	  };
	}

	function selection_text(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? textRemove : (typeof value === "function"
	          ? textFunction
	          : textConstant)(value))
	      : this.node().textContent;
	}

	function htmlRemove() {
	  this.innerHTML = "";
	}

	function htmlConstant(value) {
	  return function() {
	    this.innerHTML = value;
	  };
	}

	function htmlFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.innerHTML = v == null ? "" : v;
	  };
	}

	function selection_html(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? htmlRemove : (typeof value === "function"
	          ? htmlFunction
	          : htmlConstant)(value))
	      : this.node().innerHTML;
	}

	function raise() {
	  if (this.nextSibling) this.parentNode.appendChild(this);
	}

	function selection_raise() {
	  return this.each(raise);
	}

	function lower() {
	  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	}

	function selection_lower() {
	  return this.each(lower);
	}

	function selection_append(name) {
	  var create = typeof name === "function" ? name : creator(name);
	  return this.select(function() {
	    return this.appendChild(create.apply(this, arguments));
	  });
	}

	function constantNull() {
	  return null;
	}

	function selection_insert(name, before) {
	  var create = typeof name === "function" ? name : creator(name),
	      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	  return this.select(function() {
	    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	  });
	}

	function remove() {
	  var parent = this.parentNode;
	  if (parent) parent.removeChild(this);
	}

	function selection_remove() {
	  return this.each(remove);
	}

	function selection_cloneShallow() {
	  var clone = this.cloneNode(false), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_cloneDeep() {
	  var clone = this.cloneNode(true), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_clone(deep) {
	  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
	}

	function selection_datum(value) {
	  return arguments.length
	      ? this.property("__data__", value)
	      : this.node().__data__;
	}

	var filterEvents = {};

	exports.event = null;

	if (typeof document !== "undefined") {
	  var element = document.documentElement;
	  if (!("onmouseenter" in element)) {
	    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
	  }
	}

	function filterContextListener(listener, index, group) {
	  listener = contextListener(listener, index, group);
	  return function(event) {
	    var related = event.relatedTarget;
	    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	      listener.call(this, event);
	    }
	  };
	}

	function contextListener(listener, index, group) {
	  return function(event1) {
	    var event0 = exports.event; // Events can be reentrant (e.g., focus).
	    exports.event = event1;
	    try {
	      listener.call(this, this.__data__, index, group);
	    } finally {
	      exports.event = event0;
	    }
	  };
	}

	function parseTypenames(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    return {type: t, name: name};
	  });
	}

	function onRemove(typename) {
	  return function() {
	    var on = this.__on;
	    if (!on) return;
	    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	      } else {
	        on[++i] = o;
	      }
	    }
	    if (++i) on.length = i;
	    else delete this.__on;
	  };
	}

	function onAdd(typename, value, capture) {
	  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
	  return function(d, i, group) {
	    var on = this.__on, o, listener = wrap(value, i, group);
	    if (on) for (var j = 0, m = on.length; j < m; ++j) {
	      if ((o = on[j]).type === typename.type && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
	        o.value = value;
	        return;
	      }
	    }
	    this.addEventListener(typename.type, listener, capture);
	    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	    if (!on) this.__on = [o];
	    else on.push(o);
	  };
	}

	function selection_on(typename, value, capture) {
	  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

	  if (arguments.length < 2) {
	    var on = this.node().__on;
	    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	      for (i = 0, o = on[j]; i < n; ++i) {
	        if ((t = typenames[i]).type === o.type && t.name === o.name) {
	          return o.value;
	        }
	      }
	    }
	    return;
	  }

	  on = value ? onAdd : onRemove;
	  if (capture == null) capture = false;
	  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
	  return this;
	}

	function customEvent(event1, listener, that, args) {
	  var event0 = exports.event;
	  event1.sourceEvent = exports.event;
	  exports.event = event1;
	  try {
	    return listener.apply(that, args);
	  } finally {
	    exports.event = event0;
	  }
	}

	function dispatchEvent(node, type, params) {
	  var window = defaultView(node),
	      event = window.CustomEvent;

	  if (typeof event === "function") {
	    event = new event(type, params);
	  } else {
	    event = window.document.createEvent("Event");
	    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	    else event.initEvent(type, false, false);
	  }

	  node.dispatchEvent(event);
	}

	function dispatchConstant(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params);
	  };
	}

	function dispatchFunction(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params.apply(this, arguments));
	  };
	}

	function selection_dispatch(type, params) {
	  return this.each((typeof params === "function"
	      ? dispatchFunction
	      : dispatchConstant)(type, params));
	}

	var root = [null];

	function Selection(groups, parents) {
	  this._groups = groups;
	  this._parents = parents;
	}

	function selection() {
	  return new Selection([[document.documentElement]], root);
	}

	Selection.prototype = selection.prototype = {
	  constructor: Selection,
	  select: selection_select,
	  selectAll: selection_selectAll,
	  filter: selection_filter,
	  data: selection_data,
	  enter: selection_enter,
	  exit: selection_exit,
	  join: selection_join,
	  merge: selection_merge,
	  order: selection_order,
	  sort: selection_sort,
	  call: selection_call,
	  nodes: selection_nodes,
	  node: selection_node,
	  size: selection_size,
	  empty: selection_empty,
	  each: selection_each,
	  attr: selection_attr,
	  style: selection_style,
	  property: selection_property,
	  classed: selection_classed,
	  text: selection_text,
	  html: selection_html,
	  raise: selection_raise,
	  lower: selection_lower,
	  append: selection_append,
	  insert: selection_insert,
	  remove: selection_remove,
	  clone: selection_clone,
	  datum: selection_datum,
	  on: selection_on,
	  dispatch: selection_dispatch
	};

	function select(selector) {
	  return typeof selector === "string"
	      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	      : new Selection([[selector]], root);
	}

	function create(name) {
	  return select(creator(name).call(document.documentElement));
	}

	var nextId = 0;

	function local() {
	  return new Local;
	}

	function Local() {
	  this._ = "@" + (++nextId).toString(36);
	}

	Local.prototype = local.prototype = {
	  constructor: Local,
	  get: function(node) {
	    var id = this._;
	    while (!(id in node)) if (!(node = node.parentNode)) return;
	    return node[id];
	  },
	  set: function(node, value) {
	    return node[this._] = value;
	  },
	  remove: function(node) {
	    return this._ in node && delete node[this._];
	  },
	  toString: function() {
	    return this._;
	  }
	};

	function sourceEvent() {
	  var current = exports.event, source;
	  while (source = current.sourceEvent) current = source;
	  return current;
	}

	function point(node, event) {
	  var svg = node.ownerSVGElement || node;

	  if (svg.createSVGPoint) {
	    var point = svg.createSVGPoint();
	    point.x = event.clientX, point.y = event.clientY;
	    point = point.matrixTransform(node.getScreenCTM().inverse());
	    return [point.x, point.y];
	  }

	  var rect = node.getBoundingClientRect();
	  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
	}

	function mouse(node) {
	  var event = sourceEvent();
	  if (event.changedTouches) event = event.changedTouches[0];
	  return point(node, event);
	}

	function selectAll(selector) {
	  return typeof selector === "string"
	      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
	      : new Selection([selector == null ? [] : selector], root);
	}

	function touch(node, touches, identifier) {
	  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

	  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
	    if ((touch = touches[i]).identifier === identifier) {
	      return point(node, touch);
	    }
	  }

	  return null;
	}

	function touches(node, touches) {
	  if (touches == null) touches = sourceEvent().touches;

	  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
	    points[i] = point(node, touches[i]);
	  }

	  return points;
	}

	exports.clientPoint = point;
	exports.create = create;
	exports.creator = creator;
	exports.customEvent = customEvent;
	exports.local = local;
	exports.matcher = matcher;
	exports.mouse = mouse;
	exports.namespace = namespace;
	exports.namespaces = namespaces;
	exports.select = select;
	exports.selectAll = selectAll;
	exports.selection = selection;
	exports.selector = selector;
	exports.selectorAll = selectorAll;
	exports.style = styleValue;
	exports.touch = touch;
	exports.touches = touches;
	exports.window = defaultView;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-interpolate/ v1.4.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(13)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Color) { 'use strict';

	function basis(t1, v0, v1, v2, v3) {
	  var t2 = t1 * t1, t3 = t2 * t1;
	  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
	      + (4 - 6 * t2 + 3 * t3) * v1
	      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
	      + t3 * v3) / 6;
	}

	function basis$1(values) {
	  var n = values.length - 1;
	  return function(t) {
	    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
	        v1 = values[i],
	        v2 = values[i + 1],
	        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
	        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	}

	function basisClosed(values) {
	  var n = values.length;
	  return function(t) {
	    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
	        v0 = values[(i + n - 1) % n],
	        v1 = values[i % n],
	        v2 = values[(i + 1) % n],
	        v3 = values[(i + 2) % n];
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function linear(a, d) {
	  return function(t) {
	    return a + t * d;
	  };
	}

	function exponential(a, b, y) {
	  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	    return Math.pow(a + t * b, y);
	  };
	}

	function hue(a, b) {
	  var d = b - a;
	  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
	}

	function gamma(y) {
	  return (y = +y) === 1 ? nogamma : function(a, b) {
	    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
	  };
	}

	function nogamma(a, b) {
	  var d = b - a;
	  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
	}

	var rgb = (function rgbGamma(y) {
	  var color = gamma(y);

	  function rgb(start, end) {
	    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
	        g = color(start.g, end.g),
	        b = color(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.r = r(t);
	      start.g = g(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  rgb.gamma = rgbGamma;

	  return rgb;
	})(1);

	function rgbSpline(spline) {
	  return function(colors) {
	    var n = colors.length,
	        r = new Array(n),
	        g = new Array(n),
	        b = new Array(n),
	        i, color;
	    for (i = 0; i < n; ++i) {
	      color = d3Color.rgb(colors[i]);
	      r[i] = color.r || 0;
	      g[i] = color.g || 0;
	      b[i] = color.b || 0;
	    }
	    r = spline(r);
	    g = spline(g);
	    b = spline(b);
	    color.opacity = 1;
	    return function(t) {
	      color.r = r(t);
	      color.g = g(t);
	      color.b = b(t);
	      return color + "";
	    };
	  };
	}

	var rgbBasis = rgbSpline(basis$1);
	var rgbBasisClosed = rgbSpline(basisClosed);

	function numberArray(a, b) {
	  if (!b) b = [];
	  var n = a ? Math.min(b.length, a.length) : 0,
	      c = b.slice(),
	      i;
	  return function(t) {
	    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
	    return c;
	  };
	}

	function isNumberArray(x) {
	  return ArrayBuffer.isView(x) && !(x instanceof DataView);
	}

	function array(a, b) {
	  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
	}

	function genericArray(a, b) {
	  var nb = b ? b.length : 0,
	      na = a ? Math.min(nb, a.length) : 0,
	      x = new Array(na),
	      c = new Array(nb),
	      i;

	  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
	  for (; i < nb; ++i) c[i] = b[i];

	  return function(t) {
	    for (i = 0; i < na; ++i) c[i] = x[i](t);
	    return c;
	  };
	}

	function date(a, b) {
	  var d = new Date;
	  return a = +a, b = +b, function(t) {
	    return d.setTime(a * (1 - t) + b * t), d;
	  };
	}

	function number(a, b) {
	  return a = +a, b = +b, function(t) {
	    return a * (1 - t) + b * t;
	  };
	}

	function object(a, b) {
	  var i = {},
	      c = {},
	      k;

	  if (a === null || typeof a !== "object") a = {};
	  if (b === null || typeof b !== "object") b = {};

	  for (k in b) {
	    if (k in a) {
	      i[k] = value(a[k], b[k]);
	    } else {
	      c[k] = b[k];
	    }
	  }

	  return function(t) {
	    for (k in i) c[k] = i[k](t);
	    return c;
	  };
	}

	var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
	    reB = new RegExp(reA.source, "g");

	function zero(b) {
	  return function() {
	    return b;
	  };
	}

	function one(b) {
	  return function(t) {
	    return b(t) + "";
	  };
	}

	function string(a, b) {
	  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	      am, // current match in a
	      bm, // current match in b
	      bs, // string preceding current number in b, if any
	      i = -1, // index in s
	      s = [], // string constants and placeholders
	      q = []; // number interpolators

	  // Coerce inputs to strings.
	  a = a + "", b = b + "";

	  // Interpolate pairs of numbers in a & b.
	  while ((am = reA.exec(a))
	      && (bm = reB.exec(b))) {
	    if ((bs = bm.index) > bi) { // a string precedes the next number in b
	      bs = b.slice(bi, bs);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }
	    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	      if (s[i]) s[i] += bm; // coalesce with previous string
	      else s[++i] = bm;
	    } else { // interpolate non-matching numbers
	      s[++i] = null;
	      q.push({i: i, x: number(am, bm)});
	    }
	    bi = reB.lastIndex;
	  }

	  // Add remains of b.
	  if (bi < b.length) {
	    bs = b.slice(bi);
	    if (s[i]) s[i] += bs; // coalesce with previous string
	    else s[++i] = bs;
	  }

	  // Special optimization for only a single match.
	  // Otherwise, interpolate each of the numbers and rejoin the string.
	  return s.length < 2 ? (q[0]
	      ? one(q[0].x)
	      : zero(b))
	      : (b = q.length, function(t) {
	          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	          return s.join("");
	        });
	}

	function value(a, b) {
	  var t = typeof b, c;
	  return b == null || t === "boolean" ? constant(b)
	      : (t === "number" ? number
	      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
	      : b instanceof d3Color.color ? rgb
	      : b instanceof Date ? date
	      : isNumberArray(b) ? numberArray
	      : Array.isArray(b) ? genericArray
	      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
	      : number)(a, b);
	}

	function discrete(range) {
	  var n = range.length;
	  return function(t) {
	    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	  };
	}

	function hue$1(a, b) {
	  var i = hue(+a, +b);
	  return function(t) {
	    var x = i(t);
	    return x - 360 * Math.floor(x / 360);
	  };
	}

	function round(a, b) {
	  return a = +a, b = +b, function(t) {
	    return Math.round(a * (1 - t) + b * t);
	  };
	}

	var degrees = 180 / Math.PI;

	var identity = {
	  translateX: 0,
	  translateY: 0,
	  rotate: 0,
	  skewX: 0,
	  scaleX: 1,
	  scaleY: 1
	};

	function decompose(a, b, c, d, e, f) {
	  var scaleX, scaleY, skewX;
	  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	  return {
	    translateX: e,
	    translateY: f,
	    rotate: Math.atan2(b, a) * degrees,
	    skewX: Math.atan(skewX) * degrees,
	    scaleX: scaleX,
	    scaleY: scaleY
	  };
	}

	var cssNode,
	    cssRoot,
	    cssView,
	    svgNode;

	function parseCss(value) {
	  if (value === "none") return identity;
	  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
	  cssNode.style.transform = value;
	  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
	  cssRoot.removeChild(cssNode);
	  value = value.slice(7, -1).split(",");
	  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
	}

	function parseSvg(value) {
	  if (value == null) return identity;
	  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	  svgNode.setAttribute("transform", value);
	  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
	  value = value.matrix;
	  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	}

	function interpolateTransform(parse, pxComma, pxParen, degParen) {

	  function pop(s) {
	    return s.length ? s.pop() + " " : "";
	  }

	  function translate(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push("translate(", null, pxComma, null, pxParen);
	      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	    } else if (xb || yb) {
	      s.push("translate(" + xb + pxComma + yb + pxParen);
	    }
	  }

	  function rotate(a, b, s, q) {
	    if (a !== b) {
	      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "rotate(" + b + degParen);
	    }
	  }

	  function skewX(a, b, s, q) {
	    if (a !== b) {
	      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "skewX(" + b + degParen);
	    }
	  }

	  function scale(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	    } else if (xb !== 1 || yb !== 1) {
	      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	    }
	  }

	  return function(a, b) {
	    var s = [], // string constants and placeholders
	        q = []; // number interpolators
	    a = parse(a), b = parse(b);
	    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	    rotate(a.rotate, b.rotate, s, q);
	    skewX(a.skewX, b.skewX, s, q);
	    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	    a = b = null; // gc
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  };
	}

	var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

	var rho = Math.SQRT2,
	    rho2 = 2,
	    rho4 = 4,
	    epsilon2 = 1e-12;

	function cosh(x) {
	  return ((x = Math.exp(x)) + 1 / x) / 2;
	}

	function sinh(x) {
	  return ((x = Math.exp(x)) - 1 / x) / 2;
	}

	function tanh(x) {
	  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	}

	// p0 = [ux0, uy0, w0]
	// p1 = [ux1, uy1, w1]
	function zoom(p0, p1) {
	  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
	      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
	      dx = ux1 - ux0,
	      dy = uy1 - uy0,
	      d2 = dx * dx + dy * dy,
	      i,
	      S;

	  // Special case for u0 ≅ u1.
	  if (d2 < epsilon2) {
	    S = Math.log(w1 / w0) / rho;
	    i = function(t) {
	      return [
	        ux0 + t * dx,
	        uy0 + t * dy,
	        w0 * Math.exp(rho * t * S)
	      ];
	    };
	  }

	  // General case.
	  else {
	    var d1 = Math.sqrt(d2),
	        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
	        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
	        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
	        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	    S = (r1 - r0) / rho;
	    i = function(t) {
	      var s = t * S,
	          coshr0 = cosh(r0),
	          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
	      return [
	        ux0 + u * dx,
	        uy0 + u * dy,
	        w0 * coshr0 / cosh(rho * s + r0)
	      ];
	    };
	  }

	  i.duration = S * 1000;

	  return i;
	}

	function hsl(hue) {
	  return function(start, end) {
	    var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
	        s = nogamma(start.s, end.s),
	        l = nogamma(start.l, end.l),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.h = h(t);
	      start.s = s(t);
	      start.l = l(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }
	}

	var hsl$1 = hsl(hue);
	var hslLong = hsl(nogamma);

	function lab(start, end) {
	  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
	      a = nogamma(start.a, end.a),
	      b = nogamma(start.b, end.b),
	      opacity = nogamma(start.opacity, end.opacity);
	  return function(t) {
	    start.l = l(t);
	    start.a = a(t);
	    start.b = b(t);
	    start.opacity = opacity(t);
	    return start + "";
	  };
	}

	function hcl(hue) {
	  return function(start, end) {
	    var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
	        c = nogamma(start.c, end.c),
	        l = nogamma(start.l, end.l),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.h = h(t);
	      start.c = c(t);
	      start.l = l(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }
	}

	var hcl$1 = hcl(hue);
	var hclLong = hcl(nogamma);

	function cubehelix(hue) {
	  return (function cubehelixGamma(y) {
	    y = +y;

	    function cubehelix(start, end) {
	      var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
	          s = nogamma(start.s, end.s),
	          l = nogamma(start.l, end.l),
	          opacity = nogamma(start.opacity, end.opacity);
	      return function(t) {
	        start.h = h(t);
	        start.s = s(t);
	        start.l = l(Math.pow(t, y));
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }

	    cubehelix.gamma = cubehelixGamma;

	    return cubehelix;
	  })(1);
	}

	var cubehelix$1 = cubehelix(hue);
	var cubehelixLong = cubehelix(nogamma);

	function piecewise(interpolate, values) {
	  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
	  while (i < n) I[i] = interpolate(v, v = values[++i]);
	  return function(t) {
	    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
	    return I[i](t - i);
	  };
	}

	function quantize(interpolator, n) {
	  var samples = new Array(n);
	  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
	  return samples;
	}

	exports.interpolate = value;
	exports.interpolateArray = array;
	exports.interpolateBasis = basis$1;
	exports.interpolateBasisClosed = basisClosed;
	exports.interpolateCubehelix = cubehelix$1;
	exports.interpolateCubehelixLong = cubehelixLong;
	exports.interpolateDate = date;
	exports.interpolateDiscrete = discrete;
	exports.interpolateHcl = hcl$1;
	exports.interpolateHclLong = hclLong;
	exports.interpolateHsl = hsl$1;
	exports.interpolateHslLong = hslLong;
	exports.interpolateHue = hue$1;
	exports.interpolateLab = lab;
	exports.interpolateNumber = number;
	exports.interpolateNumberArray = numberArray;
	exports.interpolateObject = object;
	exports.interpolateRgb = rgb;
	exports.interpolateRgbBasis = rgbBasis;
	exports.interpolateRgbBasisClosed = rgbBasisClosed;
	exports.interpolateRound = round;
	exports.interpolateString = string;
	exports.interpolateTransformCss = interpolateTransformCss;
	exports.interpolateTransformSvg = interpolateTransformSvg;
	exports.interpolateZoom = zoom;
	exports.piecewise = piecewise;
	exports.quantize = quantize;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-color/ v1.4.1 Copyright 2020 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function define(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	}

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*",
	    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	    reHex = /^#([0-9a-f]{3,8})$/,
	    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  copy: function(channels) {
	    return Object.assign(new this.constructor, this, channels);
	  },
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: color_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: color_formatHex,
	  formatHsl: color_formatHsl,
	  formatRgb: color_formatRgb,
	  toString: color_formatRgb
	});

	function color_formatHex() {
	  return this.rgb().formatHex();
	}

	function color_formatHsl() {
	  return hslConvert(this).formatHsl();
	}

	function color_formatRgb() {
	  return this.rgb().formatRgb();
	}

	function color(format) {
	  var m, l;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
	      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
	      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
	      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
	      : null) // invalid hex
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (-0.5 <= this.r && this.r < 255.5)
	        && (-0.5 <= this.g && this.g < 255.5)
	        && (-0.5 <= this.b && this.b < 255.5)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: rgb_formatHex,
	  formatRgb: rgb_formatRgb,
	  toString: rgb_formatRgb
	}));

	function rgb_formatHex() {
	  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	}

	function rgb_formatRgb() {
	  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	  return (a === 1 ? "rgb(" : "rgba(")
	      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	      + (a === 1 ? ")" : ", " + a + ")");
	}

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  formatHsl: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "hsl(" : "hsla(")
	        + (this.h || 0) + ", "
	        + (this.s || 0) * 100 + "%, "
	        + (this.l || 0) * 100 + "%"
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	var deg2rad = Math.PI / 180;
	var rad2deg = 180 / Math.PI;

	// https://observablehq.com/@mbostock/lab-and-rgb
	var K = 18,
	    Xn = 0.96422,
	    Yn = 1,
	    Zn = 0.82521,
	    t0 = 4 / 29,
	    t1 = 6 / 29,
	    t2 = 3 * t1 * t1,
	    t3 = t1 * t1 * t1;

	function labConvert(o) {
	  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
	  if (o instanceof Hcl) return hcl2lab(o);
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = rgb2lrgb(o.r),
	      g = rgb2lrgb(o.g),
	      b = rgb2lrgb(o.b),
	      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
	  if (r === g && g === b) x = z = y; else {
	    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
	    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
	  }
	  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
	}

	function gray(l, opacity) {
	  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
	}

	function lab(l, a, b, opacity) {
	  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
	}

	function Lab(l, a, b, opacity) {
	  this.l = +l;
	  this.a = +a;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Lab, lab, extend(Color, {
	  brighter: function(k) {
	    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  darker: function(k) {
	    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  rgb: function() {
	    var y = (this.l + 16) / 116,
	        x = isNaN(this.a) ? y : y + this.a / 500,
	        z = isNaN(this.b) ? y : y - this.b / 200;
	    x = Xn * lab2xyz(x);
	    y = Yn * lab2xyz(y);
	    z = Zn * lab2xyz(z);
	    return new Rgb(
	      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
	      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
	      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
	      this.opacity
	    );
	  }
	}));

	function xyz2lab(t) {
	  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
	}

	function lab2xyz(t) {
	  return t > t1 ? t * t * t : t2 * (t - t0);
	}

	function lrgb2rgb(x) {
	  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
	}

	function rgb2lrgb(x) {
	  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
	}

	function hclConvert(o) {
	  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
	  if (!(o instanceof Lab)) o = labConvert(o);
	  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
	  var h = Math.atan2(o.b, o.a) * rad2deg;
	  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
	}

	function lch(l, c, h, opacity) {
	  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function hcl(h, c, l, opacity) {
	  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function Hcl(h, c, l, opacity) {
	  this.h = +h;
	  this.c = +c;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	function hcl2lab(o) {
	  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
	  var h = o.h * deg2rad;
	  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
	}

	define(Hcl, hcl, extend(Color, {
	  brighter: function(k) {
	    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
	  },
	  darker: function(k) {
	    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
	  },
	  rgb: function() {
	    return hcl2lab(this).rgb();
	  }
	}));

	var A = -0.14861,
	    B = +1.78277,
	    C = -0.29227,
	    D = -0.90649,
	    E = +1.97294,
	    ED = E * D,
	    EB = E * B,
	    BC_DA = B * C - D * A;

	function cubehelixConvert(o) {
	  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
	      bl = b - l,
	      k = (E * (g - l) - C * bl) / D,
	      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
	      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
	  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
	}

	function cubehelix(h, s, l, opacity) {
	  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
	}

	function Cubehelix(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Cubehelix, cubehelix, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
	        l = +this.l,
	        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
	        cosh = Math.cos(h),
	        sinh = Math.sin(h);
	    return new Rgb(
	      255 * (l + a * (A * cosh + B * sinh)),
	      255 * (l + a * (C * cosh + D * sinh)),
	      255 * (l + a * (E * cosh)),
	      this.opacity
	    );
	  }
	}));

	exports.color = color;
	exports.cubehelix = cubehelix;
	exports.gray = gray;
	exports.hcl = hcl;
	exports.hsl = hsl;
	exports.lab = lab;
	exports.lch = lch;
	exports.rgb = rgb;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-transition/ v1.3.2 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(11), __webpack_require__(9), __webpack_require__(15), __webpack_require__(12), __webpack_require__(13), __webpack_require__(16)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) { 'use strict';

	var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
	var emptyTween = [];

	var CREATED = 0;
	var SCHEDULED = 1;
	var STARTING = 2;
	var STARTED = 3;
	var RUNNING = 4;
	var ENDING = 5;
	var ENDED = 6;

	function schedule(node, name, id, index, group, timing) {
	  var schedules = node.__transition;
	  if (!schedules) node.__transition = {};
	  else if (id in schedules) return;
	  create(node, id, {
	    name: name,
	    index: index, // For context during callback.
	    group: group, // For context during callback.
	    on: emptyOn,
	    tween: emptyTween,
	    time: timing.time,
	    delay: timing.delay,
	    duration: timing.duration,
	    ease: timing.ease,
	    timer: null,
	    state: CREATED
	  });
	}

	function init(node, id) {
	  var schedule = get(node, id);
	  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	  return schedule;
	}

	function set(node, id) {
	  var schedule = get(node, id);
	  if (schedule.state > STARTED) throw new Error("too late; already running");
	  return schedule;
	}

	function get(node, id) {
	  var schedule = node.__transition;
	  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
	  return schedule;
	}

	function create(node, id, self) {
	  var schedules = node.__transition,
	      tween;

	  // Initialize the self timer when the transition is created.
	  // Note the actual delay is not known until the first callback!
	  schedules[id] = self;
	  self.timer = d3Timer.timer(schedule, 0, self.time);

	  function schedule(elapsed) {
	    self.state = SCHEDULED;
	    self.timer.restart(start, self.delay, self.time);

	    // If the elapsed delay is less than our first sleep, start immediately.
	    if (self.delay <= elapsed) start(elapsed - self.delay);
	  }

	  function start(elapsed) {
	    var i, j, n, o;

	    // If the state is not SCHEDULED, then we previously errored on start.
	    if (self.state !== SCHEDULED) return stop();

	    for (i in schedules) {
	      o = schedules[i];
	      if (o.name !== self.name) continue;

	      // While this element already has a starting transition during this frame,
	      // defer starting an interrupting transition until that transition has a
	      // chance to tick (and possibly end); see d3/d3-transition#54!
	      if (o.state === STARTED) return d3Timer.timeout(start);

	      // Interrupt the active transition, if any.
	      if (o.state === RUNNING) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("interrupt", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }

	      // Cancel any pre-empted transitions.
	      else if (+i < id) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("cancel", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }
	    }

	    // Defer the first tick to end of the current frame; see d3/d3#1576.
	    // Note the transition may be canceled after start and before the first tick!
	    // Note this must be scheduled before the start event; see d3/d3-transition#16!
	    // Assuming this is successful, subsequent callbacks go straight to tick.
	    d3Timer.timeout(function() {
	      if (self.state === STARTED) {
	        self.state = RUNNING;
	        self.timer.restart(tick, self.delay, self.time);
	        tick(elapsed);
	      }
	    });

	    // Dispatch the start event.
	    // Note this must be done before the tween are initialized.
	    self.state = STARTING;
	    self.on.call("start", node, node.__data__, self.index, self.group);
	    if (self.state !== STARTING) return; // interrupted
	    self.state = STARTED;

	    // Initialize the tween, deleting null tween.
	    tween = new Array(n = self.tween.length);
	    for (i = 0, j = -1; i < n; ++i) {
	      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
	        tween[++j] = o;
	      }
	    }
	    tween.length = j + 1;
	  }

	  function tick(elapsed) {
	    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
	        i = -1,
	        n = tween.length;

	    while (++i < n) {
	      tween[i].call(node, t);
	    }

	    // Dispatch the end event.
	    if (self.state === ENDING) {
	      self.on.call("end", node, node.__data__, self.index, self.group);
	      stop();
	    }
	  }

	  function stop() {
	    self.state = ENDED;
	    self.timer.stop();
	    delete schedules[id];
	    for (var i in schedules) return; // eslint-disable-line no-unused-vars
	    delete node.__transition;
	  }
	}

	function interrupt(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      active,
	      empty = true,
	      i;

	  if (!schedules) return;

	  name = name == null ? null : name + "";

	  for (i in schedules) {
	    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
	    active = schedule.state > STARTING && schedule.state < ENDING;
	    schedule.state = ENDED;
	    schedule.timer.stop();
	    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
	    delete schedules[i];
	  }

	  if (empty) delete node.__transition;
	}

	function selection_interrupt(name) {
	  return this.each(function() {
	    interrupt(this, name);
	  });
	}

	function tweenRemove(id, name) {
	  var tween0, tween1;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = tween0 = tween;
	      for (var i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1 = tween1.slice();
	          tween1.splice(i, 1);
	          break;
	        }
	      }
	    }

	    schedule.tween = tween1;
	  };
	}

	function tweenFunction(id, name, value) {
	  var tween0, tween1;
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = (tween0 = tween).slice();
	      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1[i] = t;
	          break;
	        }
	      }
	      if (i === n) tween1.push(t);
	    }

	    schedule.tween = tween1;
	  };
	}

	function transition_tween(name, value) {
	  var id = this._id;

	  name += "";

	  if (arguments.length < 2) {
	    var tween = get(this.node(), id).tween;
	    for (var i = 0, n = tween.length, t; i < n; ++i) {
	      if ((t = tween[i]).name === name) {
	        return t.value;
	      }
	    }
	    return null;
	  }

	  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
	}

	function tweenValue(transition, name, value) {
	  var id = transition._id;

	  transition.each(function() {
	    var schedule = set(this, id);
	    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
	  });

	  return function(node) {
	    return get(node, id).value[name];
	  };
	}

	function interpolate(a, b) {
	  var c;
	  return (typeof b === "number" ? d3Interpolate.interpolateNumber
	      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
	      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
	      : d3Interpolate.interpolateString)(a, b);
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttribute(name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrConstantNS(fullname, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttributeNS(fullname.space, fullname.local);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrFunction(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttribute(name);
	    string0 = this.getAttribute(name);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function attrFunctionNS(fullname, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	    string0 = this.getAttributeNS(fullname.space, fullname.local);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function transition_attr(name, value) {
	  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
	  return this.attrTween(name, typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
	      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
	      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
	}

	function attrInterpolate(name, i) {
	  return function(t) {
	    this.setAttribute(name, i.call(this, t));
	  };
	}

	function attrInterpolateNS(fullname, i) {
	  return function(t) {
	    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
	  };
	}

	function attrTweenNS(fullname, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function attrTween(name, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_attrTween(name, value) {
	  var key = "attr." + name;
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  var fullname = d3Selection.namespace(name);
	  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
	}

	function delayFunction(id, value) {
	  return function() {
	    init(this, id).delay = +value.apply(this, arguments);
	  };
	}

	function delayConstant(id, value) {
	  return value = +value, function() {
	    init(this, id).delay = value;
	  };
	}

	function transition_delay(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? delayFunction
	          : delayConstant)(id, value))
	      : get(this.node(), id).delay;
	}

	function durationFunction(id, value) {
	  return function() {
	    set(this, id).duration = +value.apply(this, arguments);
	  };
	}

	function durationConstant(id, value) {
	  return value = +value, function() {
	    set(this, id).duration = value;
	  };
	}

	function transition_duration(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? durationFunction
	          : durationConstant)(id, value))
	      : get(this.node(), id).duration;
	}

	function easeConstant(id, value) {
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    set(this, id).ease = value;
	  };
	}

	function transition_ease(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each(easeConstant(id, value))
	      : get(this.node(), id).ease;
	}

	function transition_filter(match) {
	  if (typeof match !== "function") match = d3Selection.matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, this._name, this._id);
	}

	function transition_merge(transition) {
	  if (transition._id !== this._id) throw new Error;

	  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Transition(merges, this._parents, this._name, this._id);
	}

	function start(name) {
	  return (name + "").trim().split(/^|\s+/).every(function(t) {
	    var i = t.indexOf(".");
	    if (i >= 0) t = t.slice(0, i);
	    return !t || t === "start";
	  });
	}

	function onFunction(id, name, listener) {
	  var on0, on1, sit = start(name) ? init : set;
	  return function() {
	    var schedule = sit(this, id),
	        on = schedule.on;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	    schedule.on = on1;
	  };
	}

	function transition_on(name, listener) {
	  var id = this._id;

	  return arguments.length < 2
	      ? get(this.node(), id).on.on(name)
	      : this.each(onFunction(id, name, listener));
	}

	function removeFunction(id) {
	  return function() {
	    var parent = this.parentNode;
	    for (var i in this.__transition) if (+i !== id) return;
	    if (parent) parent.removeChild(this);
	  };
	}

	function transition_remove() {
	  return this.on("end.remove", removeFunction(this._id));
	}

	function transition_select(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = d3Selection.selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, name, id);
	}

	function transition_selectAll(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = d3Selection.selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
	          if (child = children[k]) {
	            schedule(child, name, id, k, children, inherit);
	          }
	        }
	        subgroups.push(children);
	        parents.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, parents, name, id);
	}

	var Selection = d3Selection.selection.prototype.constructor;

	function transition_selection() {
	  return new Selection(this._groups, this._parents);
	}

	function styleNull(name, interpolate) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = d3Selection.style(this, name),
	        string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, string10 = string1);
	  };
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = d3Selection.style(this, name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function styleFunction(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = d3Selection.style(this, name),
	        value1 = value(this),
	        string1 = value1 + "";
	    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function styleMaybeRemove(id, name) {
	  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
	  return function() {
	    var schedule = set(this, id),
	        on = schedule.on,
	        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

	    schedule.on = on1;
	  };
	}

	function transition_style(name, value, priority) {
	  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
	  return value == null ? this
	      .styleTween(name, styleNull(name, i))
	      .on("end.style." + name, styleRemove(name))
	    : typeof value === "function" ? this
	      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
	      .each(styleMaybeRemove(this._id, name))
	    : this
	      .styleTween(name, styleConstant(name, i, value), priority)
	      .on("end.style." + name, null);
	}

	function styleInterpolate(name, i, priority) {
	  return function(t) {
	    this.style.setProperty(name, i.call(this, t), priority);
	  };
	}

	function styleTween(name, value, priority) {
	  var t, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
	    return t;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_styleTween(name, value, priority) {
	  var key = "style." + (name += "");
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var value1 = value(this);
	    this.textContent = value1 == null ? "" : value1;
	  };
	}

	function transition_text(value) {
	  return this.tween("text", typeof value === "function"
	      ? textFunction(tweenValue(this, "text", value))
	      : textConstant(value == null ? "" : value + ""));
	}

	function textInterpolate(i) {
	  return function(t) {
	    this.textContent = i.call(this, t);
	  };
	}

	function textTween(value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_textTween(value) {
	  var key = "text";
	  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, textTween(value));
	}

	function transition_transition() {
	  var name = this._name,
	      id0 = this._id,
	      id1 = newId();

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        var inherit = get(node, id0);
	        schedule(node, name, id1, i, group, {
	          time: inherit.time + inherit.delay + inherit.duration,
	          delay: 0,
	          duration: inherit.duration,
	          ease: inherit.ease
	        });
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id1);
	}

	function transition_end() {
	  var on0, on1, that = this, id = that._id, size = that.size();
	  return new Promise(function(resolve, reject) {
	    var cancel = {value: reject},
	        end = {value: function() { if (--size === 0) resolve(); }};

	    that.each(function() {
	      var schedule = set(this, id),
	          on = schedule.on;

	      // If this node shared a dispatch with the previous node,
	      // just assign the updated shared dispatch and we’re done!
	      // Otherwise, copy-on-write.
	      if (on !== on0) {
	        on1 = (on0 = on).copy();
	        on1._.cancel.push(cancel);
	        on1._.interrupt.push(cancel);
	        on1._.end.push(end);
	      }

	      schedule.on = on1;
	    });
	  });
	}

	var id = 0;

	function Transition(groups, parents, name, id) {
	  this._groups = groups;
	  this._parents = parents;
	  this._name = name;
	  this._id = id;
	}

	function transition(name) {
	  return d3Selection.selection().transition(name);
	}

	function newId() {
	  return ++id;
	}

	var selection_prototype = d3Selection.selection.prototype;

	Transition.prototype = transition.prototype = {
	  constructor: Transition,
	  select: transition_select,
	  selectAll: transition_selectAll,
	  filter: transition_filter,
	  merge: transition_merge,
	  selection: transition_selection,
	  transition: transition_transition,
	  call: selection_prototype.call,
	  nodes: selection_prototype.nodes,
	  node: selection_prototype.node,
	  size: selection_prototype.size,
	  empty: selection_prototype.empty,
	  each: selection_prototype.each,
	  on: transition_on,
	  attr: transition_attr,
	  attrTween: transition_attrTween,
	  style: transition_style,
	  styleTween: transition_styleTween,
	  text: transition_text,
	  textTween: transition_textTween,
	  remove: transition_remove,
	  tween: transition_tween,
	  delay: transition_delay,
	  duration: transition_duration,
	  ease: transition_ease,
	  end: transition_end
	};

	var defaultTiming = {
	  time: null, // Set on use.
	  delay: 0,
	  duration: 250,
	  ease: d3Ease.easeCubicInOut
	};

	function inherit(node, id) {
	  var timing;
	  while (!(timing = node.__transition) || !(timing = timing[id])) {
	    if (!(node = node.parentNode)) {
	      return defaultTiming.time = d3Timer.now(), defaultTiming;
	    }
	  }
	  return timing;
	}

	function selection_transition(name) {
	  var id,
	      timing;

	  if (name instanceof Transition) {
	    id = name._id, name = name._name;
	  } else {
	    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
	  }

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        schedule(node, name, id, i, group, timing || inherit(node, id));
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id);
	}

	d3Selection.selection.prototype.interrupt = selection_interrupt;
	d3Selection.selection.prototype.transition = selection_transition;

	var root = [null];

	function active(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      i;

	  if (schedules) {
	    name = name == null ? null : name + "";
	    for (i in schedules) {
	      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
	        return new Transition([[node]], root, name, +i);
	      }
	    }
	  }

	  return null;
	}

	exports.active = active;
	exports.interrupt = interrupt;
	exports.transition = transition;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-timer/ v1.0.10 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var frame = 0, // is an animation frame pending?
	    timeout = 0, // is a timeout pending?
	    interval = 0, // are any timers active?
	    pokeDelay = 1000, // how frequently we check for clock skew
	    taskHead,
	    taskTail,
	    clockLast = 0,
	    clockNow = 0,
	    clockSkew = 0,
	    clock = typeof performance === "object" && performance.now ? performance : Date,
	    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

	function now() {
	  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
	}

	function clearNow() {
	  clockNow = 0;
	}

	function Timer() {
	  this._call =
	  this._time =
	  this._next = null;
	}

	Timer.prototype = timer.prototype = {
	  constructor: Timer,
	  restart: function(callback, delay, time) {
	    if (typeof callback !== "function") throw new TypeError("callback is not a function");
	    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
	    if (!this._next && taskTail !== this) {
	      if (taskTail) taskTail._next = this;
	      else taskHead = this;
	      taskTail = this;
	    }
	    this._call = callback;
	    this._time = time;
	    sleep();
	  },
	  stop: function() {
	    if (this._call) {
	      this._call = null;
	      this._time = Infinity;
	      sleep();
	    }
	  }
	};

	function timer(callback, delay, time) {
	  var t = new Timer;
	  t.restart(callback, delay, time);
	  return t;
	}

	function timerFlush() {
	  now(); // Get the current time, if not already set.
	  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
	  var t = taskHead, e;
	  while (t) {
	    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	    t = t._next;
	  }
	  --frame;
	}

	function wake() {
	  clockNow = (clockLast = clock.now()) + clockSkew;
	  frame = timeout = 0;
	  try {
	    timerFlush();
	  } finally {
	    frame = 0;
	    nap();
	    clockNow = 0;
	  }
	}

	function poke() {
	  var now = clock.now(), delay = now - clockLast;
	  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
	}

	function nap() {
	  var t0, t1 = taskHead, t2, time = Infinity;
	  while (t1) {
	    if (t1._call) {
	      if (time > t1._time) time = t1._time;
	      t0 = t1, t1 = t1._next;
	    } else {
	      t2 = t1._next, t1._next = null;
	      t1 = t0 ? t0._next = t2 : taskHead = t2;
	    }
	  }
	  taskTail = t0;
	  sleep(time);
	}

	function sleep(time) {
	  if (frame) return; // Soonest alarm already set, or will be.
	  if (timeout) timeout = clearTimeout(timeout);
	  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
	  if (delay > 24) {
	    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
	    if (interval) interval = clearInterval(interval);
	  } else {
	    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
	    frame = 1, setFrame(wake);
	  }
	}

	function timeout$1(callback, delay, time) {
	  var t = new Timer;
	  delay = delay == null ? 0 : +delay;
	  t.restart(function(elapsed) {
	    t.stop();
	    callback(elapsed + delay);
	  }, delay, time);
	  return t;
	}

	function interval$1(callback, delay, time) {
	  var t = new Timer, total = delay;
	  if (delay == null) return t.restart(callback, delay, time), t;
	  delay = +delay, time = time == null ? now() : +time;
	  t.restart(function tick(elapsed) {
	    elapsed += total;
	    t.restart(tick, total += delay, time);
	    callback(elapsed);
	  }, delay, time);
	  return t;
	}

	exports.interval = interval$1;
	exports.now = now;
	exports.timeout = timeout$1;
	exports.timer = timer;
	exports.timerFlush = timerFlush;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-ease/ v1.0.6 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function linear(t) {
	  return +t;
	}

	function quadIn(t) {
	  return t * t;
	}

	function quadOut(t) {
	  return t * (2 - t);
	}

	function quadInOut(t) {
	  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
	}

	function cubicIn(t) {
	  return t * t * t;
	}

	function cubicOut(t) {
	  return --t * t * t + 1;
	}

	function cubicInOut(t) {
	  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
	}

	var exponent = 3;

	var polyIn = (function custom(e) {
	  e = +e;

	  function polyIn(t) {
	    return Math.pow(t, e);
	  }

	  polyIn.exponent = custom;

	  return polyIn;
	})(exponent);

	var polyOut = (function custom(e) {
	  e = +e;

	  function polyOut(t) {
	    return 1 - Math.pow(1 - t, e);
	  }

	  polyOut.exponent = custom;

	  return polyOut;
	})(exponent);

	var polyInOut = (function custom(e) {
	  e = +e;

	  function polyInOut(t) {
	    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
	  }

	  polyInOut.exponent = custom;

	  return polyInOut;
	})(exponent);

	var pi = Math.PI,
	    halfPi = pi / 2;

	function sinIn(t) {
	  return 1 - Math.cos(t * halfPi);
	}

	function sinOut(t) {
	  return Math.sin(t * halfPi);
	}

	function sinInOut(t) {
	  return (1 - Math.cos(pi * t)) / 2;
	}

	function expIn(t) {
	  return Math.pow(2, 10 * t - 10);
	}

	function expOut(t) {
	  return 1 - Math.pow(2, -10 * t);
	}

	function expInOut(t) {
	  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
	}

	function circleIn(t) {
	  return 1 - Math.sqrt(1 - t * t);
	}

	function circleOut(t) {
	  return Math.sqrt(1 - --t * t);
	}

	function circleInOut(t) {
	  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
	}

	var b1 = 4 / 11,
	    b2 = 6 / 11,
	    b3 = 8 / 11,
	    b4 = 3 / 4,
	    b5 = 9 / 11,
	    b6 = 10 / 11,
	    b7 = 15 / 16,
	    b8 = 21 / 22,
	    b9 = 63 / 64,
	    b0 = 1 / b1 / b1;

	function bounceIn(t) {
	  return 1 - bounceOut(1 - t);
	}

	function bounceOut(t) {
	  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
	}

	function bounceInOut(t) {
	  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
	}

	var overshoot = 1.70158;

	var backIn = (function custom(s) {
	  s = +s;

	  function backIn(t) {
	    return t * t * ((s + 1) * t - s);
	  }

	  backIn.overshoot = custom;

	  return backIn;
	})(overshoot);

	var backOut = (function custom(s) {
	  s = +s;

	  function backOut(t) {
	    return --t * t * ((s + 1) * t + s) + 1;
	  }

	  backOut.overshoot = custom;

	  return backOut;
	})(overshoot);

	var backInOut = (function custom(s) {
	  s = +s;

	  function backInOut(t) {
	    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
	  }

	  backInOut.overshoot = custom;

	  return backInOut;
	})(overshoot);

	var tau = 2 * Math.PI,
	    amplitude = 1,
	    period = 0.3;

	var elasticIn = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticIn(t) {
	    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
	  }

	  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
	  elasticIn.period = function(p) { return custom(a, p); };

	  return elasticIn;
	})(amplitude, period);

	var elasticOut = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticOut(t) {
	    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
	  }

	  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
	  elasticOut.period = function(p) { return custom(a, p); };

	  return elasticOut;
	})(amplitude, period);

	var elasticInOut = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticInOut(t) {
	    return ((t = t * 2 - 1) < 0
	        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
	        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
	  }

	  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
	  elasticInOut.period = function(p) { return custom(a, p); };

	  return elasticInOut;
	})(amplitude, period);

	exports.easeBack = backInOut;
	exports.easeBackIn = backIn;
	exports.easeBackInOut = backInOut;
	exports.easeBackOut = backOut;
	exports.easeBounce = bounceOut;
	exports.easeBounceIn = bounceIn;
	exports.easeBounceInOut = bounceInOut;
	exports.easeBounceOut = bounceOut;
	exports.easeCircle = circleInOut;
	exports.easeCircleIn = circleIn;
	exports.easeCircleInOut = circleInOut;
	exports.easeCircleOut = circleOut;
	exports.easeCubic = cubicInOut;
	exports.easeCubicIn = cubicIn;
	exports.easeCubicInOut = cubicInOut;
	exports.easeCubicOut = cubicOut;
	exports.easeElastic = elasticOut;
	exports.easeElasticIn = elasticIn;
	exports.easeElasticInOut = elasticInOut;
	exports.easeElasticOut = elasticOut;
	exports.easeExp = expInOut;
	exports.easeExpIn = expIn;
	exports.easeExpInOut = expInOut;
	exports.easeExpOut = expOut;
	exports.easeLinear = linear;
	exports.easePoly = polyInOut;
	exports.easePolyIn = polyIn;
	exports.easePolyInOut = polyInOut;
	exports.easePolyOut = polyOut;
	exports.easeQuad = quadInOut;
	exports.easeQuadIn = quadIn;
	exports.easeQuadInOut = quadInOut;
	exports.easeQuadOut = quadOut;
	exports.easeSin = sinInOut;
	exports.easeSinIn = sinIn;
	exports.easeSinInOut = sinInOut;
	exports.easeSinOut = sinOut;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-chord/ v1.0.6 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(6), __webpack_require__(18)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
	}(this, (function (exports,d3Array,d3Path) { 'use strict';

	var cos = Math.cos;
	var sin = Math.sin;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau = pi * 2;
	var max = Math.max;

	function compareValue(compare) {
	  return function(a, b) {
	    return compare(
	      a.source.value + a.target.value,
	      b.source.value + b.target.value
	    );
	  };
	}

	function chord() {
	  var padAngle = 0,
	      sortGroups = null,
	      sortSubgroups = null,
	      sortChords = null;

	  function chord(matrix) {
	    var n = matrix.length,
	        groupSums = [],
	        groupIndex = d3Array.range(n),
	        subgroupIndex = [],
	        chords = [],
	        groups = chords.groups = new Array(n),
	        subgroups = new Array(n * n),
	        k,
	        x,
	        x0,
	        dx,
	        i,
	        j;

	    // Compute the sum.
	    k = 0, i = -1; while (++i < n) {
	      x = 0, j = -1; while (++j < n) {
	        x += matrix[i][j];
	      }
	      groupSums.push(x);
	      subgroupIndex.push(d3Array.range(n));
	      k += x;
	    }

	    // Sort groups…
	    if (sortGroups) groupIndex.sort(function(a, b) {
	      return sortGroups(groupSums[a], groupSums[b]);
	    });

	    // Sort subgroups…
	    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
	      d.sort(function(a, b) {
	        return sortSubgroups(matrix[i][a], matrix[i][b]);
	      });
	    });

	    // Convert the sum to scaling factor for [0, 2pi].
	    // TODO Allow start and end angle to be specified?
	    // TODO Allow padding to be specified as percentage?
	    k = max(0, tau - padAngle * n) / k;
	    dx = k ? padAngle : tau / n;

	    // Compute the start and end angle for each group and subgroup.
	    // Note: Opera has a bug reordering object literal properties!
	    x = 0, i = -1; while (++i < n) {
	      x0 = x, j = -1; while (++j < n) {
	        var di = groupIndex[i],
	            dj = subgroupIndex[di][j],
	            v = matrix[di][dj],
	            a0 = x,
	            a1 = x += v * k;
	        subgroups[dj * n + di] = {
	          index: di,
	          subindex: dj,
	          startAngle: a0,
	          endAngle: a1,
	          value: v
	        };
	      }
	      groups[di] = {
	        index: di,
	        startAngle: x0,
	        endAngle: x,
	        value: groupSums[di]
	      };
	      x += dx;
	    }

	    // Generate chords for each (non-empty) subgroup-subgroup link.
	    i = -1; while (++i < n) {
	      j = i - 1; while (++j < n) {
	        var source = subgroups[j * n + i],
	            target = subgroups[i * n + j];
	        if (source.value || target.value) {
	          chords.push(source.value < target.value
	              ? {source: target, target: source}
	              : {source: source, target: target});
	        }
	      }
	    }

	    return sortChords ? chords.sort(sortChords) : chords;
	  }

	  chord.padAngle = function(_) {
	    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
	  };

	  chord.sortGroups = function(_) {
	    return arguments.length ? (sortGroups = _, chord) : sortGroups;
	  };

	  chord.sortSubgroups = function(_) {
	    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
	  };

	  chord.sortChords = function(_) {
	    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
	  };

	  return chord;
	}

	var slice = Array.prototype.slice;

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function defaultSource(d) {
	  return d.source;
	}

	function defaultTarget(d) {
	  return d.target;
	}

	function defaultRadius(d) {
	  return d.radius;
	}

	function defaultStartAngle(d) {
	  return d.startAngle;
	}

	function defaultEndAngle(d) {
	  return d.endAngle;
	}

	function ribbon() {
	  var source = defaultSource,
	      target = defaultTarget,
	      radius = defaultRadius,
	      startAngle = defaultStartAngle,
	      endAngle = defaultEndAngle,
	      context = null;

	  function ribbon() {
	    var buffer,
	        argv = slice.call(arguments),
	        s = source.apply(this, argv),
	        t = target.apply(this, argv),
	        sr = +radius.apply(this, (argv[0] = s, argv)),
	        sa0 = startAngle.apply(this, argv) - halfPi,
	        sa1 = endAngle.apply(this, argv) - halfPi,
	        sx0 = sr * cos(sa0),
	        sy0 = sr * sin(sa0),
	        tr = +radius.apply(this, (argv[0] = t, argv)),
	        ta0 = startAngle.apply(this, argv) - halfPi,
	        ta1 = endAngle.apply(this, argv) - halfPi;

	    if (!context) context = buffer = d3Path.path();

	    context.moveTo(sx0, sy0);
	    context.arc(0, 0, sr, sa0, sa1);
	    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
	      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
	      context.arc(0, 0, tr, ta0, ta1);
	    }
	    context.quadraticCurveTo(0, 0, sx0, sy0);
	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  ribbon.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
	  };

	  ribbon.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
	  };

	  ribbon.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
	  };

	  ribbon.source = function(_) {
	    return arguments.length ? (source = _, ribbon) : source;
	  };

	  ribbon.target = function(_) {
	    return arguments.length ? (target = _, ribbon) : target;
	  };

	  ribbon.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
	  };

	  return ribbon;
	}

	exports.chord = chord;
	exports.ribbon = ribbon;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-path/ v1.0.9 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var pi = Math.PI,
	    tau = 2 * pi,
	    epsilon = 1e-6,
	    tauEpsilon = tau - epsilon;

	function Path() {
	  this._x0 = this._y0 = // start of current subpath
	  this._x1 = this._y1 = null; // end of current subpath
	  this._ = "";
	}

	function path() {
	  return new Path;
	}

	Path.prototype = path.prototype = {
	  constructor: Path,
	  moveTo: function(x, y) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
	  },
	  closePath: function() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  },
	  lineTo: function(x, y) {
	    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  quadraticCurveTo: function(x1, y1, x, y) {
	    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
	    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  arcTo: function(x1, y1, x2, y2, r) {
	    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
	    var x0 = this._x1,
	        y0 = this._y1,
	        x21 = x2 - x1,
	        y21 = y2 - y1,
	        x01 = x0 - x1,
	        y01 = y0 - y1,
	        l01_2 = x01 * x01 + y01 * y01;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x1,y1).
	    if (this._x1 === null) {
	      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
	    else if (!(l01_2 > epsilon));

	    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
	    // Equivalently, is (x1,y1) coincident with (x2,y2)?
	    // Or, is the radius zero? Line to (x1,y1).
	    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
	      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Otherwise, draw an arc!
	    else {
	      var x20 = x2 - x0,
	          y20 = y2 - y0,
	          l21_2 = x21 * x21 + y21 * y21,
	          l20_2 = x20 * x20 + y20 * y20,
	          l21 = Math.sqrt(l21_2),
	          l01 = Math.sqrt(l01_2),
	          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
	          t01 = l / l01,
	          t21 = l / l21;

	      // If the start tangent is not coincident with (x0,y0), line to.
	      if (Math.abs(t01 - 1) > epsilon) {
	        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
	      }

	      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
	    }
	  },
	  arc: function(x, y, r, a0, a1, ccw) {
	    x = +x, y = +y, r = +r, ccw = !!ccw;
	    var dx = r * Math.cos(a0),
	        dy = r * Math.sin(a0),
	        x0 = x + dx,
	        y0 = y + dy,
	        cw = 1 ^ ccw,
	        da = ccw ? a0 - a1 : a1 - a0;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x0,y0).
	    if (this._x1 === null) {
	      this._ += "M" + x0 + "," + y0;
	    }

	    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
	    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
	      this._ += "L" + x0 + "," + y0;
	    }

	    // Is this arc empty? We’re done.
	    if (!r) return;

	    // Does the angle go the wrong way? Flip the direction.
	    if (da < 0) da = da % tau + tau;

	    // Is this a complete circle? Draw two arcs to complete the circle.
	    if (da > tauEpsilon) {
	      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
	    }

	    // Is this arc non-empty? Draw an arc!
	    else if (da > epsilon) {
	      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
	    }
	  },
	  rect: function(x, y, w, h) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
	  },
	  toString: function() {
	    return this._;
	  }
	};

	exports.path = path;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var prefix = "$";

	function Map() {}

	Map.prototype = map.prototype = {
	  constructor: Map,
	  has: function(key) {
	    return (prefix + key) in this;
	  },
	  get: function(key) {
	    return this[prefix + key];
	  },
	  set: function(key, value) {
	    this[prefix + key] = value;
	    return this;
	  },
	  remove: function(key) {
	    var property = prefix + key;
	    return property in this && delete this[property];
	  },
	  clear: function() {
	    for (var property in this) if (property[0] === prefix) delete this[property];
	  },
	  keys: function() {
	    var keys = [];
	    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
	    return keys;
	  },
	  values: function() {
	    var values = [];
	    for (var property in this) if (property[0] === prefix) values.push(this[property]);
	    return values;
	  },
	  entries: function() {
	    var entries = [];
	    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
	    return entries;
	  },
	  size: function() {
	    var size = 0;
	    for (var property in this) if (property[0] === prefix) ++size;
	    return size;
	  },
	  empty: function() {
	    for (var property in this) if (property[0] === prefix) return false;
	    return true;
	  },
	  each: function(f) {
	    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
	  }
	};

	function map(object, f) {
	  var map = new Map;

	  // Copy constructor.
	  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

	  // Index array by numeric index or specified key function.
	  else if (Array.isArray(object)) {
	    var i = -1,
	        n = object.length,
	        o;

	    if (f == null) while (++i < n) map.set(i, object[i]);
	    else while (++i < n) map.set(f(o = object[i], i, object), o);
	  }

	  // Convert object to map.
	  else if (object) for (var key in object) map.set(key, object[key]);

	  return map;
	}

	function nest() {
	  var keys = [],
	      sortKeys = [],
	      sortValues,
	      rollup,
	      nest;

	  function apply(array, depth, createResult, setResult) {
	    if (depth >= keys.length) {
	      if (sortValues != null) array.sort(sortValues);
	      return rollup != null ? rollup(array) : array;
	    }

	    var i = -1,
	        n = array.length,
	        key = keys[depth++],
	        keyValue,
	        value,
	        valuesByKey = map(),
	        values,
	        result = createResult();

	    while (++i < n) {
	      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
	        values.push(value);
	      } else {
	        valuesByKey.set(keyValue, [value]);
	      }
	    }

	    valuesByKey.each(function(values, key) {
	      setResult(result, key, apply(values, depth, createResult, setResult));
	    });

	    return result;
	  }

	  function entries(map$$1, depth) {
	    if (++depth > keys.length) return map$$1;
	    var array, sortKey = sortKeys[depth - 1];
	    if (rollup != null && depth >= keys.length) array = map$$1.entries();
	    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
	    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
	  }

	  return nest = {
	    object: function(array) { return apply(array, 0, createObject, setObject); },
	    map: function(array) { return apply(array, 0, createMap, setMap); },
	    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
	    key: function(d) { keys.push(d); return nest; },
	    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
	    sortValues: function(order) { sortValues = order; return nest; },
	    rollup: function(f) { rollup = f; return nest; }
	  };
	}

	function createObject() {
	  return {};
	}

	function setObject(object, key, value) {
	  object[key] = value;
	}

	function createMap() {
	  return map();
	}

	function setMap(map$$1, key, value) {
	  map$$1.set(key, value);
	}

	function Set() {}

	var proto = map.prototype;

	Set.prototype = set.prototype = {
	  constructor: Set,
	  has: proto.has,
	  add: function(value) {
	    value += "";
	    this[prefix + value] = value;
	    return this;
	  },
	  remove: proto.remove,
	  clear: proto.clear,
	  values: proto.keys,
	  size: proto.size,
	  empty: proto.empty,
	  each: proto.each
	};

	function set(object, f) {
	  var set = new Set;

	  // Copy constructor.
	  if (object instanceof Set) object.each(function(value) { set.add(value); });

	  // Otherwise, assume it’s an array.
	  else if (object) {
	    var i = -1, n = object.length;
	    if (f == null) while (++i < n) set.add(object[i]);
	    else while (++i < n) set.add(f(object[i], i, object));
	  }

	  return set;
	}

	function keys(map) {
	  var keys = [];
	  for (var key in map) keys.push(key);
	  return keys;
	}

	function values(map) {
	  var values = [];
	  for (var key in map) values.push(map[key]);
	  return values;
	}

	function entries(map) {
	  var entries = [];
	  for (var key in map) entries.push({key: key, value: map[key]});
	  return entries;
	}

	exports.nest = nest;
	exports.set = set;
	exports.map = map;
	exports.keys = keys;
	exports.values = values;
	exports.entries = entries;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-contour/ v1.3.2 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(6)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Array) { 'use strict';

	var array = Array.prototype;

	var slice = array.slice;

	function ascending(a, b) {
	  return a - b;
	}

	function area(ring) {
	  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
	  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
	  return area;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function contains(ring, hole) {
	  var i = -1, n = hole.length, c;
	  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
	  return 0;
	}

	function ringContains(ring, point) {
	  var x = point[0], y = point[1], contains = -1;
	  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
	    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
	    if (segmentContains(pi, pj, point)) return 0;
	    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
	  }
	  return contains;
	}

	function segmentContains(a, b, c) {
	  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
	}

	function collinear(a, b, c) {
	  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
	}

	function within(p, q, r) {
	  return p <= q && q <= r || r <= q && q <= p;
	}

	function noop() {}

	var cases = [
	  [],
	  [[[1.0, 1.5], [0.5, 1.0]]],
	  [[[1.5, 1.0], [1.0, 1.5]]],
	  [[[1.5, 1.0], [0.5, 1.0]]],
	  [[[1.0, 0.5], [1.5, 1.0]]],
	  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
	  [[[1.0, 0.5], [1.0, 1.5]]],
	  [[[1.0, 0.5], [0.5, 1.0]]],
	  [[[0.5, 1.0], [1.0, 0.5]]],
	  [[[1.0, 1.5], [1.0, 0.5]]],
	  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
	  [[[1.5, 1.0], [1.0, 0.5]]],
	  [[[0.5, 1.0], [1.5, 1.0]]],
	  [[[1.0, 1.5], [1.5, 1.0]]],
	  [[[0.5, 1.0], [1.0, 1.5]]],
	  []
	];

	function contours() {
	  var dx = 1,
	      dy = 1,
	      threshold = d3Array.thresholdSturges,
	      smooth = smoothLinear;

	  function contours(values) {
	    var tz = threshold(values);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
	      tz = d3Array.tickStep(start, stop, tz);
	      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
	    } else {
	      tz = tz.slice().sort(ascending);
	    }

	    return tz.map(function(value) {
	      return contour(values, value);
	    });
	  }

	  // Accumulate, smooth contour rings, assign holes to exterior rings.
	  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
	  function contour(values, value) {
	    var polygons = [],
	        holes = [];

	    isorings(values, value, function(ring) {
	      smooth(ring, values, value);
	      if (area(ring) > 0) polygons.push([ring]);
	      else holes.push(ring);
	    });

	    holes.forEach(function(hole) {
	      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
	        if (contains((polygon = polygons[i])[0], hole) !== -1) {
	          polygon.push(hole);
	          return;
	        }
	      }
	    });

	    return {
	      type: "MultiPolygon",
	      value: value,
	      coordinates: polygons
	    };
	  }

	  // Marching squares with isolines stitched into rings.
	  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
	  function isorings(values, value, callback) {
	    var fragmentByStart = new Array,
	        fragmentByEnd = new Array,
	        x, y, t0, t1, t2, t3;

	    // Special case for the first row (y = -1, t2 = t3 = 0).
	    x = y = -1;
	    t1 = values[0] >= value;
	    cases[t1 << 1].forEach(stitch);
	    while (++x < dx - 1) {
	      t0 = t1, t1 = values[x + 1] >= value;
	      cases[t0 | t1 << 1].forEach(stitch);
	    }
	    cases[t1 << 0].forEach(stitch);

	    // General case for the intermediate rows.
	    while (++y < dy - 1) {
	      x = -1;
	      t1 = values[y * dx + dx] >= value;
	      t2 = values[y * dx] >= value;
	      cases[t1 << 1 | t2 << 2].forEach(stitch);
	      while (++x < dx - 1) {
	        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
	        t3 = t2, t2 = values[y * dx + x + 1] >= value;
	        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
	      }
	      cases[t1 | t2 << 3].forEach(stitch);
	    }

	    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
	    x = -1;
	    t2 = values[y * dx] >= value;
	    cases[t2 << 2].forEach(stitch);
	    while (++x < dx - 1) {
	      t3 = t2, t2 = values[y * dx + x + 1] >= value;
	      cases[t2 << 2 | t3 << 3].forEach(stitch);
	    }
	    cases[t2 << 3].forEach(stitch);

	    function stitch(line) {
	      var start = [line[0][0] + x, line[0][1] + y],
	          end = [line[1][0] + x, line[1][1] + y],
	          startIndex = index(start),
	          endIndex = index(end),
	          f, g;
	      if (f = fragmentByEnd[startIndex]) {
	        if (g = fragmentByStart[endIndex]) {
	          delete fragmentByEnd[f.end];
	          delete fragmentByStart[g.start];
	          if (f === g) {
	            f.ring.push(end);
	            callback(f.ring);
	          } else {
	            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
	          }
	        } else {
	          delete fragmentByEnd[f.end];
	          f.ring.push(end);
	          fragmentByEnd[f.end = endIndex] = f;
	        }
	      } else if (f = fragmentByStart[endIndex]) {
	        if (g = fragmentByEnd[startIndex]) {
	          delete fragmentByStart[f.start];
	          delete fragmentByEnd[g.end];
	          if (f === g) {
	            f.ring.push(end);
	            callback(f.ring);
	          } else {
	            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
	          }
	        } else {
	          delete fragmentByStart[f.start];
	          f.ring.unshift(start);
	          fragmentByStart[f.start = startIndex] = f;
	        }
	      } else {
	        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
	      }
	    }
	  }

	  function index(point) {
	    return point[0] * 2 + point[1] * (dx + 1) * 4;
	  }

	  function smoothLinear(ring, values, value) {
	    ring.forEach(function(point) {
	      var x = point[0],
	          y = point[1],
	          xt = x | 0,
	          yt = y | 0,
	          v0,
	          v1 = values[yt * dx + xt];
	      if (x > 0 && x < dx && xt === x) {
	        v0 = values[yt * dx + xt - 1];
	        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
	      }
	      if (y > 0 && y < dy && yt === y) {
	        v0 = values[(yt - 1) * dx + xt];
	        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
	      }
	    });
	  }

	  contours.contour = contour;

	  contours.size = function(_) {
	    if (!arguments.length) return [dx, dy];
	    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
	    return dx = _0, dy = _1, contours;
	  };

	  contours.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
	  };

	  contours.smooth = function(_) {
	    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
	  };

	  return contours;
	}

	// TODO Optimize edge cases.
	// TODO Optimize index calculation.
	// TODO Optimize arguments.
	function blurX(source, target, r) {
	  var n = source.width,
	      m = source.height,
	      w = (r << 1) + 1;
	  for (var j = 0; j < m; ++j) {
	    for (var i = 0, sr = 0; i < n + r; ++i) {
	      if (i < n) {
	        sr += source.data[i + j * n];
	      }
	      if (i >= r) {
	        if (i >= w) {
	          sr -= source.data[i - w + j * n];
	        }
	        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
	      }
	    }
	  }
	}

	// TODO Optimize edge cases.
	// TODO Optimize index calculation.
	// TODO Optimize arguments.
	function blurY(source, target, r) {
	  var n = source.width,
	      m = source.height,
	      w = (r << 1) + 1;
	  for (var i = 0; i < n; ++i) {
	    for (var j = 0, sr = 0; j < m + r; ++j) {
	      if (j < m) {
	        sr += source.data[i + j * n];
	      }
	      if (j >= r) {
	        if (j >= w) {
	          sr -= source.data[i + (j - w) * n];
	        }
	        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
	      }
	    }
	  }
	}

	function defaultX(d) {
	  return d[0];
	}

	function defaultY(d) {
	  return d[1];
	}

	function defaultWeight() {
	  return 1;
	}

	function density() {
	  var x = defaultX,
	      y = defaultY,
	      weight = defaultWeight,
	      dx = 960,
	      dy = 500,
	      r = 20, // blur radius
	      k = 2, // log2(grid cell size)
	      o = r * 3, // grid offset, to pad for blur
	      n = (dx + o * 2) >> k, // grid width
	      m = (dy + o * 2) >> k, // grid height
	      threshold = constant(20);

	  function density(data) {
	    var values0 = new Float32Array(n * m),
	        values1 = new Float32Array(n * m);

	    data.forEach(function(d, i, data) {
	      var xi = (+x(d, i, data) + o) >> k,
	          yi = (+y(d, i, data) + o) >> k,
	          wi = +weight(d, i, data);
	      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
	        values0[xi + yi * n] += wi;
	      }
	    });

	    // TODO Optimize.
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

	    var tz = threshold(values0);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      var stop = d3Array.max(values0);
	      tz = d3Array.tickStep(0, stop, tz);
	      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
	      tz.shift();
	    }

	    return contours()
	        .thresholds(tz)
	        .size([n, m])
	      (values0)
	        .map(transform);
	  }

	  function transform(geometry) {
	    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
	    geometry.coordinates.forEach(transformPolygon);
	    return geometry;
	  }

	  function transformPolygon(coordinates) {
	    coordinates.forEach(transformRing);
	  }

	  function transformRing(coordinates) {
	    coordinates.forEach(transformPoint);
	  }

	  // TODO Optimize.
	  function transformPoint(coordinates) {
	    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
	    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
	  }

	  function resize() {
	    o = r * 3;
	    n = (dx + o * 2) >> k;
	    m = (dy + o * 2) >> k;
	    return density;
	  }

	  density.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
	  };

	  density.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
	  };

	  density.weight = function(_) {
	    return arguments.length ? (weight = typeof _ === "function" ? _ : constant(+_), density) : weight;
	  };

	  density.size = function(_) {
	    if (!arguments.length) return [dx, dy];
	    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
	    return dx = _0, dy = _1, resize();
	  };

	  density.cellSize = function(_) {
	    if (!arguments.length) return 1 << k;
	    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
	    return k = Math.floor(Math.log(_) / Math.LN2), resize();
	  };

	  density.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
	  };

	  density.bandwidth = function(_) {
	    if (!arguments.length) return Math.sqrt(r * (r + 1));
	    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
	    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
	  };

	  return density;
	}

	exports.contours = contours;
	exports.contourDensity = density;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-dsv/ v1.2.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var EOL = {},
	    EOF = {},
	    QUOTE = 34,
	    NEWLINE = 10,
	    RETURN = 13;

	function objectConverter(columns) {
	  return new Function("d", "return {" + columns.map(function(name, i) {
	    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
	  }).join(",") + "}");
	}

	function customConverter(columns, f) {
	  var object = objectConverter(columns);
	  return function(row, i) {
	    return f(object(row), i, columns);
	  };
	}

	// Compute unique columns in order of discovery.
	function inferColumns(rows) {
	  var columnSet = Object.create(null),
	      columns = [];

	  rows.forEach(function(row) {
	    for (var column in row) {
	      if (!(column in columnSet)) {
	        columns.push(columnSet[column] = column);
	      }
	    }
	  });

	  return columns;
	}

	function pad(value, width) {
	  var s = value + "", length = s.length;
	  return length < width ? new Array(width - length + 1).join(0) + s : s;
	}

	function formatYear(year) {
	  return year < 0 ? "-" + pad(-year, 6)
	    : year > 9999 ? "+" + pad(year, 6)
	    : pad(year, 4);
	}

	function formatDate(date) {
	  var hours = date.getUTCHours(),
	      minutes = date.getUTCMinutes(),
	      seconds = date.getUTCSeconds(),
	      milliseconds = date.getUTCMilliseconds();
	  return isNaN(date) ? "Invalid Date"
	      : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
	      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
	      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
	      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
	      : "");
	}

	function dsv(delimiter) {
	  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
	      DELIMITER = delimiter.charCodeAt(0);

	  function parse(text, f) {
	    var convert, columns, rows = parseRows(text, function(row, i) {
	      if (convert) return convert(row, i - 1);
	      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
	    });
	    rows.columns = columns || [];
	    return rows;
	  }

	  function parseRows(text, f) {
	    var rows = [], // output rows
	        N = text.length,
	        I = 0, // current character index
	        n = 0, // current line number
	        t, // current token
	        eof = N <= 0, // current token followed by EOF?
	        eol = false; // current token followed by EOL?

	    // Strip the trailing newline.
	    if (text.charCodeAt(N - 1) === NEWLINE) --N;
	    if (text.charCodeAt(N - 1) === RETURN) --N;

	    function token() {
	      if (eof) return EOF;
	      if (eol) return eol = false, EOL;

	      // Unescape quotes.
	      var i, j = I, c;
	      if (text.charCodeAt(j) === QUOTE) {
	        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
	        if ((i = I) >= N) eof = true;
	        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
	      }

	      // Find next delimiter or newline.
	      while (I < N) {
	        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        else if (c !== DELIMITER) continue;
	        return text.slice(j, i);
	      }

	      // Return last token before EOF.
	      return eof = true, text.slice(j, N);
	    }

	    while ((t = token()) !== EOF) {
	      var row = [];
	      while (t !== EOL && t !== EOF) row.push(t), t = token();
	      if (f && (row = f(row, n++)) == null) continue;
	      rows.push(row);
	    }

	    return rows;
	  }

	  function preformatBody(rows, columns) {
	    return rows.map(function(row) {
	      return columns.map(function(column) {
	        return formatValue(row[column]);
	      }).join(delimiter);
	    });
	  }

	  function format(rows, columns) {
	    if (columns == null) columns = inferColumns(rows);
	    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
	  }

	  function formatBody(rows, columns) {
	    if (columns == null) columns = inferColumns(rows);
	    return preformatBody(rows, columns).join("\n");
	  }

	  function formatRows(rows) {
	    return rows.map(formatRow).join("\n");
	  }

	  function formatRow(row) {
	    return row.map(formatValue).join(delimiter);
	  }

	  function formatValue(value) {
	    return value == null ? ""
	        : value instanceof Date ? formatDate(value)
	        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
	        : value;
	  }

	  return {
	    parse: parse,
	    parseRows: parseRows,
	    format: format,
	    formatBody: formatBody,
	    formatRows: formatRows,
	    formatRow: formatRow,
	    formatValue: formatValue
	  };
	}

	var csv = dsv(",");

	var csvParse = csv.parse;
	var csvParseRows = csv.parseRows;
	var csvFormat = csv.format;
	var csvFormatBody = csv.formatBody;
	var csvFormatRows = csv.formatRows;
	var csvFormatRow = csv.formatRow;
	var csvFormatValue = csv.formatValue;

	var tsv = dsv("\t");

	var tsvParse = tsv.parse;
	var tsvParseRows = tsv.parseRows;
	var tsvFormat = tsv.format;
	var tsvFormatBody = tsv.formatBody;
	var tsvFormatRows = tsv.formatRows;
	var tsvFormatRow = tsv.formatRow;
	var tsvFormatValue = tsv.formatValue;

	function autoType(object) {
	  for (var key in object) {
	    var value = object[key].trim(), number, m;
	    if (!value) value = null;
	    else if (value === "true") value = true;
	    else if (value === "false") value = false;
	    else if (value === "NaN") value = NaN;
	    else if (!isNaN(number = +value)) value = number;
	    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
	      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
	      value = new Date(value);
	    }
	    else continue;
	    object[key] = value;
	  }
	  return object;
	}

	// https://github.com/d3/d3-dsv/issues/45
	var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

	exports.autoType = autoType;
	exports.csvFormat = csvFormat;
	exports.csvFormatBody = csvFormatBody;
	exports.csvFormatRow = csvFormatRow;
	exports.csvFormatRows = csvFormatRows;
	exports.csvFormatValue = csvFormatValue;
	exports.csvParse = csvParse;
	exports.csvParseRows = csvParseRows;
	exports.dsvFormat = dsv;
	exports.tsvFormat = tsvFormat;
	exports.tsvFormatBody = tsvFormatBody;
	exports.tsvFormatRow = tsvFormatRow;
	exports.tsvFormatRows = tsvFormatRows;
	exports.tsvFormatValue = tsvFormatValue;
	exports.tsvParse = tsvParse;
	exports.tsvParseRows = tsvParseRows;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-fetch/ v1.2.0 Copyright 2020 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(21)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dsv'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Dsv) { 'use strict';

	function responseBlob(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.blob();
	}

	function blob(input, init) {
	  return fetch(input, init).then(responseBlob);
	}

	function responseArrayBuffer(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.arrayBuffer();
	}

	function buffer(input, init) {
	  return fetch(input, init).then(responseArrayBuffer);
	}

	function responseText(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.text();
	}

	function text(input, init) {
	  return fetch(input, init).then(responseText);
	}

	function dsvParse(parse) {
	  return function(input, init, row) {
	    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
	    return text(input, init).then(function(response) {
	      return parse(response, row);
	    });
	  };
	}

	function dsv(delimiter, input, init, row) {
	  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
	  var format = d3Dsv.dsvFormat(delimiter);
	  return text(input, init).then(function(response) {
	    return format.parse(response, row);
	  });
	}

	var csv = dsvParse(d3Dsv.csvParse);
	var tsv = dsvParse(d3Dsv.tsvParse);

	function image(input, init) {
	  return new Promise(function(resolve, reject) {
	    var image = new Image;
	    for (var key in init) image[key] = init[key];
	    image.onerror = reject;
	    image.onload = function() { resolve(image); };
	    image.src = input;
	  });
	}

	function responseJson(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  if (response.status === 204 || response.status === 205) return;
	  return response.json();
	}

	function json(input, init) {
	  return fetch(input, init).then(responseJson);
	}

	function parser(type) {
	  return function(input, init)  {
	    return text(input, init).then(function(text) {
	      return (new DOMParser).parseFromString(text, type);
	    });
	  };
	}

	var xml = parser("application/xml");

	var html = parser("text/html");

	var svg = parser("image/svg+xml");

	exports.blob = blob;
	exports.buffer = buffer;
	exports.csv = csv;
	exports.dsv = dsv;
	exports.html = html;
	exports.image = image;
	exports.json = json;
	exports.svg = svg;
	exports.text = text;
	exports.tsv = tsv;
	exports.xml = xml;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-force/ v1.2.1 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(24), __webpack_require__(19), __webpack_require__(9), __webpack_require__(15)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

	function center(x, y) {
	  var nodes;

	  if (x == null) x = 0;
	  if (y == null) y = 0;

	  function force() {
	    var i,
	        n = nodes.length,
	        node,
	        sx = 0,
	        sy = 0;

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], sx += node.x, sy += node.y;
	    }

	    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
	      node = nodes[i], node.x -= sx, node.y -= sy;
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  return force;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function jiggle() {
	  return (Math.random() - 0.5) * 1e-6;
	}

	function x(d) {
	  return d.x + d.vx;
	}

	function y(d) {
	  return d.y + d.vy;
	}

	function collide(radius) {
	  var nodes,
	      radii,
	      strength = 1,
	      iterations = 1;

	  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

	  function force() {
	    var i, n = nodes.length,
	        tree,
	        node,
	        xi,
	        yi,
	        ri,
	        ri2;

	    for (var k = 0; k < iterations; ++k) {
	      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        ri = radii[node.index], ri2 = ri * ri;
	        xi = node.x + node.vx;
	        yi = node.y + node.vy;
	        tree.visit(apply);
	      }
	    }

	    function apply(quad, x0, y0, x1, y1) {
	      var data = quad.data, rj = quad.r, r = ri + rj;
	      if (data) {
	        if (data.index > node.index) {
	          var x = xi - data.x - data.vx,
	              y = yi - data.y - data.vy,
	              l = x * x + y * y;
	          if (l < r * r) {
	            if (x === 0) x = jiggle(), l += x * x;
	            if (y === 0) y = jiggle(), l += y * y;
	            l = (r - (l = Math.sqrt(l))) / l * strength;
	            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
	            node.vy += (y *= l) * r;
	            data.vx -= x * (r = 1 - r);
	            data.vy -= y * r;
	          }
	        }
	        return;
	      }
	      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
	    }
	  }

	  function prepare(quad) {
	    if (quad.data) return quad.r = radii[quad.data.index];
	    for (var i = quad.r = 0; i < 4; ++i) {
	      if (quad[i] && quad[i].r > quad.r) {
	        quad.r = quad[i].r;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    radii = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = +_, force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  return force;
	}

	function index(d) {
	  return d.index;
	}

	function find(nodeById, nodeId) {
	  var node = nodeById.get(nodeId);
	  if (!node) throw new Error("missing: " + nodeId);
	  return node;
	}

	function link(links) {
	  var id = index,
	      strength = defaultStrength,
	      strengths,
	      distance = constant(30),
	      distances,
	      nodes,
	      count,
	      bias,
	      iterations = 1;

	  if (links == null) links = [];

	  function defaultStrength(link) {
	    return 1 / Math.min(count[link.source.index], count[link.target.index]);
	  }

	  function force(alpha) {
	    for (var k = 0, n = links.length; k < iterations; ++k) {
	      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
	        link = links[i], source = link.source, target = link.target;
	        x = target.x + target.vx - source.x - source.vx || jiggle();
	        y = target.y + target.vy - source.y - source.vy || jiggle();
	        l = Math.sqrt(x * x + y * y);
	        l = (l - distances[i]) / l * alpha * strengths[i];
	        x *= l, y *= l;
	        target.vx -= x * (b = bias[i]);
	        target.vy -= y * b;
	        source.vx += x * (b = 1 - b);
	        source.vy += y * b;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;

	    var i,
	        n = nodes.length,
	        m = links.length,
	        nodeById = d3Collection.map(nodes, id),
	        link;

	    for (i = 0, count = new Array(n); i < m; ++i) {
	      link = links[i], link.index = i;
	      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
	      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
	      count[link.source.index] = (count[link.source.index] || 0) + 1;
	      count[link.target.index] = (count[link.target.index] || 0) + 1;
	    }

	    for (i = 0, bias = new Array(m); i < m; ++i) {
	      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
	    }

	    strengths = new Array(m), initializeStrength();
	    distances = new Array(m), initializeDistance();
	  }

	  function initializeStrength() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      strengths[i] = +strength(links[i], i, links);
	    }
	  }

	  function initializeDistance() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      distances[i] = +distance(links[i], i, links);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.links = function(_) {
	    return arguments.length ? (links = _, initialize(), force) : links;
	  };

	  force.id = function(_) {
	    return arguments.length ? (id = _, force) : id;
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
	  };

	  force.distance = function(_) {
	    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
	  };

	  return force;
	}

	function x$1(d) {
	  return d.x;
	}

	function y$1(d) {
	  return d.y;
	}

	var initialRadius = 10,
	    initialAngle = Math.PI * (3 - Math.sqrt(5));

	function simulation(nodes) {
	  var simulation,
	      alpha = 1,
	      alphaMin = 0.001,
	      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
	      alphaTarget = 0,
	      velocityDecay = 0.6,
	      forces = d3Collection.map(),
	      stepper = d3Timer.timer(step),
	      event = d3Dispatch.dispatch("tick", "end");

	  if (nodes == null) nodes = [];

	  function step() {
	    tick();
	    event.call("tick", simulation);
	    if (alpha < alphaMin) {
	      stepper.stop();
	      event.call("end", simulation);
	    }
	  }

	  function tick(iterations) {
	    var i, n = nodes.length, node;

	    if (iterations === undefined) iterations = 1;

	    for (var k = 0; k < iterations; ++k) {
	      alpha += (alphaTarget - alpha) * alphaDecay;

	      forces.each(function (force) {
	        force(alpha);
	      });

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        if (node.fx == null) node.x += node.vx *= velocityDecay;
	        else node.x = node.fx, node.vx = 0;
	        if (node.fy == null) node.y += node.vy *= velocityDecay;
	        else node.y = node.fy, node.vy = 0;
	      }
	    }

	    return simulation;
	  }

	  function initializeNodes() {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.index = i;
	      if (node.fx != null) node.x = node.fx;
	      if (node.fy != null) node.y = node.fy;
	      if (isNaN(node.x) || isNaN(node.y)) {
	        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
	        node.x = radius * Math.cos(angle);
	        node.y = radius * Math.sin(angle);
	      }
	      if (isNaN(node.vx) || isNaN(node.vy)) {
	        node.vx = node.vy = 0;
	      }
	    }
	  }

	  function initializeForce(force) {
	    if (force.initialize) force.initialize(nodes);
	    return force;
	  }

	  initializeNodes();

	  return simulation = {
	    tick: tick,

	    restart: function() {
	      return stepper.restart(step), simulation;
	    },

	    stop: function() {
	      return stepper.stop(), simulation;
	    },

	    nodes: function(_) {
	      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
	    },

	    alpha: function(_) {
	      return arguments.length ? (alpha = +_, simulation) : alpha;
	    },

	    alphaMin: function(_) {
	      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
	    },

	    alphaDecay: function(_) {
	      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
	    },

	    alphaTarget: function(_) {
	      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
	    },

	    velocityDecay: function(_) {
	      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
	    },

	    force: function(name, _) {
	      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
	    },

	    find: function(x, y, radius) {
	      var i = 0,
	          n = nodes.length,
	          dx,
	          dy,
	          d2,
	          node,
	          closest;

	      if (radius == null) radius = Infinity;
	      else radius *= radius;

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        dx = x - node.x;
	        dy = y - node.y;
	        d2 = dx * dx + dy * dy;
	        if (d2 < radius) closest = node, radius = d2;
	      }

	      return closest;
	    },

	    on: function(name, _) {
	      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
	    }
	  };
	}

	function manyBody() {
	  var nodes,
	      node,
	      alpha,
	      strength = constant(-30),
	      strengths,
	      distanceMin2 = 1,
	      distanceMax2 = Infinity,
	      theta2 = 0.81;

	  function force(_) {
	    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
	    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    strengths = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
	  }

	  function accumulate(quad) {
	    var strength = 0, q, c, weight = 0, x, y, i;

	    // For internal nodes, accumulate forces from child quadrants.
	    if (quad.length) {
	      for (x = y = i = 0; i < 4; ++i) {
	        if ((q = quad[i]) && (c = Math.abs(q.value))) {
	          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
	        }
	      }
	      quad.x = x / weight;
	      quad.y = y / weight;
	    }

	    // For leaf nodes, accumulate forces from coincident quadrants.
	    else {
	      q = quad;
	      q.x = q.data.x;
	      q.y = q.data.y;
	      do strength += strengths[q.data.index];
	      while (q = q.next);
	    }

	    quad.value = strength;
	  }

	  function apply(quad, x1, _, x2) {
	    if (!quad.value) return true;

	    var x = quad.x - node.x,
	        y = quad.y - node.y,
	        w = x2 - x1,
	        l = x * x + y * y;

	    // Apply the Barnes-Hut approximation if possible.
	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (w * w / theta2 < l) {
	      if (l < distanceMax2) {
	        if (x === 0) x = jiggle(), l += x * x;
	        if (y === 0) y = jiggle(), l += y * y;
	        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	        node.vx += x * quad.value * alpha / l;
	        node.vy += y * quad.value * alpha / l;
	      }
	      return true;
	    }

	    // Otherwise, process points directly.
	    else if (quad.length || l >= distanceMax2) return;

	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (quad.data !== node || quad.next) {
	      if (x === 0) x = jiggle(), l += x * x;
	      if (y === 0) y = jiggle(), l += y * y;
	      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	    }

	    do if (quad.data !== node) {
	      w = strengths[quad.data.index] * alpha / l;
	      node.vx += x * w;
	      node.vy += y * w;
	    } while (quad = quad.next);
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.distanceMin = function(_) {
	    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
	  };

	  force.distanceMax = function(_) {
	    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
	  };

	  force.theta = function(_) {
	    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
	  };

	  return force;
	}

	function radial(radius, x, y) {
	  var nodes,
	      strength = constant(0.1),
	      strengths,
	      radiuses;

	  if (typeof radius !== "function") radius = constant(+radius);
	  if (x == null) x = 0;
	  if (y == null) y = 0;

	  function force(alpha) {
	    for (var i = 0, n = nodes.length; i < n; ++i) {
	      var node = nodes[i],
	          dx = node.x - x || 1e-6,
	          dy = node.y - y || 1e-6,
	          r = Math.sqrt(dx * dx + dy * dy),
	          k = (radiuses[i] - r) * strengths[i] * alpha / r;
	      node.vx += dx * k;
	      node.vy += dy * k;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    radiuses = new Array(n);
	    for (i = 0; i < n; ++i) {
	      radiuses[i] = +radius(nodes[i], i, nodes);
	      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _, initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  return force;
	}

	function x$2(x) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      xz;

	  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    xz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
	  };

	  return force;
	}

	function y$2(y) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      yz;

	  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    yz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
	  };

	  return force;
	}

	exports.forceCenter = center;
	exports.forceCollide = collide;
	exports.forceLink = link;
	exports.forceManyBody = manyBody;
	exports.forceRadial = radial;
	exports.forceSimulation = simulation;
	exports.forceX = x$2;
	exports.forceY = y$2;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function tree_add(d) {
	  var x = +this._x.call(null, d),
	      y = +this._y.call(null, d);
	  return add(this.cover(x, y), x, y, d);
	}

	function add(tree, x, y, d) {
	  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

	  var parent,
	      node = tree._root,
	      leaf = {data: d},
	      x0 = tree._x0,
	      y0 = tree._y0,
	      x1 = tree._x1,
	      y1 = tree._y1,
	      xm,
	      ym,
	      xp,
	      yp,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return tree._root = leaf, tree;

	  // Find the existing leaf for the new point, or add it.
	  while (node.length) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
	  }

	  // Is the new point is exactly coincident with the existing point?
	  xp = +tree._x.call(null, node.data);
	  yp = +tree._y.call(null, node.data);
	  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

	  // Otherwise, split the leaf node until the old and new point are separated.
	  do {
	    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
	  return parent[j] = node, parent[i] = leaf, tree;
	}

	function addAll(data) {
	  var d, i, n = data.length,
	      x,
	      y,
	      xz = new Array(n),
	      yz = new Array(n),
	      x0 = Infinity,
	      y0 = Infinity,
	      x1 = -Infinity,
	      y1 = -Infinity;

	  // Compute the points and their extent.
	  for (i = 0; i < n; ++i) {
	    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
	    xz[i] = x;
	    yz[i] = y;
	    if (x < x0) x0 = x;
	    if (x > x1) x1 = x;
	    if (y < y0) y0 = y;
	    if (y > y1) y1 = y;
	  }

	  // If there were no (valid) points, abort.
	  if (x0 > x1 || y0 > y1) return this;

	  // Expand the tree to cover the new points.
	  this.cover(x0, y0).cover(x1, y1);

	  // Add the new points.
	  for (i = 0; i < n; ++i) {
	    add(this, xz[i], yz[i], data[i]);
	  }

	  return this;
	}

	function tree_cover(x, y) {
	  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

	  var x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1;

	  // If the quadtree has no extent, initialize them.
	  // Integer extent are necessary so that if we later double the extent,
	  // the existing quadrant boundaries don’t change due to floating point error!
	  if (isNaN(x0)) {
	    x1 = (x0 = Math.floor(x)) + 1;
	    y1 = (y0 = Math.floor(y)) + 1;
	  }

	  // Otherwise, double repeatedly to cover.
	  else {
	    var z = x1 - x0,
	        node = this._root,
	        parent,
	        i;

	    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
	      i = (y < y0) << 1 | (x < x0);
	      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
	      switch (i) {
	        case 0: x1 = x0 + z, y1 = y0 + z; break;
	        case 1: x0 = x1 - z, y1 = y0 + z; break;
	        case 2: x1 = x0 + z, y0 = y1 - z; break;
	        case 3: x0 = x1 - z, y0 = y1 - z; break;
	      }
	    }

	    if (this._root && this._root.length) this._root = node;
	  }

	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  return this;
	}

	function tree_data() {
	  var data = [];
	  this.visit(function(node) {
	    if (!node.length) do data.push(node.data); while (node = node.next)
	  });
	  return data;
	}

	function tree_extent(_) {
	  return arguments.length
	      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
	      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
	}

	function Quad(node, x0, y0, x1, y1) {
	  this.node = node;
	  this.x0 = x0;
	  this.y0 = y0;
	  this.x1 = x1;
	  this.y1 = y1;
	}

	function tree_find(x, y, radius) {
	  var data,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1,
	      y1,
	      x2,
	      y2,
	      x3 = this._x1,
	      y3 = this._y1,
	      quads = [],
	      node = this._root,
	      q,
	      i;

	  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
	  if (radius == null) radius = Infinity;
	  else {
	    x0 = x - radius, y0 = y - radius;
	    x3 = x + radius, y3 = y + radius;
	    radius *= radius;
	  }

	  while (q = quads.pop()) {

	    // Stop searching if this quadrant can’t contain a closer node.
	    if (!(node = q.node)
	        || (x1 = q.x0) > x3
	        || (y1 = q.y0) > y3
	        || (x2 = q.x1) < x0
	        || (y2 = q.y1) < y0) continue;

	    // Bisect the current quadrant.
	    if (node.length) {
	      var xm = (x1 + x2) / 2,
	          ym = (y1 + y2) / 2;

	      quads.push(
	        new Quad(node[3], xm, ym, x2, y2),
	        new Quad(node[2], x1, ym, xm, y2),
	        new Quad(node[1], xm, y1, x2, ym),
	        new Quad(node[0], x1, y1, xm, ym)
	      );

	      // Visit the closest quadrant first.
	      if (i = (y >= ym) << 1 | (x >= xm)) {
	        q = quads[quads.length - 1];
	        quads[quads.length - 1] = quads[quads.length - 1 - i];
	        quads[quads.length - 1 - i] = q;
	      }
	    }

	    // Visit this point. (Visiting coincident points isn’t necessary!)
	    else {
	      var dx = x - +this._x.call(null, node.data),
	          dy = y - +this._y.call(null, node.data),
	          d2 = dx * dx + dy * dy;
	      if (d2 < radius) {
	        var d = Math.sqrt(radius = d2);
	        x0 = x - d, y0 = y - d;
	        x3 = x + d, y3 = y + d;
	        data = node.data;
	      }
	    }
	  }

	  return data;
	}

	function tree_remove(d) {
	  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

	  var parent,
	      node = this._root,
	      retainer,
	      previous,
	      next,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1,
	      x,
	      y,
	      xm,
	      ym,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return this;

	  // Find the leaf node for the point.
	  // While descending, also retain the deepest parent with a non-removed sibling.
	  if (node.length) while (true) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
	    if (!node.length) break;
	    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
	  }

	  // Find the point to remove.
	  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
	  if (next = node.next) delete node.next;

	  // If there are multiple coincident points, remove just the point.
	  if (previous) return (next ? previous.next = next : delete previous.next), this;

	  // If this is the root point, remove it.
	  if (!parent) return this._root = next, this;

	  // Remove this leaf.
	  next ? parent[i] = next : delete parent[i];

	  // If the parent now contains exactly one leaf, collapse superfluous parents.
	  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
	      && node === (parent[3] || parent[2] || parent[1] || parent[0])
	      && !node.length) {
	    if (retainer) retainer[j] = node;
	    else this._root = node;
	  }

	  return this;
	}

	function removeAll(data) {
	  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
	  return this;
	}

	function tree_root() {
	  return this._root;
	}

	function tree_size() {
	  var size = 0;
	  this.visit(function(node) {
	    if (!node.length) do ++size; while (node = node.next)
	  });
	  return size;
	}

	function tree_visit(callback) {
	  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
	  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
	      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	    }
	  }
	  return this;
	}

	function tree_visitAfter(callback) {
	  var quads = [], next = [], q;
	  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    var node = q.node;
	    if (node.length) {
	      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	    }
	    next.push(q);
	  }
	  while (q = next.pop()) {
	    callback(q.node, q.x0, q.y0, q.x1, q.y1);
	  }
	  return this;
	}

	function defaultX(d) {
	  return d[0];
	}

	function tree_x(_) {
	  return arguments.length ? (this._x = _, this) : this._x;
	}

	function defaultY(d) {
	  return d[1];
	}

	function tree_y(_) {
	  return arguments.length ? (this._y = _, this) : this._y;
	}

	function quadtree(nodes, x, y) {
	  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
	  return nodes == null ? tree : tree.addAll(nodes);
	}

	function Quadtree(x, y, x0, y0, x1, y1) {
	  this._x = x;
	  this._y = y;
	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  this._root = undefined;
	}

	function leaf_copy(leaf) {
	  var copy = {data: leaf.data}, next = copy;
	  while (leaf = leaf.next) next = next.next = {data: leaf.data};
	  return copy;
	}

	var treeProto = quadtree.prototype = Quadtree.prototype;

	treeProto.copy = function() {
	  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
	      node = this._root,
	      nodes,
	      child;

	  if (!node) return copy;

	  if (!node.length) return copy._root = leaf_copy(node), copy;

	  nodes = [{source: node, target: copy._root = new Array(4)}];
	  while (node = nodes.pop()) {
	    for (var i = 0; i < 4; ++i) {
	      if (child = node.source[i]) {
	        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
	        else node.target[i] = leaf_copy(child);
	      }
	    }
	  }

	  return copy;
	};

	treeProto.add = tree_add;
	treeProto.addAll = addAll;
	treeProto.cover = tree_cover;
	treeProto.data = tree_data;
	treeProto.extent = tree_extent;
	treeProto.find = tree_find;
	treeProto.remove = tree_remove;
	treeProto.removeAll = removeAll;
	treeProto.root = tree_root;
	treeProto.size = tree_size;
	treeProto.visit = tree_visit;
	treeProto.visitAfter = tree_visitAfter;
	treeProto.x = tree_x;
	treeProto.y = tree_y;

	exports.quadtree = quadtree;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-format/ v1.4.4 Copyright 2020 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	// Computes the decimal coefficient and exponent of the specified number x with
	// significant digits p, where x is positive and p is in [1, 21] or undefined.
	// For example, formatDecimal(1.23) returns ["123", 0].
	function formatDecimal(x, p) {
	  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
	  var i, coefficient = x.slice(0, i);

	  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	  return [
	    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	    +x.slice(i + 1)
	  ];
	}

	function exponent(x) {
	  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
	}

	function formatGroup(grouping, thousands) {
	  return function(value, width) {
	    var i = value.length,
	        t = [],
	        j = 0,
	        g = grouping[0],
	        length = 0;

	    while (i > 0 && g > 0) {
	      if (length + g + 1 > width) g = Math.max(1, width - length);
	      t.push(value.substring(i -= g, i + g));
	      if ((length += g + 1) > width) break;
	      g = grouping[j = (j + 1) % grouping.length];
	    }

	    return t.reverse().join(thousands);
	  };
	}

	function formatNumerals(numerals) {
	  return function(value) {
	    return value.replace(/[0-9]/g, function(i) {
	      return numerals[+i];
	    });
	  };
	}

	// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
	var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

	function formatSpecifier(specifier) {
	  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	  var match;
	  return new FormatSpecifier({
	    fill: match[1],
	    align: match[2],
	    sign: match[3],
	    symbol: match[4],
	    zero: match[5],
	    width: match[6],
	    comma: match[7],
	    precision: match[8] && match[8].slice(1),
	    trim: match[9],
	    type: match[10]
	  });
	}

	formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

	function FormatSpecifier(specifier) {
	  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
	  this.align = specifier.align === undefined ? ">" : specifier.align + "";
	  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
	  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
	  this.zero = !!specifier.zero;
	  this.width = specifier.width === undefined ? undefined : +specifier.width;
	  this.comma = !!specifier.comma;
	  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
	  this.trim = !!specifier.trim;
	  this.type = specifier.type === undefined ? "" : specifier.type + "";
	}

	FormatSpecifier.prototype.toString = function() {
	  return this.fill
	      + this.align
	      + this.sign
	      + this.symbol
	      + (this.zero ? "0" : "")
	      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
	      + (this.comma ? "," : "")
	      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
	      + (this.trim ? "~" : "")
	      + this.type;
	};

	// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
	function formatTrim(s) {
	  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
	    switch (s[i]) {
	      case ".": i0 = i1 = i; break;
	      case "0": if (i0 === 0) i0 = i; i1 = i; break;
	      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
	    }
	  }
	  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
	}

	var prefixExponent;

	function formatPrefixAuto(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1],
	      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	      n = coefficient.length;
	  return i === n ? coefficient
	      : i > n ? coefficient + new Array(i - n + 1).join("0")
	      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	}

	function formatRounded(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1];
	  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	}

	var formatTypes = {
	  "%": function(x, p) { return (x * 100).toFixed(p); },
	  "b": function(x) { return Math.round(x).toString(2); },
	  "c": function(x) { return x + ""; },
	  "d": function(x) { return Math.round(x).toString(10); },
	  "e": function(x, p) { return x.toExponential(p); },
	  "f": function(x, p) { return x.toFixed(p); },
	  "g": function(x, p) { return x.toPrecision(p); },
	  "o": function(x) { return Math.round(x).toString(8); },
	  "p": function(x, p) { return formatRounded(x * 100, p); },
	  "r": formatRounded,
	  "s": formatPrefixAuto,
	  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	  "x": function(x) { return Math.round(x).toString(16); }
	};

	function identity(x) {
	  return x;
	}

	var map = Array.prototype.map,
	    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

	function formatLocale(locale) {
	  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
	      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
	      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
	      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
	      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
	      percent = locale.percent === undefined ? "%" : locale.percent + "",
	      minus = locale.minus === undefined ? "-" : locale.minus + "",
	      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

	  function newFormat(specifier) {
	    specifier = formatSpecifier(specifier);

	    var fill = specifier.fill,
	        align = specifier.align,
	        sign = specifier.sign,
	        symbol = specifier.symbol,
	        zero = specifier.zero,
	        width = specifier.width,
	        comma = specifier.comma,
	        precision = specifier.precision,
	        trim = specifier.trim,
	        type = specifier.type;

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // The "" type, and any invalid type, is an alias for ".12~g".
	    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    // Compute the prefix and suffix.
	    // For SI-prefix, the suffix is lazily computed.
	    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

	    // What format function should we use?
	    // Is this an integer type?
	    // Can this type generate exponential notation?
	    var formatType = formatTypes[type],
	        maybeSuffix = /[defgprs%]/.test(type);

	    // Set the default precision if not specified,
	    // or clamp the specified precision to the supported range.
	    // For significant precision, it must be in [1, 21].
	    // For fixed precision, it must be in [0, 20].
	    precision = precision === undefined ? 6
	        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	        : Math.max(0, Math.min(20, precision));

	    function format(value) {
	      var valuePrefix = prefix,
	          valueSuffix = suffix,
	          i, n, c;

	      if (type === "c") {
	        valueSuffix = formatType(value) + valueSuffix;
	        value = "";
	      } else {
	        value = +value;

	        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
	        var valueNegative = value < 0 || 1 / value < 0;

	        // Perform the initial formatting.
	        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

	        // Trim insignificant zeros.
	        if (trim) value = formatTrim(value);

	        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
	        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

	        // Compute the prefix and suffix.
	        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

	        // Break the formatted value into the integer “value” part that can be
	        // grouped, and fractional or exponential “suffix” part that is not.
	        if (maybeSuffix) {
	          i = -1, n = value.length;
	          while (++i < n) {
	            if (c = value.charCodeAt(i), 48 > c || c > 57) {
	              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	              value = value.slice(0, i);
	              break;
	            }
	          }
	        }
	      }

	      // If the fill character is not "0", grouping is applied before padding.
	      if (comma && !zero) value = group(value, Infinity);

	      // Compute the padding.
	      var length = valuePrefix.length + value.length + valueSuffix.length,
	          padding = length < width ? new Array(width - length + 1).join(fill) : "";

	      // If the fill character is "0", grouping is applied after padding.
	      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	      // Reconstruct the final output based on the desired alignment.
	      switch (align) {
	        case "<": value = valuePrefix + value + valueSuffix + padding; break;
	        case "=": value = valuePrefix + padding + value + valueSuffix; break;
	        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
	        default: value = padding + valuePrefix + value + valueSuffix; break;
	      }

	      return numerals(value);
	    }

	    format.toString = function() {
	      return specifier + "";
	    };

	    return format;
	  }

	  function formatPrefix(specifier, value) {
	    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	        k = Math.pow(10, -e),
	        prefix = prefixes[8 + e / 3];
	    return function(value) {
	      return f(k * value) + prefix;
	    };
	  }

	  return {
	    format: newFormat,
	    formatPrefix: formatPrefix
	  };
	}

	var locale;

	defaultLocale({
	  decimal: ".",
	  thousands: ",",
	  grouping: [3],
	  currency: ["$", ""],
	  minus: "-"
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  exports.format = locale.format;
	  exports.formatPrefix = locale.formatPrefix;
	  return locale;
	}

	function precisionFixed(step) {
	  return Math.max(0, -exponent(Math.abs(step)));
	}

	function precisionPrefix(step, value) {
	  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	}

	function precisionRound(step, max) {
	  step = Math.abs(step), max = Math.abs(max) - step;
	  return Math.max(0, exponent(max) - exponent(step)) + 1;
	}

	exports.FormatSpecifier = FormatSpecifier;
	exports.formatDefaultLocale = defaultLocale;
	exports.formatLocale = formatLocale;
	exports.formatSpecifier = formatSpecifier;
	exports.precisionFixed = precisionFixed;
	exports.precisionPrefix = precisionPrefix;
	exports.precisionRound = precisionRound;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-geo/ v1.12.1 Copyright 2020 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(6)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, (function (exports, d3Array) { 'use strict';

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305–363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	function adder() {
	  return new Adder;
	}

	function Adder() {
	  this.reset();
	}

	Adder.prototype = {
	  constructor: Adder,
	  reset: function() {
	    this.s = // rounded value
	    this.t = 0; // exact error
	  },
	  add: function(y) {
	    add(temp, y, this.t);
	    add(this, temp.s, this.s);
	    if (this.s) this.t += temp.t;
	    else this.s = temp.t;
	  },
	  valueOf: function() {
	    return this.s;
	  }
	};

	var temp = new Adder;

	function add(adder, a, b) {
	  var x = adder.s = a + b,
	      bv = x - a,
	      av = x - bv;
	  adder.t = (a - av) + (b - bv);
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var quarterPi = pi / 4;
	var tau = pi * 2;

	var degrees = 180 / pi;
	var radians = pi / 180;

	var abs = Math.abs;
	var atan = Math.atan;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var ceil = Math.ceil;
	var exp = Math.exp;
	var log = Math.log;
	var pow = Math.pow;
	var sin = Math.sin;
	var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
	var sqrt = Math.sqrt;
	var tan = Math.tan;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
	}

	function haversin(x) {
	  return (x = sin(x / 2)) * x;
	}

	function noop() {}

	function streamGeometry(geometry, stream) {
	  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
	    streamGeometryType[geometry.type](geometry, stream);
	  }
	}

	var streamObjectType = {
	  Feature: function(object, stream) {
	    streamGeometry(object.geometry, stream);
	  },
	  FeatureCollection: function(object, stream) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) streamGeometry(features[i].geometry, stream);
	  }
	};

	var streamGeometryType = {
	  Sphere: function(object, stream) {
	    stream.sphere();
	  },
	  Point: function(object, stream) {
	    object = object.coordinates;
	    stream.point(object[0], object[1], object[2]);
	  },
	  MultiPoint: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
	  },
	  LineString: function(object, stream) {
	    streamLine(object.coordinates, stream, 0);
	  },
	  MultiLineString: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamLine(coordinates[i], stream, 0);
	  },
	  Polygon: function(object, stream) {
	    streamPolygon(object.coordinates, stream);
	  },
	  MultiPolygon: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamPolygon(coordinates[i], stream);
	  },
	  GeometryCollection: function(object, stream) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) streamGeometry(geometries[i], stream);
	  }
	};

	function streamLine(coordinates, stream, closed) {
	  var i = -1, n = coordinates.length - closed, coordinate;
	  stream.lineStart();
	  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
	  stream.lineEnd();
	}

	function streamPolygon(coordinates, stream) {
	  var i = -1, n = coordinates.length;
	  stream.polygonStart();
	  while (++i < n) streamLine(coordinates[i], stream, 1);
	  stream.polygonEnd();
	}

	function geoStream(object, stream) {
	  if (object && streamObjectType.hasOwnProperty(object.type)) {
	    streamObjectType[object.type](object, stream);
	  } else {
	    streamGeometry(object, stream);
	  }
	}

	var areaRingSum = adder();

	var areaSum = adder(),
	    lambda00,
	    phi00,
	    lambda0,
	    cosPhi0,
	    sinPhi0;

	var areaStream = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaRingSum.reset();
	    areaStream.lineStart = areaRingStart;
	    areaStream.lineEnd = areaRingEnd;
	  },
	  polygonEnd: function() {
	    var areaRing = +areaRingSum;
	    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
	    this.lineStart = this.lineEnd = this.point = noop;
	  },
	  sphere: function() {
	    areaSum.add(tau);
	  }
	};

	function areaRingStart() {
	  areaStream.point = areaPointFirst;
	}

	function areaRingEnd() {
	  areaPoint(lambda00, phi00);
	}

	function areaPointFirst(lambda, phi) {
	  areaStream.point = areaPoint;
	  lambda00 = lambda, phi00 = phi;
	  lambda *= radians, phi *= radians;
	  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
	}

	function areaPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  phi = phi / 2 + quarterPi; // half the angular distance from south pole

	  // Spherical excess E for a spherical triangle with vertices: south pole,
	  // previous point, current point.  Uses a formula derived from Cagnoli’s
	  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
	  var dLambda = lambda - lambda0,
	      sdLambda = dLambda >= 0 ? 1 : -1,
	      adLambda = sdLambda * dLambda,
	      cosPhi = cos(phi),
	      sinPhi = sin(phi),
	      k = sinPhi0 * sinPhi,
	      u = cosPhi0 * cosPhi + k * cos(adLambda),
	      v = k * sdLambda * sin(adLambda);
	  areaRingSum.add(atan2(v, u));

	  // Advance the previous points.
	  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
	}

	function area(object) {
	  areaSum.reset();
	  geoStream(object, areaStream);
	  return areaSum * 2;
	}

	function spherical(cartesian) {
	  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
	}

	function cartesian(spherical) {
	  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
	  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
	}

	function cartesianDot(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	function cartesianCross(a, b) {
	  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
	}

	// TODO return a
	function cartesianAddInPlace(a, b) {
	  a[0] += b[0], a[1] += b[1], a[2] += b[2];
	}

	function cartesianScale(vector, k) {
	  return [vector[0] * k, vector[1] * k, vector[2] * k];
	}

	// TODO return d
	function cartesianNormalizeInPlace(d) {
	  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	  d[0] /= l, d[1] /= l, d[2] /= l;
	}

	var lambda0$1, phi0, lambda1, phi1, // bounds
	    lambda2, // previous lambda-coordinate
	    lambda00$1, phi00$1, // first point
	    p0, // previous 3D point
	    deltaSum = adder(),
	    ranges,
	    range;

	var boundsStream = {
	  point: boundsPoint,
	  lineStart: boundsLineStart,
	  lineEnd: boundsLineEnd,
	  polygonStart: function() {
	    boundsStream.point = boundsRingPoint;
	    boundsStream.lineStart = boundsRingStart;
	    boundsStream.lineEnd = boundsRingEnd;
	    deltaSum.reset();
	    areaStream.polygonStart();
	  },
	  polygonEnd: function() {
	    areaStream.polygonEnd();
	    boundsStream.point = boundsPoint;
	    boundsStream.lineStart = boundsLineStart;
	    boundsStream.lineEnd = boundsLineEnd;
	    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	    else if (deltaSum > epsilon) phi1 = 90;
	    else if (deltaSum < -epsilon) phi0 = -90;
	    range[0] = lambda0$1, range[1] = lambda1;
	  },
	  sphere: function() {
	    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	  }
	};

	function boundsPoint(lambda, phi) {
	  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	}

	function linePoint(lambda, phi) {
	  var p = cartesian([lambda * radians, phi * radians]);
	  if (p0) {
	    var normal = cartesianCross(p0, p),
	        equatorial = [normal[1], -normal[0], 0],
	        inflection = cartesianCross(equatorial, normal);
	    cartesianNormalizeInPlace(inflection);
	    inflection = spherical(inflection);
	    var delta = lambda - lambda2,
	        sign = delta > 0 ? 1 : -1,
	        lambdai = inflection[0] * degrees * sign,
	        phii,
	        antimeridian = abs(delta) > 180;
	    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
	      phii = inflection[1] * degrees;
	      if (phii > phi1) phi1 = phii;
	    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
	      phii = -inflection[1] * degrees;
	      if (phii < phi0) phi0 = phii;
	    } else {
	      if (phi < phi0) phi0 = phi;
	      if (phi > phi1) phi1 = phi;
	    }
	    if (antimeridian) {
	      if (lambda < lambda2) {
	        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	      } else {
	        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	      }
	    } else {
	      if (lambda1 >= lambda0$1) {
	        if (lambda < lambda0$1) lambda0$1 = lambda;
	        if (lambda > lambda1) lambda1 = lambda;
	      } else {
	        if (lambda > lambda2) {
	          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	        } else {
	          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	        }
	      }
	    }
	  } else {
	    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
	  }
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	  p0 = p, lambda2 = lambda;
	}

	function boundsLineStart() {
	  boundsStream.point = linePoint;
	}

	function boundsLineEnd() {
	  range[0] = lambda0$1, range[1] = lambda1;
	  boundsStream.point = boundsPoint;
	  p0 = null;
	}

	function boundsRingPoint(lambda, phi) {
	  if (p0) {
	    var delta = lambda - lambda2;
	    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
	  } else {
	    lambda00$1 = lambda, phi00$1 = phi;
	  }
	  areaStream.point(lambda, phi);
	  linePoint(lambda, phi);
	}

	function boundsRingStart() {
	  areaStream.lineStart();
	}

	function boundsRingEnd() {
	  boundsRingPoint(lambda00$1, phi00$1);
	  areaStream.lineEnd();
	  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
	  range[0] = lambda0$1, range[1] = lambda1;
	  p0 = null;
	}

	// Finds the left-right distance between two longitudes.
	// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
	// the distance between ±180° to be 360°.
	function angle(lambda0, lambda1) {
	  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
	}

	function rangeCompare(a, b) {
	  return a[0] - b[0];
	}

	function rangeContains(range, x) {
	  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	}

	function bounds(feature) {
	  var i, n, a, b, merged, deltaMax, delta;

	  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
	  ranges = [];
	  geoStream(feature, boundsStream);

	  // First, sort ranges by their minimum longitudes.
	  if (n = ranges.length) {
	    ranges.sort(rangeCompare);

	    // Then, merge any ranges that overlap.
	    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
	      b = ranges[i];
	      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
	        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	      } else {
	        merged.push(a = b);
	      }
	    }

	    // Finally, find the largest gap between the merged ranges.
	    // The final bounding box will be the inverse of this gap.
	    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
	      b = merged[i];
	      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
	    }
	  }

	  ranges = range = null;

	  return lambda0$1 === Infinity || phi0 === Infinity
	      ? [[NaN, NaN], [NaN, NaN]]
	      : [[lambda0$1, phi0], [lambda1, phi1]];
	}

	var W0, W1,
	    X0, Y0, Z0,
	    X1, Y1, Z1,
	    X2, Y2, Z2,
	    lambda00$2, phi00$2, // first point
	    x0, y0, z0; // previous point

	var centroidStream = {
	  sphere: noop,
	  point: centroidPoint,
	  lineStart: centroidLineStart,
	  lineEnd: centroidLineEnd,
	  polygonStart: function() {
	    centroidStream.lineStart = centroidRingStart;
	    centroidStream.lineEnd = centroidRingEnd;
	  },
	  polygonEnd: function() {
	    centroidStream.lineStart = centroidLineStart;
	    centroidStream.lineEnd = centroidLineEnd;
	  }
	};

	// Arithmetic mean of Cartesian vectors.
	function centroidPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
	}

	function centroidPointCartesian(x, y, z) {
	  ++W0;
	  X0 += (x - X0) / W0;
	  Y0 += (y - Y0) / W0;
	  Z0 += (z - Z0) / W0;
	}

	function centroidLineStart() {
	  centroidStream.point = centroidLinePointFirst;
	}

	function centroidLinePointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidStream.point = centroidLinePoint;
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLinePoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLineEnd() {
	  centroidStream.point = centroidPoint;
	}

	// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
	// J. Applied Mechanics 42, 239 (1975).
	function centroidRingStart() {
	  centroidStream.point = centroidRingPointFirst;
	}

	function centroidRingEnd() {
	  centroidRingPoint(lambda00$2, phi00$2);
	  centroidStream.point = centroidPoint;
	}

	function centroidRingPointFirst(lambda, phi) {
	  lambda00$2 = lambda, phi00$2 = phi;
	  lambda *= radians, phi *= radians;
	  centroidStream.point = centroidRingPoint;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidRingPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      cx = y0 * z - z0 * y,
	      cy = z0 * x - x0 * z,
	      cz = x0 * y - y0 * x,
	      m = sqrt(cx * cx + cy * cy + cz * cz),
	      w = asin(m), // line weight = angle
	      v = m && -w / m; // area weight multiplier
	  X2 += v * cx;
	  Y2 += v * cy;
	  Z2 += v * cz;
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroid(object) {
	  W0 = W1 =
	  X0 = Y0 = Z0 =
	  X1 = Y1 = Z1 =
	  X2 = Y2 = Z2 = 0;
	  geoStream(object, centroidStream);

	  var x = X2,
	      y = Y2,
	      z = Z2,
	      m = x * x + y * y + z * z;

	  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
	  if (m < epsilon2) {
	    x = X1, y = Y1, z = Z1;
	    // If the feature has zero length, fall back to arithmetic mean of point vectors.
	    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
	    m = x * x + y * y + z * z;
	    // If the feature still has an undefined ccentroid, then return.
	    if (m < epsilon2) return [NaN, NaN];
	  }

	  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function compose(a, b) {

	  function compose(x, y) {
	    return x = a(x, y), b(x[0], x[1]);
	  }

	  if (a.invert && b.invert) compose.invert = function(x, y) {
	    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	  };

	  return compose;
	}

	function rotationIdentity(lambda, phi) {
	  return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
	}

	rotationIdentity.invert = rotationIdentity;

	function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
	  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
	    : rotationLambda(deltaLambda))
	    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
	    : rotationIdentity);
	}

	function forwardRotationLambda(deltaLambda) {
	  return function(lambda, phi) {
	    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	  };
	}

	function rotationLambda(deltaLambda) {
	  var rotation = forwardRotationLambda(deltaLambda);
	  rotation.invert = forwardRotationLambda(-deltaLambda);
	  return rotation;
	}

	function rotationPhiGamma(deltaPhi, deltaGamma) {
	  var cosDeltaPhi = cos(deltaPhi),
	      sinDeltaPhi = sin(deltaPhi),
	      cosDeltaGamma = cos(deltaGamma),
	      sinDeltaGamma = sin(deltaGamma);

	  function rotation(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaPhi + x * sinDeltaPhi;
	    return [
	      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
	      asin(k * cosDeltaGamma + y * sinDeltaGamma)
	    ];
	  }

	  rotation.invert = function(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaGamma - y * sinDeltaGamma;
	    return [
	      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
	      asin(k * cosDeltaPhi - x * sinDeltaPhi)
	    ];
	  };

	  return rotation;
	}

	function rotation(rotate) {
	  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

	  function forward(coordinates) {
	    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  }

	  forward.invert = function(coordinates) {
	    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  };

	  return forward;
	}

	// Generates a circle centered at [0°, 0°], with a given radius and precision.
	function circleStream(stream, radius, delta, direction, t0, t1) {
	  if (!delta) return;
	  var cosRadius = cos(radius),
	      sinRadius = sin(radius),
	      step = direction * delta;
	  if (t0 == null) {
	    t0 = radius + direction * tau;
	    t1 = radius - step / 2;
	  } else {
	    t0 = circleRadius(cosRadius, t0);
	    t1 = circleRadius(cosRadius, t1);
	    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
	  }
	  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
	    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
	    stream.point(point[0], point[1]);
	  }
	}

	// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
	function circleRadius(cosRadius, point) {
	  point = cartesian(point), point[0] -= cosRadius;
	  cartesianNormalizeInPlace(point);
	  var radius = acos(-point[1]);
	  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
	}

	function circle() {
	  var center = constant([0, 0]),
	      radius = constant(90),
	      precision = constant(6),
	      ring,
	      rotate,
	      stream = {point: point};

	  function point(x, y) {
	    ring.push(x = rotate(x, y));
	    x[0] *= degrees, x[1] *= degrees;
	  }

	  function circle() {
	    var c = center.apply(this, arguments),
	        r = radius.apply(this, arguments) * radians,
	        p = precision.apply(this, arguments) * radians;
	    ring = [];
	    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
	    circleStream(stream, r, p, 1);
	    c = {type: "Polygon", coordinates: [ring]};
	    ring = rotate = null;
	    return c;
	  }

	  circle.center = function(_) {
	    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
	  };

	  circle.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
	  };

	  circle.precision = function(_) {
	    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
	  };

	  return circle;
	}

	function clipBuffer() {
	  var lines = [],
	      line;
	  return {
	    point: function(x, y, m) {
	      line.push([x, y, m]);
	    },
	    lineStart: function() {
	      lines.push(line = []);
	    },
	    lineEnd: noop,
	    rejoin: function() {
	      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	    },
	    result: function() {
	      var result = lines;
	      lines = [];
	      line = null;
	      return result;
	    }
	  };
	}

	function pointEqual(a, b) {
	  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
	}

	function Intersection(point, points, other, entry) {
	  this.x = point;
	  this.z = points;
	  this.o = other; // another intersection
	  this.e = entry; // is an entry?
	  this.v = false; // visited
	  this.n = this.p = null; // next & previous
	}

	// A generalized polygon clipping algorithm: given a polygon that has been cut
	// into its visible line segments, and rejoins the segments by interpolating
	// along the clip edge.
	function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
	  var subject = [],
	      clip = [],
	      i,
	      n;

	  segments.forEach(function(segment) {
	    if ((n = segment.length - 1) <= 0) return;
	    var n, p0 = segment[0], p1 = segment[n], x;

	    if (pointEqual(p0, p1)) {
	      if (!p0[2] && !p1[2]) {
	        stream.lineStart();
	        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
	        stream.lineEnd();
	        return;
	      }
	      // handle degenerate cases by moving the point
	      p1[0] += 2 * epsilon;
	    }

	    subject.push(x = new Intersection(p0, segment, null, true));
	    clip.push(x.o = new Intersection(p0, null, x, false));
	    subject.push(x = new Intersection(p1, segment, null, false));
	    clip.push(x.o = new Intersection(p1, null, x, true));
	  });

	  if (!subject.length) return;

	  clip.sort(compareIntersection);
	  link(subject);
	  link(clip);

	  for (i = 0, n = clip.length; i < n; ++i) {
	    clip[i].e = startInside = !startInside;
	  }

	  var start = subject[0],
	      points,
	      point;

	  while (1) {
	    // Find first unvisited intersection.
	    var current = start,
	        isSubject = true;
	    while (current.v) if ((current = current.n) === start) return;
	    points = current.z;
	    stream.lineStart();
	    do {
	      current.v = current.o.v = true;
	      if (current.e) {
	        if (isSubject) {
	          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.n.x, 1, stream);
	        }
	        current = current.n;
	      } else {
	        if (isSubject) {
	          points = current.p.z;
	          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.p.x, -1, stream);
	        }
	        current = current.p;
	      }
	      current = current.o;
	      points = current.z;
	      isSubject = !isSubject;
	    } while (!current.v);
	    stream.lineEnd();
	  }
	}

	function link(array) {
	  if (!(n = array.length)) return;
	  var n,
	      i = 0,
	      a = array[0],
	      b;
	  while (++i < n) {
	    a.n = b = array[i];
	    b.p = a;
	    a = b;
	  }
	  a.n = b = array[0];
	  b.p = a;
	}

	var sum = adder();

	function longitude(point) {
	  if (abs(point[0]) <= pi)
	    return point[0];
	  else
	    return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
	}

	function polygonContains(polygon, point) {
	  var lambda = longitude(point),
	      phi = point[1],
	      sinPhi = sin(phi),
	      normal = [sin(lambda), -cos(lambda), 0],
	      angle = 0,
	      winding = 0;

	  sum.reset();

	  if (sinPhi === 1) phi = halfPi + epsilon;
	  else if (sinPhi === -1) phi = -halfPi - epsilon;

	  for (var i = 0, n = polygon.length; i < n; ++i) {
	    if (!(m = (ring = polygon[i]).length)) continue;
	    var ring,
	        m,
	        point0 = ring[m - 1],
	        lambda0 = longitude(point0),
	        phi0 = point0[1] / 2 + quarterPi,
	        sinPhi0 = sin(phi0),
	        cosPhi0 = cos(phi0);

	    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
	      var point1 = ring[j],
	          lambda1 = longitude(point1),
	          phi1 = point1[1] / 2 + quarterPi,
	          sinPhi1 = sin(phi1),
	          cosPhi1 = cos(phi1),
	          delta = lambda1 - lambda0,
	          sign = delta >= 0 ? 1 : -1,
	          absDelta = sign * delta,
	          antimeridian = absDelta > pi,
	          k = sinPhi0 * sinPhi1;

	      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
	      angle += antimeridian ? delta + sign * tau : delta;

	      // Are the longitudes either side of the point’s meridian (lambda),
	      // and are the latitudes smaller than the parallel (phi)?
	      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
	        var arc = cartesianCross(cartesian(point0), cartesian(point1));
	        cartesianNormalizeInPlace(arc);
	        var intersection = cartesianCross(normal, arc);
	        cartesianNormalizeInPlace(intersection);
	        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
	        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
	          winding += antimeridian ^ delta >= 0 ? 1 : -1;
	        }
	      }
	    }
	  }

	  // First, determine whether the South pole is inside or outside:
	  //
	  // It is inside if:
	  // * the polygon winds around it in a clockwise direction.
	  // * the polygon does not (cumulatively) wind around it, but has a negative
	  //   (counter-clockwise) area.
	  //
	  // Second, count the (signed) number of times a segment crosses a lambda
	  // from the point to the South pole.  If it is zero, then the point is the
	  // same side as the South pole.

	  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
	}

	function clip(pointVisible, clipLine, interpolate, start) {
	  return function(sink) {
	    var line = clipLine(sink),
	        ringBuffer = clipBuffer(),
	        ringSink = clipLine(ringBuffer),
	        polygonStarted = false,
	        polygon,
	        segments,
	        ring;

	    var clip = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        clip.point = pointRing;
	        clip.lineStart = ringStart;
	        clip.lineEnd = ringEnd;
	        segments = [];
	        polygon = [];
	      },
	      polygonEnd: function() {
	        clip.point = point;
	        clip.lineStart = lineStart;
	        clip.lineEnd = lineEnd;
	        segments = d3Array.merge(segments);
	        var startInside = polygonContains(polygon, start);
	        if (segments.length) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
	        } else if (startInside) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          interpolate(null, null, 1, sink);
	          sink.lineEnd();
	        }
	        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
	        segments = polygon = null;
	      },
	      sphere: function() {
	        sink.polygonStart();
	        sink.lineStart();
	        interpolate(null, null, 1, sink);
	        sink.lineEnd();
	        sink.polygonEnd();
	      }
	    };

	    function point(lambda, phi) {
	      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
	    }

	    function pointLine(lambda, phi) {
	      line.point(lambda, phi);
	    }

	    function lineStart() {
	      clip.point = pointLine;
	      line.lineStart();
	    }

	    function lineEnd() {
	      clip.point = point;
	      line.lineEnd();
	    }

	    function pointRing(lambda, phi) {
	      ring.push([lambda, phi]);
	      ringSink.point(lambda, phi);
	    }

	    function ringStart() {
	      ringSink.lineStart();
	      ring = [];
	    }

	    function ringEnd() {
	      pointRing(ring[0][0], ring[0][1]);
	      ringSink.lineEnd();

	      var clean = ringSink.clean(),
	          ringSegments = ringBuffer.result(),
	          i, n = ringSegments.length, m,
	          segment,
	          point;

	      ring.pop();
	      polygon.push(ring);
	      ring = null;

	      if (!n) return;

	      // No intersections.
	      if (clean & 1) {
	        segment = ringSegments[0];
	        if ((m = segment.length - 1) > 0) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
	          sink.lineEnd();
	        }
	        return;
	      }

	      // Rejoin connected segments.
	      // TODO reuse ringBuffer.rejoin()?
	      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

	      segments.push(ringSegments.filter(validSegment));
	    }

	    return clip;
	  };
	}

	function validSegment(segment) {
	  return segment.length > 1;
	}

	// Intersections are sorted along the clip edge. For both antimeridian cutting
	// and circle clipping, the same comparison is used.
	function compareIntersection(a, b) {
	  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
	       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
	}

	var clipAntimeridian = clip(
	  function() { return true; },
	  clipAntimeridianLine,
	  clipAntimeridianInterpolate,
	  [-pi, -halfPi]
	);

	// Takes a line and cuts into visible segments. Return values: 0 - there were
	// intersections or the line was empty; 1 - no intersections; 2 - there were
	// intersections, and the first and last segments should be rejoined.
	function clipAntimeridianLine(stream) {
	  var lambda0 = NaN,
	      phi0 = NaN,
	      sign0 = NaN,
	      clean; // no intersections

	  return {
	    lineStart: function() {
	      stream.lineStart();
	      clean = 1;
	    },
	    point: function(lambda1, phi1) {
	      var sign1 = lambda1 > 0 ? pi : -pi,
	          delta = abs(lambda1 - lambda0);
	      if (abs(delta - pi) < epsilon) { // line crosses a pole
	        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        stream.point(lambda1, phi0);
	        clean = 0;
	      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
	        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
	        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
	        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        clean = 0;
	      }
	      stream.point(lambda0 = lambda1, phi0 = phi1);
	      sign0 = sign1;
	    },
	    lineEnd: function() {
	      stream.lineEnd();
	      lambda0 = phi0 = NaN;
	    },
	    clean: function() {
	      return 2 - clean; // if intersections, rejoin first and last segments
	    }
	  };
	}

	function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
	  var cosPhi0,
	      cosPhi1,
	      sinLambda0Lambda1 = sin(lambda0 - lambda1);
	  return abs(sinLambda0Lambda1) > epsilon
	      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
	          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
	          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
	      : (phi0 + phi1) / 2;
	}

	function clipAntimeridianInterpolate(from, to, direction, stream) {
	  var phi;
	  if (from == null) {
	    phi = direction * halfPi;
	    stream.point(-pi, phi);
	    stream.point(0, phi);
	    stream.point(pi, phi);
	    stream.point(pi, 0);
	    stream.point(pi, -phi);
	    stream.point(0, -phi);
	    stream.point(-pi, -phi);
	    stream.point(-pi, 0);
	    stream.point(-pi, phi);
	  } else if (abs(from[0] - to[0]) > epsilon) {
	    var lambda = from[0] < to[0] ? pi : -pi;
	    phi = direction * lambda / 2;
	    stream.point(-lambda, phi);
	    stream.point(0, phi);
	    stream.point(lambda, phi);
	  } else {
	    stream.point(to[0], to[1]);
	  }
	}

	function clipCircle(radius) {
	  var cr = cos(radius),
	      delta = 6 * radians,
	      smallRadius = cr > 0,
	      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

	  function interpolate(from, to, direction, stream) {
	    circleStream(stream, radius, delta, direction, from, to);
	  }

	  function visible(lambda, phi) {
	    return cos(lambda) * cos(phi) > cr;
	  }

	  // Takes a line and cuts into visible segments. Return values used for polygon
	  // clipping: 0 - there were intersections or the line was empty; 1 - no
	  // intersections 2 - there were intersections, and the first and last segments
	  // should be rejoined.
	  function clipLine(stream) {
	    var point0, // previous point
	        c0, // code for previous point
	        v0, // visibility of previous point
	        v00, // visibility of first point
	        clean; // no intersections
	    return {
	      lineStart: function() {
	        v00 = v0 = false;
	        clean = 1;
	      },
	      point: function(lambda, phi) {
	        var point1 = [lambda, phi],
	            point2,
	            v = visible(lambda, phi),
	            c = smallRadius
	              ? v ? 0 : code(lambda, phi)
	              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
	        if (!point0 && (v00 = v0 = v)) stream.lineStart();
	        if (v !== v0) {
	          point2 = intersect(point0, point1);
	          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
	            point1[2] = 1;
	        }
	        if (v !== v0) {
	          clean = 0;
	          if (v) {
	            // outside going in
	            stream.lineStart();
	            point2 = intersect(point1, point0);
	            stream.point(point2[0], point2[1]);
	          } else {
	            // inside going out
	            point2 = intersect(point0, point1);
	            stream.point(point2[0], point2[1], 2);
	            stream.lineEnd();
	          }
	          point0 = point2;
	        } else if (notHemisphere && point0 && smallRadius ^ v) {
	          var t;
	          // If the codes for two points are different, or are both zero,
	          // and there this segment intersects with the small circle.
	          if (!(c & c0) && (t = intersect(point1, point0, true))) {
	            clean = 0;
	            if (smallRadius) {
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	            } else {
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1], 3);
	            }
	          }
	        }
	        if (v && (!point0 || !pointEqual(point0, point1))) {
	          stream.point(point1[0], point1[1]);
	        }
	        point0 = point1, v0 = v, c0 = c;
	      },
	      lineEnd: function() {
	        if (v0) stream.lineEnd();
	        point0 = null;
	      },
	      // Rejoin first and last segments if there were intersections and the first
	      // and last points were visible.
	      clean: function() {
	        return clean | ((v00 && v0) << 1);
	      }
	    };
	  }

	  // Intersects the great circle between a and b with the clip circle.
	  function intersect(a, b, two) {
	    var pa = cartesian(a),
	        pb = cartesian(b);

	    // We have two planes, n1.p = d1 and n2.p = d2.
	    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
	    var n1 = [1, 0, 0], // normal
	        n2 = cartesianCross(pa, pb),
	        n2n2 = cartesianDot(n2, n2),
	        n1n2 = n2[0], // cartesianDot(n1, n2),
	        determinant = n2n2 - n1n2 * n1n2;

	    // Two polar points.
	    if (!determinant) return !two && a;

	    var c1 =  cr * n2n2 / determinant,
	        c2 = -cr * n1n2 / determinant,
	        n1xn2 = cartesianCross(n1, n2),
	        A = cartesianScale(n1, c1),
	        B = cartesianScale(n2, c2);
	    cartesianAddInPlace(A, B);

	    // Solve |p(t)|^2 = 1.
	    var u = n1xn2,
	        w = cartesianDot(A, u),
	        uu = cartesianDot(u, u),
	        t2 = w * w - uu * (cartesianDot(A, A) - 1);

	    if (t2 < 0) return;

	    var t = sqrt(t2),
	        q = cartesianScale(u, (-w - t) / uu);
	    cartesianAddInPlace(q, A);
	    q = spherical(q);

	    if (!two) return q;

	    // Two intersection points.
	    var lambda0 = a[0],
	        lambda1 = b[0],
	        phi0 = a[1],
	        phi1 = b[1],
	        z;

	    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

	    var delta = lambda1 - lambda0,
	        polar = abs(delta - pi) < epsilon,
	        meridian = polar || delta < epsilon;

	    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

	    // Check that the first point is between a and b.
	    if (meridian
	        ? polar
	          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
	          : phi0 <= q[1] && q[1] <= phi1
	        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
	      var q1 = cartesianScale(u, (-w + t) / uu);
	      cartesianAddInPlace(q1, A);
	      return [q, spherical(q1)];
	    }
	  }

	  // Generates a 4-bit vector representing the location of a point relative to
	  // the small circle's bounding box.
	  function code(lambda, phi) {
	    var r = smallRadius ? radius : pi - radius,
	        code = 0;
	    if (lambda < -r) code |= 1; // left
	    else if (lambda > r) code |= 2; // right
	    if (phi < -r) code |= 4; // below
	    else if (phi > r) code |= 8; // above
	    return code;
	  }

	  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
	}

	function clipLine(a, b, x0, y0, x1, y1) {
	  var ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
	  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
	  return true;
	}

	var clipMax = 1e9, clipMin = -clipMax;

	// TODO Use d3-polygon’s polygonContains here for the ring check?
	// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

	function clipRectangle(x0, y0, x1, y1) {

	  function visible(x, y) {
	    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	  }

	  function interpolate(from, to, direction, stream) {
	    var a = 0, a1 = 0;
	    if (from == null
	        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
	        || comparePoint(from, to) < 0 ^ direction > 0) {
	      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	      while ((a = (a + direction + 4) % 4) !== a1);
	    } else {
	      stream.point(to[0], to[1]);
	    }
	  }

	  function corner(p, direction) {
	    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
	        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
	        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
	        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
	  }

	  function compareIntersection(a, b) {
	    return comparePoint(a.x, b.x);
	  }

	  function comparePoint(a, b) {
	    var ca = corner(a, 1),
	        cb = corner(b, 1);
	    return ca !== cb ? ca - cb
	        : ca === 0 ? b[1] - a[1]
	        : ca === 1 ? a[0] - b[0]
	        : ca === 2 ? a[1] - b[1]
	        : b[0] - a[0];
	  }

	  return function(stream) {
	    var activeStream = stream,
	        bufferStream = clipBuffer(),
	        segments,
	        polygon,
	        ring,
	        x__, y__, v__, // first point
	        x_, y_, v_, // previous point
	        first,
	        clean;

	    var clipStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: polygonStart,
	      polygonEnd: polygonEnd
	    };

	    function point(x, y) {
	      if (visible(x, y)) activeStream.point(x, y);
	    }

	    function polygonInside() {
	      var winding = 0;

	      for (var i = 0, n = polygon.length; i < n; ++i) {
	        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
	          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
	          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
	          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
	        }
	      }

	      return winding;
	    }

	    // Buffer geometry within a polygon and then clip it en masse.
	    function polygonStart() {
	      activeStream = bufferStream, segments = [], polygon = [], clean = true;
	    }

	    function polygonEnd() {
	      var startInside = polygonInside(),
	          cleanInside = clean && startInside,
	          visible = (segments = d3Array.merge(segments)).length;
	      if (cleanInside || visible) {
	        stream.polygonStart();
	        if (cleanInside) {
	          stream.lineStart();
	          interpolate(null, null, 1, stream);
	          stream.lineEnd();
	        }
	        if (visible) {
	          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
	        }
	        stream.polygonEnd();
	      }
	      activeStream = stream, segments = polygon = ring = null;
	    }

	    function lineStart() {
	      clipStream.point = linePoint;
	      if (polygon) polygon.push(ring = []);
	      first = true;
	      v_ = false;
	      x_ = y_ = NaN;
	    }

	    // TODO rather than special-case polygons, simply handle them separately.
	    // Ideally, coincident intersection points should be jittered to avoid
	    // clipping issues.
	    function lineEnd() {
	      if (segments) {
	        linePoint(x__, y__);
	        if (v__ && v_) bufferStream.rejoin();
	        segments.push(bufferStream.result());
	      }
	      clipStream.point = point;
	      if (v_) activeStream.lineEnd();
	    }

	    function linePoint(x, y) {
	      var v = visible(x, y);
	      if (polygon) ring.push([x, y]);
	      if (first) {
	        x__ = x, y__ = y, v__ = v;
	        first = false;
	        if (v) {
	          activeStream.lineStart();
	          activeStream.point(x, y);
	        }
	      } else {
	        if (v && v_) activeStream.point(x, y);
	        else {
	          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
	              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
	          if (clipLine(a, b, x0, y0, x1, y1)) {
	            if (!v_) {
	              activeStream.lineStart();
	              activeStream.point(a[0], a[1]);
	            }
	            activeStream.point(b[0], b[1]);
	            if (!v) activeStream.lineEnd();
	            clean = false;
	          } else if (v) {
	            activeStream.lineStart();
	            activeStream.point(x, y);
	            clean = false;
	          }
	        }
	      }
	      x_ = x, y_ = y, v_ = v;
	    }

	    return clipStream;
	  };
	}

	function extent() {
	  var x0 = 0,
	      y0 = 0,
	      x1 = 960,
	      y1 = 500,
	      cache,
	      cacheStream,
	      clip;

	  return clip = {
	    stream: function(stream) {
	      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
	    },
	    extent: function(_) {
	      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
	    }
	  };
	}

	var lengthSum = adder(),
	    lambda0$2,
	    sinPhi0$1,
	    cosPhi0$1;

	var lengthStream = {
	  sphere: noop,
	  point: noop,
	  lineStart: lengthLineStart,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop
	};

	function lengthLineStart() {
	  lengthStream.point = lengthPointFirst;
	  lengthStream.lineEnd = lengthLineEnd;
	}

	function lengthLineEnd() {
	  lengthStream.point = lengthStream.lineEnd = noop;
	}

	function lengthPointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
	  lengthStream.point = lengthPoint;
	}

	function lengthPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var sinPhi = sin(phi),
	      cosPhi = cos(phi),
	      delta = abs(lambda - lambda0$2),
	      cosDelta = cos(delta),
	      sinDelta = sin(delta),
	      x = cosPhi * sinDelta,
	      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
	      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
	  lengthSum.add(atan2(sqrt(x * x + y * y), z));
	  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
	}

	function length(object) {
	  lengthSum.reset();
	  geoStream(object, lengthStream);
	  return +lengthSum;
	}

	var coordinates = [null, null],
	    object = {type: "LineString", coordinates: coordinates};

	function distance(a, b) {
	  coordinates[0] = a;
	  coordinates[1] = b;
	  return length(object);
	}

	var containsObjectType = {
	  Feature: function(object, point) {
	    return containsGeometry(object.geometry, point);
	  },
	  FeatureCollection: function(object, point) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
	    return false;
	  }
	};

	var containsGeometryType = {
	  Sphere: function() {
	    return true;
	  },
	  Point: function(object, point) {
	    return containsPoint(object.coordinates, point);
	  },
	  MultiPoint: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
	    return false;
	  },
	  LineString: function(object, point) {
	    return containsLine(object.coordinates, point);
	  },
	  MultiLineString: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsLine(coordinates[i], point)) return true;
	    return false;
	  },
	  Polygon: function(object, point) {
	    return containsPolygon(object.coordinates, point);
	  },
	  MultiPolygon: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
	    return false;
	  },
	  GeometryCollection: function(object, point) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
	    return false;
	  }
	};

	function containsGeometry(geometry, point) {
	  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
	      ? containsGeometryType[geometry.type](geometry, point)
	      : false;
	}

	function containsPoint(coordinates, point) {
	  return distance(coordinates, point) === 0;
	}

	function containsLine(coordinates, point) {
	  var ao, bo, ab;
	  for (var i = 0, n = coordinates.length; i < n; i++) {
	    bo = distance(coordinates[i], point);
	    if (bo === 0) return true;
	    if (i > 0) {
	      ab = distance(coordinates[i], coordinates[i - 1]);
	      if (
	        ab > 0 &&
	        ao <= ab &&
	        bo <= ab &&
	        (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
	      )
	        return true;
	    }
	    ao = bo;
	  }
	  return false;
	}

	function containsPolygon(coordinates, point) {
	  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
	}

	function ringRadians(ring) {
	  return ring = ring.map(pointRadians), ring.pop(), ring;
	}

	function pointRadians(point) {
	  return [point[0] * radians, point[1] * radians];
	}

	function contains(object, point) {
	  return (object && containsObjectType.hasOwnProperty(object.type)
	      ? containsObjectType[object.type]
	      : containsGeometry)(object, point);
	}

	function graticuleX(y0, y1, dy) {
	  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
	  return function(x) { return y.map(function(y) { return [x, y]; }); };
	}

	function graticuleY(x0, x1, dx) {
	  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
	  return function(y) { return x.map(function(x) { return [x, y]; }); };
	}

	function graticule() {
	  var x1, x0, X1, X0,
	      y1, y0, Y1, Y0,
	      dx = 10, dy = dx, DX = 90, DY = 360,
	      x, y, X, Y,
	      precision = 2.5;

	  function graticule() {
	    return {type: "MultiLineString", coordinates: lines()};
	  }

	  function lines() {
	    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
	        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
	        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
	        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
	  }

	  graticule.lines = function() {
	    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
	  };

	  graticule.outline = function() {
	    return {
	      type: "Polygon",
	      coordinates: [
	        X(X0).concat(
	        Y(Y1).slice(1),
	        X(X1).reverse().slice(1),
	        Y(Y0).reverse().slice(1))
	      ]
	    };
	  };

	  graticule.extent = function(_) {
	    if (!arguments.length) return graticule.extentMinor();
	    return graticule.extentMajor(_).extentMinor(_);
	  };

	  graticule.extentMajor = function(_) {
	    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
	    X0 = +_[0][0], X1 = +_[1][0];
	    Y0 = +_[0][1], Y1 = +_[1][1];
	    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.extentMinor = function(_) {
	    if (!arguments.length) return [[x0, y0], [x1, y1]];
	    x0 = +_[0][0], x1 = +_[1][0];
	    y0 = +_[0][1], y1 = +_[1][1];
	    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.step = function(_) {
	    if (!arguments.length) return graticule.stepMinor();
	    return graticule.stepMajor(_).stepMinor(_);
	  };

	  graticule.stepMajor = function(_) {
	    if (!arguments.length) return [DX, DY];
	    DX = +_[0], DY = +_[1];
	    return graticule;
	  };

	  graticule.stepMinor = function(_) {
	    if (!arguments.length) return [dx, dy];
	    dx = +_[0], dy = +_[1];
	    return graticule;
	  };

	  graticule.precision = function(_) {
	    if (!arguments.length) return precision;
	    precision = +_;
	    x = graticuleX(y0, y1, 90);
	    y = graticuleY(x0, x1, precision);
	    X = graticuleX(Y0, Y1, 90);
	    Y = graticuleY(X0, X1, precision);
	    return graticule;
	  };

	  return graticule
	      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
	      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
	}

	function graticule10() {
	  return graticule()();
	}

	function interpolate(a, b) {
	  var x0 = a[0] * radians,
	      y0 = a[1] * radians,
	      x1 = b[0] * radians,
	      y1 = b[1] * radians,
	      cy0 = cos(y0),
	      sy0 = sin(y0),
	      cy1 = cos(y1),
	      sy1 = sin(y1),
	      kx0 = cy0 * cos(x0),
	      ky0 = cy0 * sin(x0),
	      kx1 = cy1 * cos(x1),
	      ky1 = cy1 * sin(x1),
	      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
	      k = sin(d);

	  var interpolate = d ? function(t) {
	    var B = sin(t *= d) / k,
	        A = sin(d - t) / k,
	        x = A * kx0 + B * kx1,
	        y = A * ky0 + B * ky1,
	        z = A * sy0 + B * sy1;
	    return [
	      atan2(y, x) * degrees,
	      atan2(z, sqrt(x * x + y * y)) * degrees
	    ];
	  } : function() {
	    return [x0 * degrees, y0 * degrees];
	  };

	  interpolate.distance = d;

	  return interpolate;
	}

	function identity(x) {
	  return x;
	}

	var areaSum$1 = adder(),
	    areaRingSum$1 = adder(),
	    x00,
	    y00,
	    x0$1,
	    y0$1;

	var areaStream$1 = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaStream$1.lineStart = areaRingStart$1;
	    areaStream$1.lineEnd = areaRingEnd$1;
	  },
	  polygonEnd: function() {
	    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
	    areaSum$1.add(abs(areaRingSum$1));
	    areaRingSum$1.reset();
	  },
	  result: function() {
	    var area = areaSum$1 / 2;
	    areaSum$1.reset();
	    return area;
	  }
	};

	function areaRingStart$1() {
	  areaStream$1.point = areaPointFirst$1;
	}

	function areaPointFirst$1(x, y) {
	  areaStream$1.point = areaPoint$1;
	  x00 = x0$1 = x, y00 = y0$1 = y;
	}

	function areaPoint$1(x, y) {
	  areaRingSum$1.add(y0$1 * x - x0$1 * y);
	  x0$1 = x, y0$1 = y;
	}

	function areaRingEnd$1() {
	  areaPoint$1(x00, y00);
	}

	var x0$2 = Infinity,
	    y0$2 = x0$2,
	    x1 = -x0$2,
	    y1 = x1;

	var boundsStream$1 = {
	  point: boundsPoint$1,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop,
	  result: function() {
	    var bounds = [[x0$2, y0$2], [x1, y1]];
	    x1 = y1 = -(y0$2 = x0$2 = Infinity);
	    return bounds;
	  }
	};

	function boundsPoint$1(x, y) {
	  if (x < x0$2) x0$2 = x;
	  if (x > x1) x1 = x;
	  if (y < y0$2) y0$2 = y;
	  if (y > y1) y1 = y;
	}

	// TODO Enforce positive area for exterior, negative area for interior?

	var X0$1 = 0,
	    Y0$1 = 0,
	    Z0$1 = 0,
	    X1$1 = 0,
	    Y1$1 = 0,
	    Z1$1 = 0,
	    X2$1 = 0,
	    Y2$1 = 0,
	    Z2$1 = 0,
	    x00$1,
	    y00$1,
	    x0$3,
	    y0$3;

	var centroidStream$1 = {
	  point: centroidPoint$1,
	  lineStart: centroidLineStart$1,
	  lineEnd: centroidLineEnd$1,
	  polygonStart: function() {
	    centroidStream$1.lineStart = centroidRingStart$1;
	    centroidStream$1.lineEnd = centroidRingEnd$1;
	  },
	  polygonEnd: function() {
	    centroidStream$1.point = centroidPoint$1;
	    centroidStream$1.lineStart = centroidLineStart$1;
	    centroidStream$1.lineEnd = centroidLineEnd$1;
	  },
	  result: function() {
	    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
	        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
	        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
	        : [NaN, NaN];
	    X0$1 = Y0$1 = Z0$1 =
	    X1$1 = Y1$1 = Z1$1 =
	    X2$1 = Y2$1 = Z2$1 = 0;
	    return centroid;
	  }
	};

	function centroidPoint$1(x, y) {
	  X0$1 += x;
	  Y0$1 += y;
	  ++Z0$1;
	}

	function centroidLineStart$1() {
	  centroidStream$1.point = centroidPointFirstLine;
	}

	function centroidPointFirstLine(x, y) {
	  centroidStream$1.point = centroidPointLine;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidPointLine(x, y) {
	  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidLineEnd$1() {
	  centroidStream$1.point = centroidPoint$1;
	}

	function centroidRingStart$1() {
	  centroidStream$1.point = centroidPointFirstRing;
	}

	function centroidRingEnd$1() {
	  centroidPointRing(x00$1, y00$1);
	}

	function centroidPointFirstRing(x, y) {
	  centroidStream$1.point = centroidPointRing;
	  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
	}

	function centroidPointRing(x, y) {
	  var dx = x - x0$3,
	      dy = y - y0$3,
	      z = sqrt(dx * dx + dy * dy);

	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;

	  z = y0$3 * x - x0$3 * y;
	  X2$1 += z * (x0$3 + x);
	  Y2$1 += z * (y0$3 + y);
	  Z2$1 += z * 3;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function PathContext(context) {
	  this._context = context;
	}

	PathContext.prototype = {
	  _radius: 4.5,
	  pointRadius: function(_) {
	    return this._radius = _, this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._context.closePath();
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._context.moveTo(x, y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._context.lineTo(x, y);
	        break;
	      }
	      default: {
	        this._context.moveTo(x + this._radius, y);
	        this._context.arc(x, y, this._radius, 0, tau);
	        break;
	      }
	    }
	  },
	  result: noop
	};

	var lengthSum$1 = adder(),
	    lengthRing,
	    x00$2,
	    y00$2,
	    x0$4,
	    y0$4;

	var lengthStream$1 = {
	  point: noop,
	  lineStart: function() {
	    lengthStream$1.point = lengthPointFirst$1;
	  },
	  lineEnd: function() {
	    if (lengthRing) lengthPoint$1(x00$2, y00$2);
	    lengthStream$1.point = noop;
	  },
	  polygonStart: function() {
	    lengthRing = true;
	  },
	  polygonEnd: function() {
	    lengthRing = null;
	  },
	  result: function() {
	    var length = +lengthSum$1;
	    lengthSum$1.reset();
	    return length;
	  }
	};

	function lengthPointFirst$1(x, y) {
	  lengthStream$1.point = lengthPoint$1;
	  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
	}

	function lengthPoint$1(x, y) {
	  x0$4 -= x, y0$4 -= y;
	  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
	  x0$4 = x, y0$4 = y;
	}

	function PathString() {
	  this._string = [];
	}

	PathString.prototype = {
	  _radius: 4.5,
	  _circle: circle$1(4.5),
	  pointRadius: function(_) {
	    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
	    return this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._string.push("Z");
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._string.push("M", x, ",", y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._string.push("L", x, ",", y);
	        break;
	      }
	      default: {
	        if (this._circle == null) this._circle = circle$1(this._radius);
	        this._string.push("M", x, ",", y, this._circle);
	        break;
	      }
	    }
	  },
	  result: function() {
	    if (this._string.length) {
	      var result = this._string.join("");
	      this._string = [];
	      return result;
	    } else {
	      return null;
	    }
	  }
	};

	function circle$1(radius) {
	  return "m0," + radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
	      + "z";
	}

	function index(projection, context) {
	  var pointRadius = 4.5,
	      projectionStream,
	      contextStream;

	  function path(object) {
	    if (object) {
	      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	      geoStream(object, projectionStream(contextStream));
	    }
	    return contextStream.result();
	  }

	  path.area = function(object) {
	    geoStream(object, projectionStream(areaStream$1));
	    return areaStream$1.result();
	  };

	  path.measure = function(object) {
	    geoStream(object, projectionStream(lengthStream$1));
	    return lengthStream$1.result();
	  };

	  path.bounds = function(object) {
	    geoStream(object, projectionStream(boundsStream$1));
	    return boundsStream$1.result();
	  };

	  path.centroid = function(object) {
	    geoStream(object, projectionStream(centroidStream$1));
	    return centroidStream$1.result();
	  };

	  path.projection = function(_) {
	    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
	  };

	  path.context = function(_) {
	    if (!arguments.length) return context;
	    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
	    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	    return path;
	  };

	  path.pointRadius = function(_) {
	    if (!arguments.length) return pointRadius;
	    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	    return path;
	  };

	  return path.projection(projection).context(context);
	}

	function transform(methods) {
	  return {
	    stream: transformer(methods)
	  };
	}

	function transformer(methods) {
	  return function(stream) {
	    var s = new TransformStream;
	    for (var key in methods) s[key] = methods[key];
	    s.stream = stream;
	    return s;
	  };
	}

	function TransformStream() {}

	TransformStream.prototype = {
	  constructor: TransformStream,
	  point: function(x, y) { this.stream.point(x, y); },
	  sphere: function() { this.stream.sphere(); },
	  lineStart: function() { this.stream.lineStart(); },
	  lineEnd: function() { this.stream.lineEnd(); },
	  polygonStart: function() { this.stream.polygonStart(); },
	  polygonEnd: function() { this.stream.polygonEnd(); }
	};

	function fit(projection, fitBounds, object) {
	  var clip = projection.clipExtent && projection.clipExtent();
	  projection.scale(150).translate([0, 0]);
	  if (clip != null) projection.clipExtent(null);
	  geoStream(object, projection.stream(boundsStream$1));
	  fitBounds(boundsStream$1.result());
	  if (clip != null) projection.clipExtent(clip);
	  return projection;
	}

	function fitExtent(projection, extent, object) {
	  return fit(projection, function(b) {
	    var w = extent[1][0] - extent[0][0],
	        h = extent[1][1] - extent[0][1],
	        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
	        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
	        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	function fitSize(projection, size, object) {
	  return fitExtent(projection, [[0, 0], size], object);
	}

	function fitWidth(projection, width, object) {
	  return fit(projection, function(b) {
	    var w = +width,
	        k = w / (b[1][0] - b[0][0]),
	        x = (w - k * (b[1][0] + b[0][0])) / 2,
	        y = -k * b[0][1];
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	function fitHeight(projection, height, object) {
	  return fit(projection, function(b) {
	    var h = +height,
	        k = h / (b[1][1] - b[0][1]),
	        x = -k * b[0][0],
	        y = (h - k * (b[1][1] + b[0][1])) / 2;
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	var maxDepth = 16, // maximum depth of subdivision
	    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

	function resample(project, delta2) {
	  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
	}

	function resampleNone(project) {
	  return transformer({
	    point: function(x, y) {
	      x = project(x, y);
	      this.stream.point(x[0], x[1]);
	    }
	  });
	}

	function resample$1(project, delta2) {

	  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
	    var dx = x1 - x0,
	        dy = y1 - y0,
	        d2 = dx * dx + dy * dy;
	    if (d2 > 4 * delta2 && depth--) {
	      var a = a0 + a1,
	          b = b0 + b1,
	          c = c0 + c1,
	          m = sqrt(a * a + b * b + c * c),
	          phi2 = asin(c /= m),
	          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
	          p = project(lambda2, phi2),
	          x2 = p[0],
	          y2 = p[1],
	          dx2 = x2 - x0,
	          dy2 = y2 - y0,
	          dz = dy * dx2 - dx * dy2;
	      if (dz * dz / d2 > delta2 // perpendicular projected distance
	          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
	          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
	        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
	        stream.point(x2, y2);
	        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
	      }
	    }
	  }
	  return function(stream) {
	    var lambda00, x00, y00, a00, b00, c00, // first point
	        lambda0, x0, y0, a0, b0, c0; // previous point

	    var resampleStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
	      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
	    };

	    function point(x, y) {
	      x = project(x, y);
	      stream.point(x[0], x[1]);
	    }

	    function lineStart() {
	      x0 = NaN;
	      resampleStream.point = linePoint;
	      stream.lineStart();
	    }

	    function linePoint(lambda, phi) {
	      var c = cartesian([lambda, phi]), p = project(lambda, phi);
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	      stream.point(x0, y0);
	    }

	    function lineEnd() {
	      resampleStream.point = point;
	      stream.lineEnd();
	    }

	    function ringStart() {
	      lineStart();
	      resampleStream.point = ringPoint;
	      resampleStream.lineEnd = ringEnd;
	    }

	    function ringPoint(lambda, phi) {
	      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	      resampleStream.point = linePoint;
	    }

	    function ringEnd() {
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
	      resampleStream.lineEnd = lineEnd;
	      lineEnd();
	    }

	    return resampleStream;
	  };
	}

	var transformRadians = transformer({
	  point: function(x, y) {
	    this.stream.point(x * radians, y * radians);
	  }
	});

	function transformRotate(rotate) {
	  return transformer({
	    point: function(x, y) {
	      var r = rotate(x, y);
	      return this.stream.point(r[0], r[1]);
	    }
	  });
	}

	function scaleTranslate(k, dx, dy, sx, sy) {
	  function transform(x, y) {
	    x *= sx; y *= sy;
	    return [dx + k * x, dy - k * y];
	  }
	  transform.invert = function(x, y) {
	    return [(x - dx) / k * sx, (dy - y) / k * sy];
	  };
	  return transform;
	}

	function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
	  var cosAlpha = cos(alpha),
	      sinAlpha = sin(alpha),
	      a = cosAlpha * k,
	      b = sinAlpha * k,
	      ai = cosAlpha / k,
	      bi = sinAlpha / k,
	      ci = (sinAlpha * dy - cosAlpha * dx) / k,
	      fi = (sinAlpha * dx + cosAlpha * dy) / k;
	  function transform(x, y) {
	    x *= sx; y *= sy;
	    return [a * x - b * y + dx, dy - b * x - a * y];
	  }
	  transform.invert = function(x, y) {
	    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
	  };
	  return transform;
	}

	function projection(project) {
	  return projectionMutator(function() { return project; })();
	}

	function projectionMutator(projectAt) {
	  var project,
	      k = 150, // scale
	      x = 480, y = 250, // translate
	      lambda = 0, phi = 0, // center
	      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
	      alpha = 0, // post-rotate angle
	      sx = 1, // reflectX
	      sy = 1, // reflectX
	      theta = null, preclip = clipAntimeridian, // pre-clip angle
	      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
	      delta2 = 0.5, // precision
	      projectResample,
	      projectTransform,
	      projectRotateTransform,
	      cache,
	      cacheStream;

	  function projection(point) {
	    return projectRotateTransform(point[0] * radians, point[1] * radians);
	  }

	  function invert(point) {
	    point = projectRotateTransform.invert(point[0], point[1]);
	    return point && [point[0] * degrees, point[1] * degrees];
	  }

	  projection.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
	  };

	  projection.preclip = function(_) {
	    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
	  };

	  projection.postclip = function(_) {
	    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	  };

	  projection.clipAngle = function(_) {
	    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
	  };

	  projection.clipExtent = function(_) {
	    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  projection.scale = function(_) {
	    return arguments.length ? (k = +_, recenter()) : k;
	  };

	  projection.translate = function(_) {
	    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
	  };

	  projection.center = function(_) {
	    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
	  };

	  projection.rotate = function(_) {
	    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
	  };

	  projection.angle = function(_) {
	    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
	  };

	  projection.reflectX = function(_) {
	    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
	  };

	  projection.reflectY = function(_) {
	    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
	  };

	  projection.precision = function(_) {
	    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
	  };

	  projection.fitExtent = function(extent, object) {
	    return fitExtent(projection, extent, object);
	  };

	  projection.fitSize = function(size, object) {
	    return fitSize(projection, size, object);
	  };

	  projection.fitWidth = function(width, object) {
	    return fitWidth(projection, width, object);
	  };

	  projection.fitHeight = function(height, object) {
	    return fitHeight(projection, height, object);
	  };

	  function recenter() {
	    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
	        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
	    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
	    projectTransform = compose(project, transform);
	    projectRotateTransform = compose(rotate, projectTransform);
	    projectResample = resample(projectTransform, delta2);
	    return reset();
	  }

	  function reset() {
	    cache = cacheStream = null;
	    return projection;
	  }

	  return function() {
	    project = projectAt.apply(this, arguments);
	    projection.invert = project.invert && invert;
	    return recenter();
	  };
	}

	function conicProjection(projectAt) {
	  var phi0 = 0,
	      phi1 = pi / 3,
	      m = projectionMutator(projectAt),
	      p = m(phi0, phi1);

	  p.parallels = function(_) {
	    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
	  };

	  return p;
	}

	function cylindricalEqualAreaRaw(phi0) {
	  var cosPhi0 = cos(phi0);

	  function forward(lambda, phi) {
	    return [lambda * cosPhi0, sin(phi) / cosPhi0];
	  }

	  forward.invert = function(x, y) {
	    return [x / cosPhi0, asin(y * cosPhi0)];
	  };

	  return forward;
	}

	function conicEqualAreaRaw(y0, y1) {
	  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

	  // Are the parallels symmetrical around the Equator?
	  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

	  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

	  function project(x, y) {
	    var r = sqrt(c - 2 * n * sin(y)) / n;
	    return [r * sin(x *= n), r0 - r * cos(x)];
	  }

	  project.invert = function(x, y) {
	    var r0y = r0 - y,
	        l = atan2(x, abs(r0y)) * sign(r0y);
	    if (r0y * n < 0)
	      l -= pi * sign(x) * sign(r0y);
	    return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
	  };

	  return project;
	}

	function conicEqualArea() {
	  return conicProjection(conicEqualAreaRaw)
	      .scale(155.424)
	      .center([0, 33.6442]);
	}

	function albers() {
	  return conicEqualArea()
	      .parallels([29.5, 45.5])
	      .scale(1070)
	      .translate([480, 250])
	      .rotate([96, 0])
	      .center([-0.6, 38.7]);
	}

	// The projections must have mutually exclusive clip regions on the sphere,
	// as this will avoid emitting interleaving lines and polygons.
	function multiplex(streams) {
	  var n = streams.length;
	  return {
	    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
	    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
	    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
	    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
	    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
	    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
	  };
	}

	// A composite projection for the United States, configured by default for
	// 960×500. The projection also works quite well at 960×600 if you change the
	// scale to 1285 and adjust the translate accordingly. The set of standard
	// parallels for each region comes from USGS, which is published here:
	// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
	function albersUsa() {
	  var cache,
	      cacheStream,
	      lower48 = albers(), lower48Point,
	      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
	      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
	      point, pointStream = {point: function(x, y) { point = [x, y]; }};

	  function albersUsa(coordinates) {
	    var x = coordinates[0], y = coordinates[1];
	    return point = null,
	        (lower48Point.point(x, y), point)
	        || (alaskaPoint.point(x, y), point)
	        || (hawaiiPoint.point(x, y), point);
	  }

	  albersUsa.invert = function(coordinates) {
	    var k = lower48.scale(),
	        t = lower48.translate(),
	        x = (coordinates[0] - t[0]) / k,
	        y = (coordinates[1] - t[1]) / k;
	    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
	        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
	        : lower48).invert(coordinates);
	  };

	  albersUsa.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
	  };

	  albersUsa.precision = function(_) {
	    if (!arguments.length) return lower48.precision();
	    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
	    return reset();
	  };

	  albersUsa.scale = function(_) {
	    if (!arguments.length) return lower48.scale();
	    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
	    return albersUsa.translate(lower48.translate());
	  };

	  albersUsa.translate = function(_) {
	    if (!arguments.length) return lower48.translate();
	    var k = lower48.scale(), x = +_[0], y = +_[1];

	    lower48Point = lower48
	        .translate(_)
	        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
	        .stream(pointStream);

	    alaskaPoint = alaska
	        .translate([x - 0.307 * k, y + 0.201 * k])
	        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    hawaiiPoint = hawaii
	        .translate([x - 0.205 * k, y + 0.212 * k])
	        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    return reset();
	  };

	  albersUsa.fitExtent = function(extent, object) {
	    return fitExtent(albersUsa, extent, object);
	  };

	  albersUsa.fitSize = function(size, object) {
	    return fitSize(albersUsa, size, object);
	  };

	  albersUsa.fitWidth = function(width, object) {
	    return fitWidth(albersUsa, width, object);
	  };

	  albersUsa.fitHeight = function(height, object) {
	    return fitHeight(albersUsa, height, object);
	  };

	  function reset() {
	    cache = cacheStream = null;
	    return albersUsa;
	  }

	  return albersUsa.scale(1070);
	}

	function azimuthalRaw(scale) {
	  return function(x, y) {
	    var cx = cos(x),
	        cy = cos(y),
	        k = scale(cx * cy);
	    return [
	      k * cy * sin(x),
	      k * sin(y)
	    ];
	  }
	}

	function azimuthalInvert(angle) {
	  return function(x, y) {
	    var z = sqrt(x * x + y * y),
	        c = angle(z),
	        sc = sin(c),
	        cc = cos(c);
	    return [
	      atan2(x * sc, z * cc),
	      asin(z && y * sc / z)
	    ];
	  }
	}

	var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
	  return sqrt(2 / (1 + cxcy));
	});

	azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
	  return 2 * asin(z / 2);
	});

	function azimuthalEqualArea() {
	  return projection(azimuthalEqualAreaRaw)
	      .scale(124.75)
	      .clipAngle(180 - 1e-3);
	}

	var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
	  return (c = acos(c)) && c / sin(c);
	});

	azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
	  return z;
	});

	function azimuthalEquidistant() {
	  return projection(azimuthalEquidistantRaw)
	      .scale(79.4188)
	      .clipAngle(180 - 1e-3);
	}

	function mercatorRaw(lambda, phi) {
	  return [lambda, log(tan((halfPi + phi) / 2))];
	}

	mercatorRaw.invert = function(x, y) {
	  return [x, 2 * atan(exp(y)) - halfPi];
	};

	function mercator() {
	  return mercatorProjection(mercatorRaw)
	      .scale(961 / tau);
	}

	function mercatorProjection(project) {
	  var m = projection(project),
	      center = m.center,
	      scale = m.scale,
	      translate = m.translate,
	      clipExtent = m.clipExtent,
	      x0 = null, y0, x1, y1; // clip extent

	  m.scale = function(_) {
	    return arguments.length ? (scale(_), reclip()) : scale();
	  };

	  m.translate = function(_) {
	    return arguments.length ? (translate(_), reclip()) : translate();
	  };

	  m.center = function(_) {
	    return arguments.length ? (center(_), reclip()) : center();
	  };

	  m.clipExtent = function(_) {
	    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  function reclip() {
	    var k = pi * scale(),
	        t = m(rotation(m.rotate()).invert([0, 0]));
	    return clipExtent(x0 == null
	        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
	        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
	        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
	  }

	  return reclip();
	}

	function tany(y) {
	  return tan((halfPi + y) / 2);
	}

	function conicConformalRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
	      f = cy0 * pow(tany(y0), n) / n;

	  if (!n) return mercatorRaw;

	  function project(x, y) {
	    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
	    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
	    var r = f / pow(tany(y), n);
	    return [r * sin(n * x), f - r * cos(n * x)];
	  }

	  project.invert = function(x, y) {
	    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy),
	      l = atan2(x, abs(fy)) * sign(fy);
	    if (fy * n < 0)
	      l -= pi * sign(x) * sign(fy);
	    return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
	  };

	  return project;
	}

	function conicConformal() {
	  return conicProjection(conicConformalRaw)
	      .scale(109.5)
	      .parallels([30, 30]);
	}

	function equirectangularRaw(lambda, phi) {
	  return [lambda, phi];
	}

	equirectangularRaw.invert = equirectangularRaw;

	function equirectangular() {
	  return projection(equirectangularRaw)
	      .scale(152.63);
	}

	function conicEquidistantRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
	      g = cy0 / n + y0;

	  if (abs(n) < epsilon) return equirectangularRaw;

	  function project(x, y) {
	    var gy = g - y, nx = n * x;
	    return [gy * sin(nx), g - gy * cos(nx)];
	  }

	  project.invert = function(x, y) {
	    var gy = g - y,
	        l = atan2(x, abs(gy)) * sign(gy);
	    if (gy * n < 0)
	      l -= pi * sign(x) * sign(gy);
	    return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
	  };

	  return project;
	}

	function conicEquidistant() {
	  return conicProjection(conicEquidistantRaw)
	      .scale(131.154)
	      .center([0, 13.9389]);
	}

	var A1 = 1.340264,
	    A2 = -0.081106,
	    A3 = 0.000893,
	    A4 = 0.003796,
	    M = sqrt(3) / 2,
	    iterations = 12;

	function equalEarthRaw(lambda, phi) {
	  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
	  return [
	    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
	    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
	  ];
	}

	equalEarthRaw.invert = function(x, y) {
	  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
	  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
	    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
	    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
	    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
	    if (abs(delta) < epsilon2) break;
	  }
	  return [
	    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
	    asin(sin(l) / M)
	  ];
	};

	function equalEarth() {
	  return projection(equalEarthRaw)
	      .scale(177.158);
	}

	function gnomonicRaw(x, y) {
	  var cy = cos(y), k = cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	gnomonicRaw.invert = azimuthalInvert(atan);

	function gnomonic() {
	  return projection(gnomonicRaw)
	      .scale(144.049)
	      .clipAngle(60);
	}

	function identity$1() {
	  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
	      alpha = 0, ca, sa, // angle
	      x0 = null, y0, x1, y1, // clip extent
	      kx = 1, ky = 1,
	      transform = transformer({
	        point: function(x, y) {
	          var p = projection([x, y]);
	          this.stream.point(p[0], p[1]);
	        }
	      }),
	      postclip = identity,
	      cache,
	      cacheStream;

	  function reset() {
	    kx = k * sx;
	    ky = k * sy;
	    cache = cacheStream = null;
	    return projection;
	  }

	  function projection (p) {
	    var x = p[0] * kx, y = p[1] * ky;
	    if (alpha) {
	      var t = y * ca - x * sa;
	      x = x * ca + y * sa;
	      y = t;
	    }    
	    return [x + tx, y + ty];
	  }
	  projection.invert = function(p) {
	    var x = p[0] - tx, y = p[1] - ty;
	    if (alpha) {
	      var t = y * ca + x * sa;
	      x = x * ca - y * sa;
	      y = t;
	    }
	    return [x / kx, y / ky];
	  };
	  projection.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
	  };
	  projection.postclip = function(_) {
	    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	  };
	  projection.clipExtent = function(_) {
	    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };
	  projection.scale = function(_) {
	    return arguments.length ? (k = +_, reset()) : k;
	  };
	  projection.translate = function(_) {
	    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
	  };
	  projection.angle = function(_) {
	    return arguments.length ? (alpha = _ % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
	  };
	  projection.reflectX = function(_) {
	    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
	  };
	  projection.reflectY = function(_) {
	    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
	  };
	  projection.fitExtent = function(extent, object) {
	    return fitExtent(projection, extent, object);
	  };
	  projection.fitSize = function(size, object) {
	    return fitSize(projection, size, object);
	  };
	  projection.fitWidth = function(width, object) {
	    return fitWidth(projection, width, object);
	  };
	  projection.fitHeight = function(height, object) {
	    return fitHeight(projection, height, object);
	  };

	  return projection;
	}

	function naturalEarth1Raw(lambda, phi) {
	  var phi2 = phi * phi, phi4 = phi2 * phi2;
	  return [
	    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
	    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
	  ];
	}

	naturalEarth1Raw.invert = function(x, y) {
	  var phi = y, i = 25, delta;
	  do {
	    var phi2 = phi * phi, phi4 = phi2 * phi2;
	    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
	        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
	  } while (abs(delta) > epsilon && --i > 0);
	  return [
	    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
	    phi
	  ];
	};

	function naturalEarth1() {
	  return projection(naturalEarth1Raw)
	      .scale(175.295);
	}

	function orthographicRaw(x, y) {
	  return [cos(y) * sin(x), sin(y)];
	}

	orthographicRaw.invert = azimuthalInvert(asin);

	function orthographic() {
	  return projection(orthographicRaw)
	      .scale(249.5)
	      .clipAngle(90 + epsilon);
	}

	function stereographicRaw(x, y) {
	  var cy = cos(y), k = 1 + cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	stereographicRaw.invert = azimuthalInvert(function(z) {
	  return 2 * atan(z);
	});

	function stereographic() {
	  return projection(stereographicRaw)
	      .scale(250)
	      .clipAngle(142);
	}

	function transverseMercatorRaw(lambda, phi) {
	  return [log(tan((halfPi + phi) / 2)), -lambda];
	}

	transverseMercatorRaw.invert = function(x, y) {
	  return [-y, 2 * atan(exp(x)) - halfPi];
	};

	function transverseMercator() {
	  var m = mercatorProjection(transverseMercatorRaw),
	      center = m.center,
	      rotate = m.rotate;

	  m.center = function(_) {
	    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
	  };

	  m.rotate = function(_) {
	    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
	  };

	  return rotate([0, 0, 90])
	      .scale(159.155);
	}

	exports.geoAlbers = albers;
	exports.geoAlbersUsa = albersUsa;
	exports.geoArea = area;
	exports.geoAzimuthalEqualArea = azimuthalEqualArea;
	exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
	exports.geoAzimuthalEquidistant = azimuthalEquidistant;
	exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
	exports.geoBounds = bounds;
	exports.geoCentroid = centroid;
	exports.geoCircle = circle;
	exports.geoClipAntimeridian = clipAntimeridian;
	exports.geoClipCircle = clipCircle;
	exports.geoClipExtent = extent;
	exports.geoClipRectangle = clipRectangle;
	exports.geoConicConformal = conicConformal;
	exports.geoConicConformalRaw = conicConformalRaw;
	exports.geoConicEqualArea = conicEqualArea;
	exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
	exports.geoConicEquidistant = conicEquidistant;
	exports.geoConicEquidistantRaw = conicEquidistantRaw;
	exports.geoContains = contains;
	exports.geoDistance = distance;
	exports.geoEqualEarth = equalEarth;
	exports.geoEqualEarthRaw = equalEarthRaw;
	exports.geoEquirectangular = equirectangular;
	exports.geoEquirectangularRaw = equirectangularRaw;
	exports.geoGnomonic = gnomonic;
	exports.geoGnomonicRaw = gnomonicRaw;
	exports.geoGraticule = graticule;
	exports.geoGraticule10 = graticule10;
	exports.geoIdentity = identity$1;
	exports.geoInterpolate = interpolate;
	exports.geoLength = length;
	exports.geoMercator = mercator;
	exports.geoMercatorRaw = mercatorRaw;
	exports.geoNaturalEarth1 = naturalEarth1;
	exports.geoNaturalEarth1Raw = naturalEarth1Raw;
	exports.geoOrthographic = orthographic;
	exports.geoOrthographicRaw = orthographicRaw;
	exports.geoPath = index;
	exports.geoProjection = projection;
	exports.geoProjectionMutator = projectionMutator;
	exports.geoRotation = rotation;
	exports.geoStereographic = stereographic;
	exports.geoStereographicRaw = stereographicRaw;
	exports.geoStream = geoStream;
	exports.geoTransform = transform;
	exports.geoTransverseMercator = transverseMercator;
	exports.geoTransverseMercatorRaw = transverseMercatorRaw;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-hierarchy/ v1.1.9 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function defaultSeparation(a, b) {
	  return a.parent === b.parent ? 1 : 2;
	}

	function meanX(children) {
	  return children.reduce(meanXReduce, 0) / children.length;
	}

	function meanXReduce(x, c) {
	  return x + c.x;
	}

	function maxY(children) {
	  return 1 + children.reduce(maxYReduce, 0);
	}

	function maxYReduce(y, c) {
	  return Math.max(y, c.y);
	}

	function leafLeft(node) {
	  var children;
	  while (children = node.children) node = children[0];
	  return node;
	}

	function leafRight(node) {
	  var children;
	  while (children = node.children) node = children[children.length - 1];
	  return node;
	}

	function cluster() {
	  var separation = defaultSeparation,
	      dx = 1,
	      dy = 1,
	      nodeSize = false;

	  function cluster(root) {
	    var previousNode,
	        x = 0;

	    // First walk, computing the initial x & y values.
	    root.eachAfter(function(node) {
	      var children = node.children;
	      if (children) {
	        node.x = meanX(children);
	        node.y = maxY(children);
	      } else {
	        node.x = previousNode ? x += separation(node, previousNode) : 0;
	        node.y = 0;
	        previousNode = node;
	      }
	    });

	    var left = leafLeft(root),
	        right = leafRight(root),
	        x0 = left.x - separation(left, right) / 2,
	        x1 = right.x + separation(right, left) / 2;

	    // Second walk, normalizing x & y to the desired size.
	    return root.eachAfter(nodeSize ? function(node) {
	      node.x = (node.x - root.x) * dx;
	      node.y = (root.y - node.y) * dy;
	    } : function(node) {
	      node.x = (node.x - x0) / (x1 - x0) * dx;
	      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
	    });
	  }

	  cluster.separation = function(x) {
	    return arguments.length ? (separation = x, cluster) : separation;
	  };

	  cluster.size = function(x) {
	    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
	  };

	  cluster.nodeSize = function(x) {
	    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
	  };

	  return cluster;
	}

	function count(node) {
	  var sum = 0,
	      children = node.children,
	      i = children && children.length;
	  if (!i) sum = 1;
	  else while (--i >= 0) sum += children[i].value;
	  node.value = sum;
	}

	function node_count() {
	  return this.eachAfter(count);
	}

	function node_each(callback) {
	  var node = this, current, next = [node], children, i, n;
	  do {
	    current = next.reverse(), next = [];
	    while (node = current.pop()) {
	      callback(node), children = node.children;
	      if (children) for (i = 0, n = children.length; i < n; ++i) {
	        next.push(children[i]);
	      }
	    }
	  } while (next.length);
	  return this;
	}

	function node_eachBefore(callback) {
	  var node = this, nodes = [node], children, i;
	  while (node = nodes.pop()) {
	    callback(node), children = node.children;
	    if (children) for (i = children.length - 1; i >= 0; --i) {
	      nodes.push(children[i]);
	    }
	  }
	  return this;
	}

	function node_eachAfter(callback) {
	  var node = this, nodes = [node], next = [], children, i, n;
	  while (node = nodes.pop()) {
	    next.push(node), children = node.children;
	    if (children) for (i = 0, n = children.length; i < n; ++i) {
	      nodes.push(children[i]);
	    }
	  }
	  while (node = next.pop()) {
	    callback(node);
	  }
	  return this;
	}

	function node_sum(value) {
	  return this.eachAfter(function(node) {
	    var sum = +value(node.data) || 0,
	        children = node.children,
	        i = children && children.length;
	    while (--i >= 0) sum += children[i].value;
	    node.value = sum;
	  });
	}

	function node_sort(compare) {
	  return this.eachBefore(function(node) {
	    if (node.children) {
	      node.children.sort(compare);
	    }
	  });
	}

	function node_path(end) {
	  var start = this,
	      ancestor = leastCommonAncestor(start, end),
	      nodes = [start];
	  while (start !== ancestor) {
	    start = start.parent;
	    nodes.push(start);
	  }
	  var k = nodes.length;
	  while (end !== ancestor) {
	    nodes.splice(k, 0, end);
	    end = end.parent;
	  }
	  return nodes;
	}

	function leastCommonAncestor(a, b) {
	  if (a === b) return a;
	  var aNodes = a.ancestors(),
	      bNodes = b.ancestors(),
	      c = null;
	  a = aNodes.pop();
	  b = bNodes.pop();
	  while (a === b) {
	    c = a;
	    a = aNodes.pop();
	    b = bNodes.pop();
	  }
	  return c;
	}

	function node_ancestors() {
	  var node = this, nodes = [node];
	  while (node = node.parent) {
	    nodes.push(node);
	  }
	  return nodes;
	}

	function node_descendants() {
	  var nodes = [];
	  this.each(function(node) {
	    nodes.push(node);
	  });
	  return nodes;
	}

	function node_leaves() {
	  var leaves = [];
	  this.eachBefore(function(node) {
	    if (!node.children) {
	      leaves.push(node);
	    }
	  });
	  return leaves;
	}

	function node_links() {
	  var root = this, links = [];
	  root.each(function(node) {
	    if (node !== root) { // Don’t include the root’s parent, if any.
	      links.push({source: node.parent, target: node});
	    }
	  });
	  return links;
	}

	function hierarchy(data, children) {
	  var root = new Node(data),
	      valued = +data.value && (root.value = data.value),
	      node,
	      nodes = [root],
	      child,
	      childs,
	      i,
	      n;

	  if (children == null) children = defaultChildren;

	  while (node = nodes.pop()) {
	    if (valued) node.value = +node.data.value;
	    if ((childs = children(node.data)) && (n = childs.length)) {
	      node.children = new Array(n);
	      for (i = n - 1; i >= 0; --i) {
	        nodes.push(child = node.children[i] = new Node(childs[i]));
	        child.parent = node;
	        child.depth = node.depth + 1;
	      }
	    }
	  }

	  return root.eachBefore(computeHeight);
	}

	function node_copy() {
	  return hierarchy(this).eachBefore(copyData);
	}

	function defaultChildren(d) {
	  return d.children;
	}

	function copyData(node) {
	  node.data = node.data.data;
	}

	function computeHeight(node) {
	  var height = 0;
	  do node.height = height;
	  while ((node = node.parent) && (node.height < ++height));
	}

	function Node(data) {
	  this.data = data;
	  this.depth =
	  this.height = 0;
	  this.parent = null;
	}

	Node.prototype = hierarchy.prototype = {
	  constructor: Node,
	  count: node_count,
	  each: node_each,
	  eachAfter: node_eachAfter,
	  eachBefore: node_eachBefore,
	  sum: node_sum,
	  sort: node_sort,
	  path: node_path,
	  ancestors: node_ancestors,
	  descendants: node_descendants,
	  leaves: node_leaves,
	  links: node_links,
	  copy: node_copy
	};

	var slice = Array.prototype.slice;

	function shuffle(array) {
	  var m = array.length,
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m];
	    array[m] = array[i];
	    array[i] = t;
	  }

	  return array;
	}

	function enclose(circles) {
	  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

	  while (i < n) {
	    p = circles[i];
	    if (e && enclosesWeak(e, p)) ++i;
	    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
	  }

	  return e;
	}

	function extendBasis(B, p) {
	  var i, j;

	  if (enclosesWeakAll(p, B)) return [p];

	  // If we get here then B must have at least one element.
	  for (i = 0; i < B.length; ++i) {
	    if (enclosesNot(p, B[i])
	        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
	      return [B[i], p];
	    }
	  }

	  // If we get here then B must have at least two elements.
	  for (i = 0; i < B.length - 1; ++i) {
	    for (j = i + 1; j < B.length; ++j) {
	      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
	          && enclosesNot(encloseBasis2(B[i], p), B[j])
	          && enclosesNot(encloseBasis2(B[j], p), B[i])
	          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
	        return [B[i], B[j], p];
	      }
	    }
	  }

	  // If we get here then something is very wrong.
	  throw new Error;
	}

	function enclosesNot(a, b) {
	  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
	  return dr < 0 || dr * dr < dx * dx + dy * dy;
	}

	function enclosesWeak(a, b) {
	  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	  return dr > 0 && dr * dr > dx * dx + dy * dy;
	}

	function enclosesWeakAll(a, B) {
	  for (var i = 0; i < B.length; ++i) {
	    if (!enclosesWeak(a, B[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	function encloseBasis(B) {
	  switch (B.length) {
	    case 1: return encloseBasis1(B[0]);
	    case 2: return encloseBasis2(B[0], B[1]);
	    case 3: return encloseBasis3(B[0], B[1], B[2]);
	  }
	}

	function encloseBasis1(a) {
	  return {
	    x: a.x,
	    y: a.y,
	    r: a.r
	  };
	}

	function encloseBasis2(a, b) {
	  var x1 = a.x, y1 = a.y, r1 = a.r,
	      x2 = b.x, y2 = b.y, r2 = b.r,
	      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
	      l = Math.sqrt(x21 * x21 + y21 * y21);
	  return {
	    x: (x1 + x2 + x21 / l * r21) / 2,
	    y: (y1 + y2 + y21 / l * r21) / 2,
	    r: (l + r1 + r2) / 2
	  };
	}

	function encloseBasis3(a, b, c) {
	  var x1 = a.x, y1 = a.y, r1 = a.r,
	      x2 = b.x, y2 = b.y, r2 = b.r,
	      x3 = c.x, y3 = c.y, r3 = c.r,
	      a2 = x1 - x2,
	      a3 = x1 - x3,
	      b2 = y1 - y2,
	      b3 = y1 - y3,
	      c2 = r2 - r1,
	      c3 = r3 - r1,
	      d1 = x1 * x1 + y1 * y1 - r1 * r1,
	      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
	      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
	      ab = a3 * b2 - a2 * b3,
	      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
	      xb = (b3 * c2 - b2 * c3) / ab,
	      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
	      yb = (a2 * c3 - a3 * c2) / ab,
	      A = xb * xb + yb * yb - 1,
	      B = 2 * (r1 + xa * xb + ya * yb),
	      C = xa * xa + ya * ya - r1 * r1,
	      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
	  return {
	    x: x1 + xa + xb * r,
	    y: y1 + ya + yb * r,
	    r: r
	  };
	}

	function place(b, a, c) {
	  var dx = b.x - a.x, x, a2,
	      dy = b.y - a.y, y, b2,
	      d2 = dx * dx + dy * dy;
	  if (d2) {
	    a2 = a.r + c.r, a2 *= a2;
	    b2 = b.r + c.r, b2 *= b2;
	    if (a2 > b2) {
	      x = (d2 + b2 - a2) / (2 * d2);
	      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
	      c.x = b.x - x * dx - y * dy;
	      c.y = b.y - x * dy + y * dx;
	    } else {
	      x = (d2 + a2 - b2) / (2 * d2);
	      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
	      c.x = a.x + x * dx - y * dy;
	      c.y = a.y + x * dy + y * dx;
	    }
	  } else {
	    c.x = a.x + c.r;
	    c.y = a.y;
	  }
	}

	function intersects(a, b) {
	  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	  return dr > 0 && dr * dr > dx * dx + dy * dy;
	}

	function score(node) {
	  var a = node._,
	      b = node.next._,
	      ab = a.r + b.r,
	      dx = (a.x * b.r + b.x * a.r) / ab,
	      dy = (a.y * b.r + b.y * a.r) / ab;
	  return dx * dx + dy * dy;
	}

	function Node$1(circle) {
	  this._ = circle;
	  this.next = null;
	  this.previous = null;
	}

	function packEnclose(circles) {
	  if (!(n = circles.length)) return 0;

	  var a, b, c, n, aa, ca, i, j, k, sj, sk;

	  // Place the first circle.
	  a = circles[0], a.x = 0, a.y = 0;
	  if (!(n > 1)) return a.r;

	  // Place the second circle.
	  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
	  if (!(n > 2)) return a.r + b.r;

	  // Place the third circle.
	  place(b, a, c = circles[2]);

	  // Initialize the front-chain using the first three circles a, b and c.
	  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
	  a.next = c.previous = b;
	  b.next = a.previous = c;
	  c.next = b.previous = a;

	  // Attempt to place each remaining circle…
	  pack: for (i = 3; i < n; ++i) {
	    place(a._, b._, c = circles[i]), c = new Node$1(c);

	    // Find the closest intersecting circle on the front-chain, if any.
	    // “Closeness” is determined by linear distance along the front-chain.
	    // “Ahead” or “behind” is likewise determined by linear distance.
	    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
	    do {
	      if (sj <= sk) {
	        if (intersects(j._, c._)) {
	          b = j, a.next = b, b.previous = a, --i;
	          continue pack;
	        }
	        sj += j._.r, j = j.next;
	      } else {
	        if (intersects(k._, c._)) {
	          a = k, a.next = b, b.previous = a, --i;
	          continue pack;
	        }
	        sk += k._.r, k = k.previous;
	      }
	    } while (j !== k.next);

	    // Success! Insert the new circle c between a and b.
	    c.previous = a, c.next = b, a.next = b.previous = b = c;

	    // Compute the new closest circle pair to the centroid.
	    aa = score(a);
	    while ((c = c.next) !== b) {
	      if ((ca = score(c)) < aa) {
	        a = c, aa = ca;
	      }
	    }
	    b = a.next;
	  }

	  // Compute the enclosing circle of the front chain.
	  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

	  // Translate the circles to put the enclosing circle around the origin.
	  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

	  return c.r;
	}

	function siblings(circles) {
	  packEnclose(circles);
	  return circles;
	}

	function optional(f) {
	  return f == null ? null : required(f);
	}

	function required(f) {
	  if (typeof f !== "function") throw new Error;
	  return f;
	}

	function constantZero() {
	  return 0;
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function defaultRadius(d) {
	  return Math.sqrt(d.value);
	}

	function index() {
	  var radius = null,
	      dx = 1,
	      dy = 1,
	      padding = constantZero;

	  function pack(root) {
	    root.x = dx / 2, root.y = dy / 2;
	    if (radius) {
	      root.eachBefore(radiusLeaf(radius))
	          .eachAfter(packChildren(padding, 0.5))
	          .eachBefore(translateChild(1));
	    } else {
	      root.eachBefore(radiusLeaf(defaultRadius))
	          .eachAfter(packChildren(constantZero, 1))
	          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
	          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
	    }
	    return root;
	  }

	  pack.radius = function(x) {
	    return arguments.length ? (radius = optional(x), pack) : radius;
	  };

	  pack.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
	  };

	  pack.padding = function(x) {
	    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
	  };

	  return pack;
	}

	function radiusLeaf(radius) {
	  return function(node) {
	    if (!node.children) {
	      node.r = Math.max(0, +radius(node) || 0);
	    }
	  };
	}

	function packChildren(padding, k) {
	  return function(node) {
	    if (children = node.children) {
	      var children,
	          i,
	          n = children.length,
	          r = padding(node) * k || 0,
	          e;

	      if (r) for (i = 0; i < n; ++i) children[i].r += r;
	      e = packEnclose(children);
	      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
	      node.r = e + r;
	    }
	  };
	}

	function translateChild(k) {
	  return function(node) {
	    var parent = node.parent;
	    node.r *= k;
	    if (parent) {
	      node.x = parent.x + k * node.x;
	      node.y = parent.y + k * node.y;
	    }
	  };
	}

	function roundNode(node) {
	  node.x0 = Math.round(node.x0);
	  node.y0 = Math.round(node.y0);
	  node.x1 = Math.round(node.x1);
	  node.y1 = Math.round(node.y1);
	}

	function treemapDice(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      node,
	      i = -1,
	      n = nodes.length,
	      k = parent.value && (x1 - x0) / parent.value;

	  while (++i < n) {
	    node = nodes[i], node.y0 = y0, node.y1 = y1;
	    node.x0 = x0, node.x1 = x0 += node.value * k;
	  }
	}

	function partition() {
	  var dx = 1,
	      dy = 1,
	      padding = 0,
	      round = false;

	  function partition(root) {
	    var n = root.height + 1;
	    root.x0 =
	    root.y0 = padding;
	    root.x1 = dx;
	    root.y1 = dy / n;
	    root.eachBefore(positionNode(dy, n));
	    if (round) root.eachBefore(roundNode);
	    return root;
	  }

	  function positionNode(dy, n) {
	    return function(node) {
	      if (node.children) {
	        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
	      }
	      var x0 = node.x0,
	          y0 = node.y0,
	          x1 = node.x1 - padding,
	          y1 = node.y1 - padding;
	      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	      node.x0 = x0;
	      node.y0 = y0;
	      node.x1 = x1;
	      node.y1 = y1;
	    };
	  }

	  partition.round = function(x) {
	    return arguments.length ? (round = !!x, partition) : round;
	  };

	  partition.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
	  };

	  partition.padding = function(x) {
	    return arguments.length ? (padding = +x, partition) : padding;
	  };

	  return partition;
	}

	var keyPrefix = "$", // Protect against keys like “__proto__”.
	    preroot = {depth: -1},
	    ambiguous = {};

	function defaultId(d) {
	  return d.id;
	}

	function defaultParentId(d) {
	  return d.parentId;
	}

	function stratify() {
	  var id = defaultId,
	      parentId = defaultParentId;

	  function stratify(data) {
	    var d,
	        i,
	        n = data.length,
	        root,
	        parent,
	        node,
	        nodes = new Array(n),
	        nodeId,
	        nodeKey,
	        nodeByKey = {};

	    for (i = 0; i < n; ++i) {
	      d = data[i], node = nodes[i] = new Node(d);
	      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
	        nodeKey = keyPrefix + (node.id = nodeId);
	        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
	      }
	    }

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], nodeId = parentId(data[i], i, data);
	      if (nodeId == null || !(nodeId += "")) {
	        if (root) throw new Error("multiple roots");
	        root = node;
	      } else {
	        parent = nodeByKey[keyPrefix + nodeId];
	        if (!parent) throw new Error("missing: " + nodeId);
	        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
	        if (parent.children) parent.children.push(node);
	        else parent.children = [node];
	        node.parent = parent;
	      }
	    }

	    if (!root) throw new Error("no root");
	    root.parent = preroot;
	    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
	    root.parent = null;
	    if (n > 0) throw new Error("cycle");

	    return root;
	  }

	  stratify.id = function(x) {
	    return arguments.length ? (id = required(x), stratify) : id;
	  };

	  stratify.parentId = function(x) {
	    return arguments.length ? (parentId = required(x), stratify) : parentId;
	  };

	  return stratify;
	}

	function defaultSeparation$1(a, b) {
	  return a.parent === b.parent ? 1 : 2;
	}

	// function radialSeparation(a, b) {
	//   return (a.parent === b.parent ? 1 : 2) / a.depth;
	// }

	// This function is used to traverse the left contour of a subtree (or
	// subforest). It returns the successor of v on this contour. This successor is
	// either given by the leftmost child of v or by the thread of v. The function
	// returns null if and only if v is on the highest level of its subtree.
	function nextLeft(v) {
	  var children = v.children;
	  return children ? children[0] : v.t;
	}

	// This function works analogously to nextLeft.
	function nextRight(v) {
	  var children = v.children;
	  return children ? children[children.length - 1] : v.t;
	}

	// Shifts the current subtree rooted at w+. This is done by increasing
	// prelim(w+) and mod(w+) by shift.
	function moveSubtree(wm, wp, shift) {
	  var change = shift / (wp.i - wm.i);
	  wp.c -= change;
	  wp.s += shift;
	  wm.c += change;
	  wp.z += shift;
	  wp.m += shift;
	}

	// All other shifts, applied to the smaller subtrees between w- and w+, are
	// performed by this function. To prepare the shifts, we have to adjust
	// change(w+), shift(w+), and change(w-).
	function executeShifts(v) {
	  var shift = 0,
	      change = 0,
	      children = v.children,
	      i = children.length,
	      w;
	  while (--i >= 0) {
	    w = children[i];
	    w.z += shift;
	    w.m += shift;
	    shift += w.s + (change += w.c);
	  }
	}

	// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
	// returns the specified (default) ancestor.
	function nextAncestor(vim, v, ancestor) {
	  return vim.a.parent === v.parent ? vim.a : ancestor;
	}

	function TreeNode(node, i) {
	  this._ = node;
	  this.parent = null;
	  this.children = null;
	  this.A = null; // default ancestor
	  this.a = this; // ancestor
	  this.z = 0; // prelim
	  this.m = 0; // mod
	  this.c = 0; // change
	  this.s = 0; // shift
	  this.t = null; // thread
	  this.i = i; // number
	}

	TreeNode.prototype = Object.create(Node.prototype);

	function treeRoot(root) {
	  var tree = new TreeNode(root, 0),
	      node,
	      nodes = [tree],
	      child,
	      children,
	      i,
	      n;

	  while (node = nodes.pop()) {
	    if (children = node._.children) {
	      node.children = new Array(n = children.length);
	      for (i = n - 1; i >= 0; --i) {
	        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
	        child.parent = node;
	      }
	    }
	  }

	  (tree.parent = new TreeNode(null, 0)).children = [tree];
	  return tree;
	}

	// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
	function tree() {
	  var separation = defaultSeparation$1,
	      dx = 1,
	      dy = 1,
	      nodeSize = null;

	  function tree(root) {
	    var t = treeRoot(root);

	    // Compute the layout using Buchheim et al.’s algorithm.
	    t.eachAfter(firstWalk), t.parent.m = -t.z;
	    t.eachBefore(secondWalk);

	    // If a fixed node size is specified, scale x and y.
	    if (nodeSize) root.eachBefore(sizeNode);

	    // If a fixed tree size is specified, scale x and y based on the extent.
	    // Compute the left-most, right-most, and depth-most nodes for extents.
	    else {
	      var left = root,
	          right = root,
	          bottom = root;
	      root.eachBefore(function(node) {
	        if (node.x < left.x) left = node;
	        if (node.x > right.x) right = node;
	        if (node.depth > bottom.depth) bottom = node;
	      });
	      var s = left === right ? 1 : separation(left, right) / 2,
	          tx = s - left.x,
	          kx = dx / (right.x + s + tx),
	          ky = dy / (bottom.depth || 1);
	      root.eachBefore(function(node) {
	        node.x = (node.x + tx) * kx;
	        node.y = node.depth * ky;
	      });
	    }

	    return root;
	  }

	  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
	  // applied recursively to the children of v, as well as the function
	  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
	  // node v is placed to the midpoint of its outermost children.
	  function firstWalk(v) {
	    var children = v.children,
	        siblings = v.parent.children,
	        w = v.i ? siblings[v.i - 1] : null;
	    if (children) {
	      executeShifts(v);
	      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	      if (w) {
	        v.z = w.z + separation(v._, w._);
	        v.m = v.z - midpoint;
	      } else {
	        v.z = midpoint;
	      }
	    } else if (w) {
	      v.z = w.z + separation(v._, w._);
	    }
	    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	  }

	  // Computes all real x-coordinates by summing up the modifiers recursively.
	  function secondWalk(v) {
	    v._.x = v.z + v.parent.m;
	    v.m += v.parent.m;
	  }

	  // The core of the algorithm. Here, a new subtree is combined with the
	  // previous subtrees. Threads are used to traverse the inside and outside
	  // contours of the left and right subtree up to the highest common level. The
	  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
	  // superscript o means outside and i means inside, the subscript - means left
	  // subtree and + means right subtree. For summing up the modifiers along the
	  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
	  // nodes of the inside contours conflict, we compute the left one of the
	  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
	  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
	  // Finally, we add a new thread (if necessary).
	  function apportion(v, w, ancestor) {
	    if (w) {
	      var vip = v,
	          vop = v,
	          vim = w,
	          vom = vip.parent.children[0],
	          sip = vip.m,
	          sop = vop.m,
	          sim = vim.m,
	          som = vom.m,
	          shift;
	      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
	        vom = nextLeft(vom);
	        vop = nextRight(vop);
	        vop.a = v;
	        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	        if (shift > 0) {
	          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
	          sip += shift;
	          sop += shift;
	        }
	        sim += vim.m;
	        sip += vip.m;
	        som += vom.m;
	        sop += vop.m;
	      }
	      if (vim && !nextRight(vop)) {
	        vop.t = vim;
	        vop.m += sim - sop;
	      }
	      if (vip && !nextLeft(vom)) {
	        vom.t = vip;
	        vom.m += sip - som;
	        ancestor = v;
	      }
	    }
	    return ancestor;
	  }

	  function sizeNode(node) {
	    node.x *= dx;
	    node.y = node.depth * dy;
	  }

	  tree.separation = function(x) {
	    return arguments.length ? (separation = x, tree) : separation;
	  };

	  tree.size = function(x) {
	    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
	  };

	  tree.nodeSize = function(x) {
	    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
	  };

	  return tree;
	}

	function treemapSlice(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      node,
	      i = -1,
	      n = nodes.length,
	      k = parent.value && (y1 - y0) / parent.value;

	  while (++i < n) {
	    node = nodes[i], node.x0 = x0, node.x1 = x1;
	    node.y0 = y0, node.y1 = y0 += node.value * k;
	  }
	}

	var phi = (1 + Math.sqrt(5)) / 2;

	function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
	  var rows = [],
	      nodes = parent.children,
	      row,
	      nodeValue,
	      i0 = 0,
	      i1 = 0,
	      n = nodes.length,
	      dx, dy,
	      value = parent.value,
	      sumValue,
	      minValue,
	      maxValue,
	      newRatio,
	      minRatio,
	      alpha,
	      beta;

	  while (i0 < n) {
	    dx = x1 - x0, dy = y1 - y0;

	    // Find the next non-empty node.
	    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
	    minValue = maxValue = sumValue;
	    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
	    beta = sumValue * sumValue * alpha;
	    minRatio = Math.max(maxValue / beta, beta / minValue);

	    // Keep adding nodes while the aspect ratio maintains or improves.
	    for (; i1 < n; ++i1) {
	      sumValue += nodeValue = nodes[i1].value;
	      if (nodeValue < minValue) minValue = nodeValue;
	      if (nodeValue > maxValue) maxValue = nodeValue;
	      beta = sumValue * sumValue * alpha;
	      newRatio = Math.max(maxValue / beta, beta / minValue);
	      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
	      minRatio = newRatio;
	    }

	    // Position and record the row orientation.
	    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
	    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
	    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
	    value -= sumValue, i0 = i1;
	  }

	  return rows;
	}

	var squarify = (function custom(ratio) {

	  function squarify(parent, x0, y0, x1, y1) {
	    squarifyRatio(ratio, parent, x0, y0, x1, y1);
	  }

	  squarify.ratio = function(x) {
	    return custom((x = +x) > 1 ? x : 1);
	  };

	  return squarify;
	})(phi);

	function index$1() {
	  var tile = squarify,
	      round = false,
	      dx = 1,
	      dy = 1,
	      paddingStack = [0],
	      paddingInner = constantZero,
	      paddingTop = constantZero,
	      paddingRight = constantZero,
	      paddingBottom = constantZero,
	      paddingLeft = constantZero;

	  function treemap(root) {
	    root.x0 =
	    root.y0 = 0;
	    root.x1 = dx;
	    root.y1 = dy;
	    root.eachBefore(positionNode);
	    paddingStack = [0];
	    if (round) root.eachBefore(roundNode);
	    return root;
	  }

	  function positionNode(node) {
	    var p = paddingStack[node.depth],
	        x0 = node.x0 + p,
	        y0 = node.y0 + p,
	        x1 = node.x1 - p,
	        y1 = node.y1 - p;
	    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	    node.x0 = x0;
	    node.y0 = y0;
	    node.x1 = x1;
	    node.y1 = y1;
	    if (node.children) {
	      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
	      x0 += paddingLeft(node) - p;
	      y0 += paddingTop(node) - p;
	      x1 -= paddingRight(node) - p;
	      y1 -= paddingBottom(node) - p;
	      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	      tile(node, x0, y0, x1, y1);
	    }
	  }

	  treemap.round = function(x) {
	    return arguments.length ? (round = !!x, treemap) : round;
	  };

	  treemap.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
	  };

	  treemap.tile = function(x) {
	    return arguments.length ? (tile = required(x), treemap) : tile;
	  };

	  treemap.padding = function(x) {
	    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
	  };

	  treemap.paddingInner = function(x) {
	    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
	  };

	  treemap.paddingOuter = function(x) {
	    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
	  };

	  treemap.paddingTop = function(x) {
	    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
	  };

	  treemap.paddingRight = function(x) {
	    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
	  };

	  treemap.paddingBottom = function(x) {
	    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
	  };

	  treemap.paddingLeft = function(x) {
	    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
	  };

	  return treemap;
	}

	function binary(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      i, n = nodes.length,
	      sum, sums = new Array(n + 1);

	  for (sums[0] = sum = i = 0; i < n; ++i) {
	    sums[i + 1] = sum += nodes[i].value;
	  }

	  partition(0, n, parent.value, x0, y0, x1, y1);

	  function partition(i, j, value, x0, y0, x1, y1) {
	    if (i >= j - 1) {
	      var node = nodes[i];
	      node.x0 = x0, node.y0 = y0;
	      node.x1 = x1, node.y1 = y1;
	      return;
	    }

	    var valueOffset = sums[i],
	        valueTarget = (value / 2) + valueOffset,
	        k = i + 1,
	        hi = j - 1;

	    while (k < hi) {
	      var mid = k + hi >>> 1;
	      if (sums[mid] < valueTarget) k = mid + 1;
	      else hi = mid;
	    }

	    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

	    var valueLeft = sums[k] - valueOffset,
	        valueRight = value - valueLeft;

	    if ((x1 - x0) > (y1 - y0)) {
	      var xk = (x0 * valueRight + x1 * valueLeft) / value;
	      partition(i, k, valueLeft, x0, y0, xk, y1);
	      partition(k, j, valueRight, xk, y0, x1, y1);
	    } else {
	      var yk = (y0 * valueRight + y1 * valueLeft) / value;
	      partition(i, k, valueLeft, x0, y0, x1, yk);
	      partition(k, j, valueRight, x0, yk, x1, y1);
	    }
	  }
	}

	function sliceDice(parent, x0, y0, x1, y1) {
	  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
	}

	var resquarify = (function custom(ratio) {

	  function resquarify(parent, x0, y0, x1, y1) {
	    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
	      var rows,
	          row,
	          nodes,
	          i,
	          j = -1,
	          n,
	          m = rows.length,
	          value = parent.value;

	      while (++j < m) {
	        row = rows[j], nodes = row.children;
	        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
	        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
	        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
	        value -= row.value;
	      }
	    } else {
	      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
	      rows.ratio = ratio;
	    }
	  }

	  resquarify.ratio = function(x) {
	    return custom((x = +x) > 1 ? x : 1);
	  };

	  return resquarify;
	})(phi);

	exports.cluster = cluster;
	exports.hierarchy = hierarchy;
	exports.pack = index;
	exports.packEnclose = enclose;
	exports.packSiblings = siblings;
	exports.partition = partition;
	exports.stratify = stratify;
	exports.tree = tree;
	exports.treemap = index$1;
	exports.treemapBinary = binary;
	exports.treemapDice = treemapDice;
	exports.treemapResquarify = resquarify;
	exports.treemapSlice = treemapSlice;
	exports.treemapSliceDice = sliceDice;
	exports.treemapSquarify = squarify;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-polygon/ v1.0.6 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	function area(polygon) {
	  var i = -1,
	      n = polygon.length,
	      a,
	      b = polygon[n - 1],
	      area = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    area += a[1] * b[0] - a[0] * b[1];
	  }

	  return area / 2;
	}

	function centroid(polygon) {
	  var i = -1,
	      n = polygon.length,
	      x = 0,
	      y = 0,
	      a,
	      b = polygon[n - 1],
	      c,
	      k = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    k += c = a[0] * b[1] - b[0] * a[1];
	    x += (a[0] + b[0]) * c;
	    y += (a[1] + b[1]) * c;
	  }

	  return k *= 3, [x / k, y / k];
	}

	// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
	// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
	// right, +y is up). Returns a positive value if ABC is counter-clockwise,
	// negative if clockwise, and zero if the points are collinear.
	function cross(a, b, c) {
	  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	}

	function lexicographicOrder(a, b) {
	  return a[0] - b[0] || a[1] - b[1];
	}

	// Computes the upper convex hull per the monotone chain algorithm.
	// Assumes points.length >= 3, is sorted by x, unique in y.
	// Returns an array of indices into points in left-to-right order.
	function computeUpperHullIndexes(points) {
	  var n = points.length,
	      indexes = [0, 1],
	      size = 2;

	  for (var i = 2; i < n; ++i) {
	    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
	    indexes[size++] = i;
	  }

	  return indexes.slice(0, size); // remove popped points
	}

	function hull(points) {
	  if ((n = points.length) < 3) return null;

	  var i,
	      n,
	      sortedPoints = new Array(n),
	      flippedPoints = new Array(n);

	  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
	  sortedPoints.sort(lexicographicOrder);
	  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

	  var upperIndexes = computeUpperHullIndexes(sortedPoints),
	      lowerIndexes = computeUpperHullIndexes(flippedPoints);

	  // Construct the hull polygon, removing possible duplicate endpoints.
	  var skipLeft = lowerIndexes[0] === upperIndexes[0],
	      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
	      hull = [];

	  // Add upper hull in right-to-l order.
	  // Then add lower hull in left-to-right order.
	  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
	  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

	  return hull;
	}

	function contains(polygon, point) {
	  var n = polygon.length,
	      p = polygon[n - 1],
	      x = point[0], y = point[1],
	      x0 = p[0], y0 = p[1],
	      x1, y1,
	      inside = false;

	  for (var i = 0; i < n; ++i) {
	    p = polygon[i], x1 = p[0], y1 = p[1];
	    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
	    x0 = x1, y0 = y1;
	  }

	  return inside;
	}

	function length(polygon) {
	  var i = -1,
	      n = polygon.length,
	      b = polygon[n - 1],
	      xa,
	      ya,
	      xb = b[0],
	      yb = b[1],
	      perimeter = 0;

	  while (++i < n) {
	    xa = xb;
	    ya = yb;
	    b = polygon[i];
	    xb = b[0];
	    yb = b[1];
	    xa -= xb;
	    ya -= yb;
	    perimeter += Math.sqrt(xa * xa + ya * ya);
	  }

	  return perimeter;
	}

	exports.polygonArea = area;
	exports.polygonCentroid = centroid;
	exports.polygonContains = contains;
	exports.polygonHull = hull;
	exports.polygonLength = length;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-random/ v1.1.2 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function defaultSource() {
	  return Math.random();
	}

	var uniform = (function sourceRandomUniform(source) {
	  function randomUniform(min, max) {
	    min = min == null ? 0 : +min;
	    max = max == null ? 1 : +max;
	    if (arguments.length === 1) max = min, min = 0;
	    else max -= min;
	    return function() {
	      return source() * max + min;
	    };
	  }

	  randomUniform.source = sourceRandomUniform;

	  return randomUniform;
	})(defaultSource);

	var normal = (function sourceRandomNormal(source) {
	  function randomNormal(mu, sigma) {
	    var x, r;
	    mu = mu == null ? 0 : +mu;
	    sigma = sigma == null ? 1 : +sigma;
	    return function() {
	      var y;

	      // If available, use the second previously-generated uniform random.
	      if (x != null) y = x, x = null;

	      // Otherwise, generate a new x and y.
	      else do {
	        x = source() * 2 - 1;
	        y = source() * 2 - 1;
	        r = x * x + y * y;
	      } while (!r || r > 1);

	      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
	    };
	  }

	  randomNormal.source = sourceRandomNormal;

	  return randomNormal;
	})(defaultSource);

	var logNormal = (function sourceRandomLogNormal(source) {
	  function randomLogNormal() {
	    var randomNormal = normal.source(source).apply(this, arguments);
	    return function() {
	      return Math.exp(randomNormal());
	    };
	  }

	  randomLogNormal.source = sourceRandomLogNormal;

	  return randomLogNormal;
	})(defaultSource);

	var irwinHall = (function sourceRandomIrwinHall(source) {
	  function randomIrwinHall(n) {
	    return function() {
	      for (var sum = 0, i = 0; i < n; ++i) sum += source();
	      return sum;
	    };
	  }

	  randomIrwinHall.source = sourceRandomIrwinHall;

	  return randomIrwinHall;
	})(defaultSource);

	var bates = (function sourceRandomBates(source) {
	  function randomBates(n) {
	    var randomIrwinHall = irwinHall.source(source)(n);
	    return function() {
	      return randomIrwinHall() / n;
	    };
	  }

	  randomBates.source = sourceRandomBates;

	  return randomBates;
	})(defaultSource);

	var exponential = (function sourceRandomExponential(source) {
	  function randomExponential(lambda) {
	    return function() {
	      return -Math.log(1 - source()) / lambda;
	    };
	  }

	  randomExponential.source = sourceRandomExponential;

	  return randomExponential;
	})(defaultSource);

	exports.randomUniform = uniform;
	exports.randomNormal = normal;
	exports.randomLogNormal = logNormal;
	exports.randomBates = bates;
	exports.randomIrwinHall = irwinHall;
	exports.randomExponential = exponential;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale/ v2.2.2 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(19), __webpack_require__(6), __webpack_require__(12), __webpack_require__(25), __webpack_require__(31), __webpack_require__(32)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-collection', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Collection,d3Array,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

	function initRange(domain, range) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.range(domain); break;
	    default: this.range(range).domain(domain); break;
	  }
	  return this;
	}

	function initInterpolator(domain, interpolator) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.interpolator(domain); break;
	    default: this.interpolator(interpolator).domain(domain); break;
	  }
	  return this;
	}

	var array = Array.prototype;

	var map = array.map;
	var slice = array.slice;

	var implicit = {name: "implicit"};

	function ordinal() {
	  var index = d3Collection.map(),
	      domain = [],
	      range = [],
	      unknown = implicit;

	  function scale(d) {
	    var key = d + "", i = index.get(key);
	    if (!i) {
	      if (unknown !== implicit) return unknown;
	      index.set(key, i = domain.push(d));
	    }
	    return range[(i - 1) % range.length];
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [], index = d3Collection.map();
	    var i = -1, n = _.length, d, key;
	    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
	    return scale;
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), scale) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return ordinal(domain, range).unknown(unknown);
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function band() {
	  var scale = ordinal().unknown(undefined),
	      domain = scale.domain,
	      ordinalRange = scale.range,
	      range = [0, 1],
	      step,
	      bandwidth,
	      round = false,
	      paddingInner = 0,
	      paddingOuter = 0,
	      align = 0.5;

	  delete scale.unknown;

	  function rescale() {
	    var n = domain().length,
	        reverse = range[1] < range[0],
	        start = range[reverse - 0],
	        stop = range[1 - reverse];
	    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	    if (round) step = Math.floor(step);
	    start += (stop - start - step * (n - paddingInner)) * align;
	    bandwidth = step * (1 - paddingInner);
	    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	    var values = d3Array.range(n).map(function(i) { return start + step * i; });
	    return ordinalRange(reverse ? values.reverse() : values);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = [+_[0], +_[1]], round = true, rescale();
	  };

	  scale.bandwidth = function() {
	    return bandwidth;
	  };

	  scale.step = function() {
	    return step;
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, rescale()) : round;
	  };

	  scale.padding = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	  };

	  scale.paddingInner = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	  };

	  scale.paddingOuter = function(_) {
	    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	  };

	  scale.align = function(_) {
	    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	  };

	  scale.copy = function() {
	    return band(domain(), range)
	        .round(round)
	        .paddingInner(paddingInner)
	        .paddingOuter(paddingOuter)
	        .align(align);
	  };

	  return initRange.apply(rescale(), arguments);
	}

	function pointish(scale) {
	  var copy = scale.copy;

	  scale.padding = scale.paddingOuter;
	  delete scale.paddingInner;
	  delete scale.paddingOuter;

	  scale.copy = function() {
	    return pointish(copy());
	  };

	  return scale;
	}

	function point() {
	  return pointish(band.apply(null, arguments).paddingInner(1));
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function number(x) {
	  return +x;
	}

	var unit = [0, 1];

	function identity(x) {
	  return x;
	}

	function normalize(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constant(isNaN(b) ? NaN : 0.5);
	}

	function clamper(domain) {
	  var a = domain[0], b = domain[domain.length - 1], t;
	  if (a > b) t = a, a = b, b = t;
	  return function(x) { return Math.max(a, Math.min(b, x)); };
	}

	// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
	function bimap(domain, range, interpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range, interpolate) {
	  var j = Math.min(domain.length, range.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range = range.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = normalize(domain[i], domain[i + 1]);
	    r[i] = interpolate(range[i], range[i + 1]);
	  }

	  return function(x) {
	    var i = d3Array.bisect(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function transformer() {
	  var domain = unit,
	      range = unit,
	      interpolate = d3Interpolate.interpolate,
	      transform,
	      untransform,
	      unknown,
	      clamp = identity,
	      piecewise,
	      output,
	      input;

	  function rescale() {
	    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
	  }

	  scale.invert = function(y) {
	    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, rescale()) : interpolate;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t, u) {
	    transform = t, untransform = u;
	    return rescale();
	  };
	}

	function continuous(transform, untransform) {
	  return transformer()(transform, untransform);
	}

	function tickFormat(start, stop, count, specifier) {
	  var step = d3Array.tickStep(start, stop, count),
	      precision;
	  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
	      return d3Format.formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return d3Format.format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    var d = domain();
	    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain(),
	        i0 = 0,
	        i1 = d.length - 1,
	        start = d[i0],
	        stop = d[i1],
	        step;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }

	    step = d3Array.tickIncrement(start, stop, count);

	    if (step > 0) {
	      start = Math.floor(start / step) * step;
	      stop = Math.ceil(stop / step) * step;
	      step = d3Array.tickIncrement(start, stop, count);
	    } else if (step < 0) {
	      start = Math.ceil(start * step) / step;
	      stop = Math.floor(stop * step) / step;
	      step = d3Array.tickIncrement(start, stop, count);
	    }

	    if (step > 0) {
	      d[i0] = Math.floor(start / step) * step;
	      d[i1] = Math.ceil(stop / step) * step;
	      domain(d);
	    } else if (step < 0) {
	      d[i0] = Math.ceil(start * step) / step;
	      d[i1] = Math.floor(stop * step) / step;
	      domain(d);
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear() {
	  var scale = continuous(identity, identity);

	  scale.copy = function() {
	    return copy(scale, linear());
	  };

	  initRange.apply(scale, arguments);

	  return linearish(scale);
	}

	function identity$1(domain) {
	  var unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : x;
	  }

	  scale.invert = scale;

	  scale.domain = scale.range = function(_) {
	    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return identity$1(domain).unknown(unknown);
	  };

	  domain = arguments.length ? map.call(domain, number) : [0, 1];

	  return linearish(scale);
	}

	function nice(domain, interval) {
	  domain = domain.slice();

	  var i0 = 0,
	      i1 = domain.length - 1,
	      x0 = domain[i0],
	      x1 = domain[i1],
	      t;

	  if (x1 < x0) {
	    t = i0, i0 = i1, i1 = t;
	    t = x0, x0 = x1, x1 = t;
	  }

	  domain[i0] = interval.floor(x0);
	  domain[i1] = interval.ceil(x1);
	  return domain;
	}

	function transformLog(x) {
	  return Math.log(x);
	}

	function transformExp(x) {
	  return Math.exp(x);
	}

	function transformLogn(x) {
	  return -Math.log(-x);
	}

	function transformExpn(x) {
	  return -Math.exp(-x);
	}

	function pow10(x) {
	  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	}

	function powp(base) {
	  return base === 10 ? pow10
	      : base === Math.E ? Math.exp
	      : function(x) { return Math.pow(base, x); };
	}

	function logp(base) {
	  return base === Math.E ? Math.log
	      : base === 10 && Math.log10
	      || base === 2 && Math.log2
	      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	}

	function reflect(f) {
	  return function(x) {
	    return -f(-x);
	  };
	}

	function loggish(transform) {
	  var scale = transform(transformLog, transformExp),
	      domain = scale.domain,
	      base = 10,
	      logs,
	      pows;

	  function rescale() {
	    logs = logp(base), pows = powp(base);
	    if (domain()[0] < 0) {
	      logs = reflect(logs), pows = reflect(pows);
	      transform(transformLogn, transformExpn);
	    } else {
	      transform(transformLog, transformExp);
	    }
	    return scale;
	  }

	  scale.base = function(_) {
	    return arguments.length ? (base = +_, rescale()) : base;
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.ticks = function(count) {
	    var d = domain(),
	        u = d[0],
	        v = d[d.length - 1],
	        r;

	    if (r = v < u) i = u, u = v, v = i;

	    var i = logs(u),
	        j = logs(v),
	        p,
	        k,
	        t,
	        n = count == null ? 10 : +count,
	        z = [];

	    if (!(base % 1) && j - i < n) {
	      i = Math.round(i) - 1, j = Math.round(j) + 1;
	      if (u > 0) for (; i < j; ++i) {
	        for (k = 1, p = pows(i); k < base; ++k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      } else for (; i < j; ++i) {
	        for (k = base - 1, p = pows(i); k >= 1; --k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      }
	    } else {
	      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
	    }

	    return r ? z.reverse() : z;
	  };

	  scale.tickFormat = function(count, specifier) {
	    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
	    if (count === Infinity) return specifier;
	    if (count == null) count = 10;
	    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	    return function(d) {
	      var i = d / pows(Math.round(logs(d)));
	      if (i * base < base - 0.5) i *= base;
	      return i <= k ? specifier(d) : "";
	    };
	  };

	  scale.nice = function() {
	    return domain(nice(domain(), {
	      floor: function(x) { return pows(Math.floor(logs(x))); },
	      ceil: function(x) { return pows(Math.ceil(logs(x))); }
	    }));
	  };

	  return scale;
	}

	function log() {
	  var scale = loggish(transformer()).domain([1, 10]);

	  scale.copy = function() {
	    return copy(scale, log()).base(scale.base());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function transformSymlog(c) {
	  return function(x) {
	    return Math.sign(x) * Math.log1p(Math.abs(x / c));
	  };
	}

	function transformSymexp(c) {
	  return function(x) {
	    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
	  };
	}

	function symlogish(transform) {
	  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

	  scale.constant = function(_) {
	    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
	  };

	  return linearish(scale);
	}

	function symlog() {
	  var scale = symlogish(transformer());

	  scale.copy = function() {
	    return copy(scale, symlog()).constant(scale.constant());
	  };

	  return initRange.apply(scale, arguments);
	}

	function transformPow(exponent) {
	  return function(x) {
	    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
	  };
	}

	function transformSqrt(x) {
	  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
	}

	function transformSquare(x) {
	  return x < 0 ? -x * x : x * x;
	}

	function powish(transform) {
	  var scale = transform(identity, identity),
	      exponent = 1;

	  function rescale() {
	    return exponent === 1 ? transform(identity, identity)
	        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
	        : transform(transformPow(exponent), transformPow(1 / exponent));
	  }

	  scale.exponent = function(_) {
	    return arguments.length ? (exponent = +_, rescale()) : exponent;
	  };

	  return linearish(scale);
	}

	function pow() {
	  var scale = powish(transformer());

	  scale.copy = function() {
	    return copy(scale, pow()).exponent(scale.exponent());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function sqrt() {
	  return pow.apply(null, arguments).exponent(0.5);
	}

	function quantile() {
	  var domain = [],
	      range = [],
	      thresholds = [],
	      unknown;

	  function rescale() {
	    var i = 0, n = Math.max(1, range.length);
	    thresholds = new Array(n - 1);
	    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
	  }

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return i < 0 ? [NaN, NaN] : [
	      i > 0 ? thresholds[i - 1] : domain[0],
	      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
	    ];
	  };

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return rescale();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.quantiles = function() {
	    return thresholds.slice();
	  };

	  scale.copy = function() {
	    return quantile()
	        .domain(domain)
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(scale, arguments);
	}

	function quantize() {
	  var x0 = 0,
	      x1 = 1,
	      n = 1,
	      domain = [0.5],
	      range = [0, 1],
	      unknown;

	  function scale(x) {
	    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
	  }

	  function rescale() {
	    var i = -1;
	    domain = new Array(n);
	    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
	    return scale;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
	  };

	  scale.range = function(_) {
	    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return i < 0 ? [NaN, NaN]
	        : i < 1 ? [x0, domain[0]]
	        : i >= n ? [domain[n - 1], x1]
	        : [domain[i - 1], domain[i]];
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : scale;
	  };

	  scale.thresholds = function() {
	    return domain.slice();
	  };

	  scale.copy = function() {
	    return quantize()
	        .domain([x0, x1])
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(linearish(scale), arguments);
	}

	function threshold() {
	  var domain = [0.5],
	      range = [0, 1],
	      unknown,
	      n = 1;

	  function scale(x) {
	    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range.indexOf(y);
	    return [domain[i - 1], domain[i]];
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return threshold()
	        .domain(domain)
	        .range(range)
	        .unknown(unknown);
	  };

	  return initRange.apply(scale, arguments);
	}

	var durationSecond = 1000,
	    durationMinute = durationSecond * 60,
	    durationHour = durationMinute * 60,
	    durationDay = durationHour * 24,
	    durationWeek = durationDay * 7,
	    durationMonth = durationDay * 30,
	    durationYear = durationDay * 365;

	function date(t) {
	  return new Date(t);
	}

	function number$1(t) {
	  return t instanceof Date ? +t : +new Date(+t);
	}

	function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
	  var scale = continuous(identity, identity),
	      invert = scale.invert,
	      domain = scale.domain;

	  var formatMillisecond = format(".%L"),
	      formatSecond = format(":%S"),
	      formatMinute = format("%I:%M"),
	      formatHour = format("%I %p"),
	      formatDay = format("%a %d"),
	      formatWeek = format("%b %d"),
	      formatMonth = format("%B"),
	      formatYear = format("%Y");

	  var tickIntervals = [
	    [second,  1,      durationSecond],
	    [second,  5,  5 * durationSecond],
	    [second, 15, 15 * durationSecond],
	    [second, 30, 30 * durationSecond],
	    [minute,  1,      durationMinute],
	    [minute,  5,  5 * durationMinute],
	    [minute, 15, 15 * durationMinute],
	    [minute, 30, 30 * durationMinute],
	    [  hour,  1,      durationHour  ],
	    [  hour,  3,  3 * durationHour  ],
	    [  hour,  6,  6 * durationHour  ],
	    [  hour, 12, 12 * durationHour  ],
	    [   day,  1,      durationDay   ],
	    [   day,  2,  2 * durationDay   ],
	    [  week,  1,      durationWeek  ],
	    [ month,  1,      durationMonth ],
	    [ month,  3,  3 * durationMonth ],
	    [  year,  1,      durationYear  ]
	  ];

	  function tickFormat(date) {
	    return (second(date) < date ? formatMillisecond
	        : minute(date) < date ? formatSecond
	        : hour(date) < date ? formatMinute
	        : day(date) < date ? formatHour
	        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	        : year(date) < date ? formatMonth
	        : formatYear)(date);
	  }

	  function tickInterval(interval, start, stop, step) {
	    if (interval == null) interval = 10;

	    // If a desired tick count is specified, pick a reasonable tick interval
	    // based on the extent of the domain and a rough estimate of tick size.
	    // Otherwise, assume interval is already a time interval and use it.
	    if (typeof interval === "number") {
	      var target = Math.abs(stop - start) / interval,
	          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
	      if (i === tickIntervals.length) {
	        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
	        interval = year;
	      } else if (i) {
	        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	        step = i[1];
	        interval = i[0];
	      } else {
	        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
	        interval = millisecond;
	      }
	    }

	    return step == null ? interval : interval.every(step);
	  }

	  scale.invert = function(y) {
	    return new Date(invert(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
	  };

	  scale.ticks = function(interval, step) {
	    var d = domain(),
	        t0 = d[0],
	        t1 = d[d.length - 1],
	        r = t1 < t0,
	        t;
	    if (r) t = t0, t0 = t1, t1 = t;
	    t = tickInterval(interval, t0, t1, step);
	    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	    return r ? t.reverse() : t;
	  };

	  scale.tickFormat = function(count, specifier) {
	    return specifier == null ? tickFormat : format(specifier);
	  };

	  scale.nice = function(interval, step) {
	    var d = domain();
	    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
	        ? domain(nice(d, interval))
	        : scale;
	  };

	  scale.copy = function() {
	    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
	  };

	  return scale;
	}

	function time() {
	  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
	}

	function utcTime() {
	  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
	}

	function transformer$1() {
	  var x0 = 0,
	      x1 = 1,
	      t0,
	      t1,
	      k10,
	      transform,
	      interpolator = identity,
	      clamp = false,
	      unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t) {
	    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
	    return scale;
	  };
	}

	function copy$1(source, target) {
	  return target
	      .domain(source.domain())
	      .interpolator(source.interpolator())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function sequential() {
	  var scale = linearish(transformer$1()(identity));

	  scale.copy = function() {
	    return copy$1(scale, sequential());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialLog() {
	  var scale = loggish(transformer$1()).domain([1, 10]);

	  scale.copy = function() {
	    return copy$1(scale, sequentialLog()).base(scale.base());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialSymlog() {
	  var scale = symlogish(transformer$1());

	  scale.copy = function() {
	    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialPow() {
	  var scale = powish(transformer$1());

	  scale.copy = function() {
	    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function sequentialSqrt() {
	  return sequentialPow.apply(null, arguments).exponent(0.5);
	}

	function sequentialQuantile() {
	  var domain = [],
	      interpolator = identity;

	  function scale(x) {
	    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x) - 1) / (domain.length - 1));
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return scale;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.copy = function() {
	    return sequentialQuantile(interpolator).domain(domain);
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function transformer$2() {
	  var x0 = 0,
	      x1 = 0.5,
	      x2 = 1,
	      t0,
	      t1,
	      t2,
	      k10,
	      k21,
	      interpolator = identity,
	      transform,
	      clamp = false,
	      unknown;

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t) {
	    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
	    return scale;
	  };
	}

	function diverging() {
	  var scale = linearish(transformer$2()(identity));

	  scale.copy = function() {
	    return copy$1(scale, diverging());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingLog() {
	  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

	  scale.copy = function() {
	    return copy$1(scale, divergingLog()).base(scale.base());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingSymlog() {
	  var scale = symlogish(transformer$2());

	  scale.copy = function() {
	    return copy$1(scale, divergingSymlog()).constant(scale.constant());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingPow() {
	  var scale = powish(transformer$2());

	  scale.copy = function() {
	    return copy$1(scale, divergingPow()).exponent(scale.exponent());
	  };

	  return initInterpolator.apply(scale, arguments);
	}

	function divergingSqrt() {
	  return divergingPow.apply(null, arguments).exponent(0.5);
	}

	exports.scaleBand = band;
	exports.scalePoint = point;
	exports.scaleIdentity = identity$1;
	exports.scaleLinear = linear;
	exports.scaleLog = log;
	exports.scaleSymlog = symlog;
	exports.scaleOrdinal = ordinal;
	exports.scaleImplicit = implicit;
	exports.scalePow = pow;
	exports.scaleSqrt = sqrt;
	exports.scaleQuantile = quantile;
	exports.scaleQuantize = quantize;
	exports.scaleThreshold = threshold;
	exports.scaleTime = time;
	exports.scaleUtc = utcTime;
	exports.scaleSequential = sequential;
	exports.scaleSequentialLog = sequentialLog;
	exports.scaleSequentialPow = sequentialPow;
	exports.scaleSequentialSqrt = sequentialSqrt;
	exports.scaleSequentialSymlog = sequentialSymlog;
	exports.scaleSequentialQuantile = sequentialQuantile;
	exports.scaleDiverging = diverging;
	exports.scaleDivergingLog = divergingLog;
	exports.scaleDivergingPow = divergingPow;
	exports.scaleDivergingSqrt = divergingSqrt;
	exports.scaleDivergingSymlog = divergingSymlog;
	exports.tickFormat = tickFormat;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time/ v1.1.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}));
	}(this, function (exports) { 'use strict';

	var t0 = new Date,
	    t1 = new Date;

	function newInterval(floori, offseti, count, field) {

	  function interval(date) {
	    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
	  }

	  interval.floor = function(date) {
	    return floori(date = new Date(+date)), date;
	  };

	  interval.ceil = function(date) {
	    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	  };

	  interval.round = function(date) {
	    var d0 = interval(date),
	        d1 = interval.ceil(date);
	    return date - d0 < d1 - date ? d0 : d1;
	  };

	  interval.offset = function(date, step) {
	    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	  };

	  interval.range = function(start, stop, step) {
	    var range = [], previous;
	    start = interval.ceil(start);
	    step = step == null ? 1 : Math.floor(step);
	    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	    while (previous < start && start < stop);
	    return range;
	  };

	  interval.filter = function(test) {
	    return newInterval(function(date) {
	      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	    }, function(date, step) {
	      if (date >= date) {
	        if (step < 0) while (++step <= 0) {
	          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
	        } else while (--step >= 0) {
	          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
	        }
	      }
	    });
	  };

	  if (count) {
	    interval.count = function(start, end) {
	      t0.setTime(+start), t1.setTime(+end);
	      floori(t0), floori(t1);
	      return Math.floor(count(t0, t1));
	    };

	    interval.every = function(step) {
	      step = Math.floor(step);
	      return !isFinite(step) || !(step > 0) ? null
	          : !(step > 1) ? interval
	          : interval.filter(field
	              ? function(d) { return field(d) % step === 0; }
	              : function(d) { return interval.count(0, d) % step === 0; });
	    };
	  }

	  return interval;
	}

	var millisecond = newInterval(function() {
	  // noop
	}, function(date, step) {
	  date.setTime(+date + step);
	}, function(start, end) {
	  return end - start;
	});

	// An optimized implementation for this simple case.
	millisecond.every = function(k) {
	  k = Math.floor(k);
	  if (!isFinite(k) || !(k > 0)) return null;
	  if (!(k > 1)) return millisecond;
	  return newInterval(function(date) {
	    date.setTime(Math.floor(date / k) * k);
	  }, function(date, step) {
	    date.setTime(+date + step * k);
	  }, function(start, end) {
	    return (end - start) / k;
	  });
	};
	var milliseconds = millisecond.range;

	var durationSecond = 1e3;
	var durationMinute = 6e4;
	var durationHour = 36e5;
	var durationDay = 864e5;
	var durationWeek = 6048e5;

	var second = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds());
	}, function(date, step) {
	  date.setTime(+date + step * durationSecond);
	}, function(start, end) {
	  return (end - start) / durationSecond;
	}, function(date) {
	  return date.getUTCSeconds();
	});
	var seconds = second.range;

	var minute = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getMinutes();
	});
	var minutes = minute.range;

	var hour = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getHours();
	});
	var hours = hour.range;

	var day = newInterval(function(date) {
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setDate(date.getDate() + step);
	}, function(start, end) {
	  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
	}, function(date) {
	  return date.getDate() - 1;
	});
	var days = day.range;

	function weekday(i) {
	  return newInterval(function(date) {
	    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step * 7);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	  });
	}

	var sunday = weekday(0);
	var monday = weekday(1);
	var tuesday = weekday(2);
	var wednesday = weekday(3);
	var thursday = weekday(4);
	var friday = weekday(5);
	var saturday = weekday(6);

	var sundays = sunday.range;
	var mondays = monday.range;
	var tuesdays = tuesday.range;
	var wednesdays = wednesday.range;
	var thursdays = thursday.range;
	var fridays = friday.range;
	var saturdays = saturday.range;

	var month = newInterval(function(date) {
	  date.setDate(1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setMonth(date.getMonth() + step);
	}, function(start, end) {
	  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	}, function(date) {
	  return date.getMonth();
	});
	var months = month.range;

	var year = newInterval(function(date) {
	  date.setMonth(0, 1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setFullYear(date.getFullYear() + step);
	}, function(start, end) {
	  return end.getFullYear() - start.getFullYear();
	}, function(date) {
	  return date.getFullYear();
	});

	// An optimized implementation for this simple case.
	year.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step * k);
	  });
	};
	var years = year.range;

	var utcMinute = newInterval(function(date) {
	  date.setUTCSeconds(0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getUTCMinutes();
	});
	var utcMinutes = utcMinute.range;

	var utcHour = newInterval(function(date) {
	  date.setUTCMinutes(0, 0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getUTCHours();
	});
	var utcHours = utcHour.range;

	var utcDay = newInterval(function(date) {
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCDate(date.getUTCDate() + step);
	}, function(start, end) {
	  return (end - start) / durationDay;
	}, function(date) {
	  return date.getUTCDate() - 1;
	});
	var utcDays = utcDay.range;

	function utcWeekday(i) {
	  return newInterval(function(date) {
	    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step * 7);
	  }, function(start, end) {
	    return (end - start) / durationWeek;
	  });
	}

	var utcSunday = utcWeekday(0);
	var utcMonday = utcWeekday(1);
	var utcTuesday = utcWeekday(2);
	var utcWednesday = utcWeekday(3);
	var utcThursday = utcWeekday(4);
	var utcFriday = utcWeekday(5);
	var utcSaturday = utcWeekday(6);

	var utcSundays = utcSunday.range;
	var utcMondays = utcMonday.range;
	var utcTuesdays = utcTuesday.range;
	var utcWednesdays = utcWednesday.range;
	var utcThursdays = utcThursday.range;
	var utcFridays = utcFriday.range;
	var utcSaturdays = utcSaturday.range;

	var utcMonth = newInterval(function(date) {
	  date.setUTCDate(1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCMonth(date.getUTCMonth() + step);
	}, function(start, end) {
	  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	}, function(date) {
	  return date.getUTCMonth();
	});
	var utcMonths = utcMonth.range;

	var utcYear = newInterval(function(date) {
	  date.setUTCMonth(0, 1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCFullYear(date.getUTCFullYear() + step);
	}, function(start, end) {
	  return end.getUTCFullYear() - start.getUTCFullYear();
	}, function(date) {
	  return date.getUTCFullYear();
	});

	// An optimized implementation for this simple case.
	utcYear.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step * k);
	  });
	};
	var utcYears = utcYear.range;

	exports.timeDay = day;
	exports.timeDays = days;
	exports.timeFriday = friday;
	exports.timeFridays = fridays;
	exports.timeHour = hour;
	exports.timeHours = hours;
	exports.timeInterval = newInterval;
	exports.timeMillisecond = millisecond;
	exports.timeMilliseconds = milliseconds;
	exports.timeMinute = minute;
	exports.timeMinutes = minutes;
	exports.timeMonday = monday;
	exports.timeMondays = mondays;
	exports.timeMonth = month;
	exports.timeMonths = months;
	exports.timeSaturday = saturday;
	exports.timeSaturdays = saturdays;
	exports.timeSecond = second;
	exports.timeSeconds = seconds;
	exports.timeSunday = sunday;
	exports.timeSundays = sundays;
	exports.timeThursday = thursday;
	exports.timeThursdays = thursdays;
	exports.timeTuesday = tuesday;
	exports.timeTuesdays = tuesdays;
	exports.timeWednesday = wednesday;
	exports.timeWednesdays = wednesdays;
	exports.timeWeek = sunday;
	exports.timeWeeks = sundays;
	exports.timeYear = year;
	exports.timeYears = years;
	exports.utcDay = utcDay;
	exports.utcDays = utcDays;
	exports.utcFriday = utcFriday;
	exports.utcFridays = utcFridays;
	exports.utcHour = utcHour;
	exports.utcHours = utcHours;
	exports.utcMillisecond = millisecond;
	exports.utcMilliseconds = milliseconds;
	exports.utcMinute = utcMinute;
	exports.utcMinutes = utcMinutes;
	exports.utcMonday = utcMonday;
	exports.utcMondays = utcMondays;
	exports.utcMonth = utcMonth;
	exports.utcMonths = utcMonths;
	exports.utcSaturday = utcSaturday;
	exports.utcSaturdays = utcSaturdays;
	exports.utcSecond = second;
	exports.utcSeconds = seconds;
	exports.utcSunday = utcSunday;
	exports.utcSundays = utcSundays;
	exports.utcThursday = utcThursday;
	exports.utcThursdays = utcThursdays;
	exports.utcTuesday = utcTuesday;
	exports.utcTuesdays = utcTuesdays;
	exports.utcWednesday = utcWednesday;
	exports.utcWednesdays = utcWednesdays;
	exports.utcWeek = utcSunday;
	exports.utcWeeks = utcSundays;
	exports.utcYear = utcYear;
	exports.utcYears = utcYears;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time-format/ v2.2.3 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(31)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Time) { 'use strict';

	function localDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	    date.setFullYear(d.y);
	    return date;
	  }
	  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	}

	function utcDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	    date.setUTCFullYear(d.y);
	    return date;
	  }
	  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	}

	function newDate(y, m, d) {
	  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
	}

	function formatLocale(locale) {
	  var locale_dateTime = locale.dateTime,
	      locale_date = locale.date,
	      locale_time = locale.time,
	      locale_periods = locale.periods,
	      locale_weekdays = locale.days,
	      locale_shortWeekdays = locale.shortDays,
	      locale_months = locale.months,
	      locale_shortMonths = locale.shortMonths;

	  var periodRe = formatRe(locale_periods),
	      periodLookup = formatLookup(locale_periods),
	      weekdayRe = formatRe(locale_weekdays),
	      weekdayLookup = formatLookup(locale_weekdays),
	      shortWeekdayRe = formatRe(locale_shortWeekdays),
	      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	      monthRe = formatRe(locale_months),
	      monthLookup = formatLookup(locale_months),
	      shortMonthRe = formatRe(locale_shortMonths),
	      shortMonthLookup = formatLookup(locale_shortMonths);

	  var formats = {
	    "a": formatShortWeekday,
	    "A": formatWeekday,
	    "b": formatShortMonth,
	    "B": formatMonth,
	    "c": null,
	    "d": formatDayOfMonth,
	    "e": formatDayOfMonth,
	    "f": formatMicroseconds,
	    "H": formatHour24,
	    "I": formatHour12,
	    "j": formatDayOfYear,
	    "L": formatMilliseconds,
	    "m": formatMonthNumber,
	    "M": formatMinutes,
	    "p": formatPeriod,
	    "q": formatQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatSeconds,
	    "u": formatWeekdayNumberMonday,
	    "U": formatWeekNumberSunday,
	    "V": formatWeekNumberISO,
	    "w": formatWeekdayNumberSunday,
	    "W": formatWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatYear,
	    "Y": formatFullYear,
	    "Z": formatZone,
	    "%": formatLiteralPercent
	  };

	  var utcFormats = {
	    "a": formatUTCShortWeekday,
	    "A": formatUTCWeekday,
	    "b": formatUTCShortMonth,
	    "B": formatUTCMonth,
	    "c": null,
	    "d": formatUTCDayOfMonth,
	    "e": formatUTCDayOfMonth,
	    "f": formatUTCMicroseconds,
	    "H": formatUTCHour24,
	    "I": formatUTCHour12,
	    "j": formatUTCDayOfYear,
	    "L": formatUTCMilliseconds,
	    "m": formatUTCMonthNumber,
	    "M": formatUTCMinutes,
	    "p": formatUTCPeriod,
	    "q": formatUTCQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatUTCSeconds,
	    "u": formatUTCWeekdayNumberMonday,
	    "U": formatUTCWeekNumberSunday,
	    "V": formatUTCWeekNumberISO,
	    "w": formatUTCWeekdayNumberSunday,
	    "W": formatUTCWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatUTCYear,
	    "Y": formatUTCFullYear,
	    "Z": formatUTCZone,
	    "%": formatLiteralPercent
	  };

	  var parses = {
	    "a": parseShortWeekday,
	    "A": parseWeekday,
	    "b": parseShortMonth,
	    "B": parseMonth,
	    "c": parseLocaleDateTime,
	    "d": parseDayOfMonth,
	    "e": parseDayOfMonth,
	    "f": parseMicroseconds,
	    "H": parseHour24,
	    "I": parseHour24,
	    "j": parseDayOfYear,
	    "L": parseMilliseconds,
	    "m": parseMonthNumber,
	    "M": parseMinutes,
	    "p": parsePeriod,
	    "q": parseQuarter,
	    "Q": parseUnixTimestamp,
	    "s": parseUnixTimestampSeconds,
	    "S": parseSeconds,
	    "u": parseWeekdayNumberMonday,
	    "U": parseWeekNumberSunday,
	    "V": parseWeekNumberISO,
	    "w": parseWeekdayNumberSunday,
	    "W": parseWeekNumberMonday,
	    "x": parseLocaleDate,
	    "X": parseLocaleTime,
	    "y": parseYear,
	    "Y": parseFullYear,
	    "Z": parseZone,
	    "%": parseLiteralPercent
	  };

	  // These recursive directive definitions must be deferred.
	  formats.x = newFormat(locale_date, formats);
	  formats.X = newFormat(locale_time, formats);
	  formats.c = newFormat(locale_dateTime, formats);
	  utcFormats.x = newFormat(locale_date, utcFormats);
	  utcFormats.X = newFormat(locale_time, utcFormats);
	  utcFormats.c = newFormat(locale_dateTime, utcFormats);

	  function newFormat(specifier, formats) {
	    return function(date) {
	      var string = [],
	          i = -1,
	          j = 0,
	          n = specifier.length,
	          c,
	          pad,
	          format;

	      if (!(date instanceof Date)) date = new Date(+date);

	      while (++i < n) {
	        if (specifier.charCodeAt(i) === 37) {
	          string.push(specifier.slice(j, i));
	          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	          else pad = c === "e" ? " " : "0";
	          if (format = formats[c]) c = format(date, pad);
	          string.push(c);
	          j = i + 1;
	        }
	      }

	      string.push(specifier.slice(j, i));
	      return string.join("");
	    };
	  }

	  function newParse(specifier, Z) {
	    return function(string) {
	      var d = newDate(1900, undefined, 1),
	          i = parseSpecifier(d, specifier, string += "", 0),
	          week, day;
	      if (i != string.length) return null;

	      // If a UNIX timestamp is specified, return it.
	      if ("Q" in d) return new Date(d.Q);
	      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

	      // If this is utcParse, never use the local timezone.
	      if (Z && !("Z" in d)) d.Z = 0;

	      // The am-pm flag is 0 for AM, and 1 for PM.
	      if ("p" in d) d.H = d.H % 12 + d.p * 12;

	      // If the month was not specified, inherit from the quarter.
	      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

	      // Convert day-of-week and week-of-year to day-of-year.
	      if ("V" in d) {
	        if (d.V < 1 || d.V > 53) return null;
	        if (!("w" in d)) d.w = 1;
	        if ("Z" in d) {
	          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
	          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
	          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getUTCFullYear();
	          d.m = week.getUTCMonth();
	          d.d = week.getUTCDate() + (d.w + 6) % 7;
	        } else {
	          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
	          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
	          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getFullYear();
	          d.m = week.getMonth();
	          d.d = week.getDate() + (d.w + 6) % 7;
	        }
	      } else if ("W" in d || "U" in d) {
	        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
	        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
	        d.m = 0;
	        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	      }

	      // If a time zone is specified, all fields are interpreted as UTC and then
	      // offset according to the specified time zone.
	      if ("Z" in d) {
	        d.H += d.Z / 100 | 0;
	        d.M += d.Z % 100;
	        return utcDate(d);
	      }

	      // Otherwise, all fields are in local time.
	      return localDate(d);
	    };
	  }

	  function parseSpecifier(d, specifier, string, j) {
	    var i = 0,
	        n = specifier.length,
	        m = string.length,
	        c,
	        parse;

	    while (i < n) {
	      if (j >= m) return -1;
	      c = specifier.charCodeAt(i++);
	      if (c === 37) {
	        c = specifier.charAt(i++);
	        parse = parses[c in pads ? specifier.charAt(i++) : c];
	        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	      } else if (c != string.charCodeAt(j++)) {
	        return -1;
	      }
	    }

	    return j;
	  }

	  function parsePeriod(d, string, i) {
	    var n = periodRe.exec(string.slice(i));
	    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortWeekday(d, string, i) {
	    var n = shortWeekdayRe.exec(string.slice(i));
	    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseWeekday(d, string, i) {
	    var n = weekdayRe.exec(string.slice(i));
	    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortMonth(d, string, i) {
	    var n = shortMonthRe.exec(string.slice(i));
	    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseMonth(d, string, i) {
	    var n = monthRe.exec(string.slice(i));
	    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseLocaleDateTime(d, string, i) {
	    return parseSpecifier(d, locale_dateTime, string, i);
	  }

	  function parseLocaleDate(d, string, i) {
	    return parseSpecifier(d, locale_date, string, i);
	  }

	  function parseLocaleTime(d, string, i) {
	    return parseSpecifier(d, locale_time, string, i);
	  }

	  function formatShortWeekday(d) {
	    return locale_shortWeekdays[d.getDay()];
	  }

	  function formatWeekday(d) {
	    return locale_weekdays[d.getDay()];
	  }

	  function formatShortMonth(d) {
	    return locale_shortMonths[d.getMonth()];
	  }

	  function formatMonth(d) {
	    return locale_months[d.getMonth()];
	  }

	  function formatPeriod(d) {
	    return locale_periods[+(d.getHours() >= 12)];
	  }

	  function formatQuarter(d) {
	    return 1 + ~~(d.getMonth() / 3);
	  }

	  function formatUTCShortWeekday(d) {
	    return locale_shortWeekdays[d.getUTCDay()];
	  }

	  function formatUTCWeekday(d) {
	    return locale_weekdays[d.getUTCDay()];
	  }

	  function formatUTCShortMonth(d) {
	    return locale_shortMonths[d.getUTCMonth()];
	  }

	  function formatUTCMonth(d) {
	    return locale_months[d.getUTCMonth()];
	  }

	  function formatUTCPeriod(d) {
	    return locale_periods[+(d.getUTCHours() >= 12)];
	  }

	  function formatUTCQuarter(d) {
	    return 1 + ~~(d.getUTCMonth() / 3);
	  }

	  return {
	    format: function(specifier) {
	      var f = newFormat(specifier += "", formats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    parse: function(specifier) {
	      var p = newParse(specifier += "", false);
	      p.toString = function() { return specifier; };
	      return p;
	    },
	    utcFormat: function(specifier) {
	      var f = newFormat(specifier += "", utcFormats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    utcParse: function(specifier) {
	      var p = newParse(specifier += "", true);
	      p.toString = function() { return specifier; };
	      return p;
	    }
	  };
	}

	var pads = {"-": "", "_": " ", "0": "0"},
	    numberRe = /^\s*\d+/, // note: ignores next directive
	    percentRe = /^%/,
	    requoteRe = /[\\^$*+?|[\]().{}]/g;

	function pad(value, fill, width) {
	  var sign = value < 0 ? "-" : "",
	      string = (sign ? -value : value) + "",
	      length = string.length;
	  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	}

	function requote(s) {
	  return s.replace(requoteRe, "\\$&");
	}

	function formatRe(names) {
	  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	}

	function formatLookup(names) {
	  var map = {}, i = -1, n = names.length;
	  while (++i < n) map[names[i].toLowerCase()] = i;
	  return map;
	}

	function parseWeekdayNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.w = +n[0], i + n[0].length) : -1;
	}

	function parseWeekdayNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.u = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.U = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberISO(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.V = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.W = +n[0], i + n[0].length) : -1;
	}

	function parseFullYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 4));
	  return n ? (d.y = +n[0], i + n[0].length) : -1;
	}

	function parseYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	}

	function parseZone(d, string, i) {
	  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	}

	function parseQuarter(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
	}

	function parseMonthNumber(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	}

	function parseDayOfMonth(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.d = +n[0], i + n[0].length) : -1;
	}

	function parseDayOfYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	}

	function parseHour24(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.H = +n[0], i + n[0].length) : -1;
	}

	function parseMinutes(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.M = +n[0], i + n[0].length) : -1;
	}

	function parseSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.S = +n[0], i + n[0].length) : -1;
	}

	function parseMilliseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.L = +n[0], i + n[0].length) : -1;
	}

	function parseMicroseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 6));
	  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
	}

	function parseLiteralPercent(d, string, i) {
	  var n = percentRe.exec(string.slice(i, i + 1));
	  return n ? i + n[0].length : -1;
	}

	function parseUnixTimestamp(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = +n[0], i + n[0].length) : -1;
	}

	function parseUnixTimestampSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.s = +n[0], i + n[0].length) : -1;
	}

	function formatDayOfMonth(d, p) {
	  return pad(d.getDate(), p, 2);
	}

	function formatHour24(d, p) {
	  return pad(d.getHours(), p, 2);
	}

	function formatHour12(d, p) {
	  return pad(d.getHours() % 12 || 12, p, 2);
	}

	function formatDayOfYear(d, p) {
	  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
	}

	function formatMilliseconds(d, p) {
	  return pad(d.getMilliseconds(), p, 3);
	}

	function formatMicroseconds(d, p) {
	  return formatMilliseconds(d, p) + "000";
	}

	function formatMonthNumber(d, p) {
	  return pad(d.getMonth() + 1, p, 2);
	}

	function formatMinutes(d, p) {
	  return pad(d.getMinutes(), p, 2);
	}

	function formatSeconds(d, p) {
	  return pad(d.getSeconds(), p, 2);
	}

	function formatWeekdayNumberMonday(d) {
	  var day = d.getDay();
	  return day === 0 ? 7 : day;
	}

	function formatWeekNumberSunday(d, p) {
	  return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
	}

	function formatWeekNumberISO(d, p) {
	  var day = d.getDay();
	  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
	  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
	}

	function formatWeekdayNumberSunday(d) {
	  return d.getDay();
	}

	function formatWeekNumberMonday(d, p) {
	  return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
	}

	function formatYear(d, p) {
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatFullYear(d, p) {
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatZone(d) {
	  var z = d.getTimezoneOffset();
	  return (z > 0 ? "-" : (z *= -1, "+"))
	      + pad(z / 60 | 0, "0", 2)
	      + pad(z % 60, "0", 2);
	}

	function formatUTCDayOfMonth(d, p) {
	  return pad(d.getUTCDate(), p, 2);
	}

	function formatUTCHour24(d, p) {
	  return pad(d.getUTCHours(), p, 2);
	}

	function formatUTCHour12(d, p) {
	  return pad(d.getUTCHours() % 12 || 12, p, 2);
	}

	function formatUTCDayOfYear(d, p) {
	  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
	}

	function formatUTCMilliseconds(d, p) {
	  return pad(d.getUTCMilliseconds(), p, 3);
	}

	function formatUTCMicroseconds(d, p) {
	  return formatUTCMilliseconds(d, p) + "000";
	}

	function formatUTCMonthNumber(d, p) {
	  return pad(d.getUTCMonth() + 1, p, 2);
	}

	function formatUTCMinutes(d, p) {
	  return pad(d.getUTCMinutes(), p, 2);
	}

	function formatUTCSeconds(d, p) {
	  return pad(d.getUTCSeconds(), p, 2);
	}

	function formatUTCWeekdayNumberMonday(d) {
	  var dow = d.getUTCDay();
	  return dow === 0 ? 7 : dow;
	}

	function formatUTCWeekNumberSunday(d, p) {
	  return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
	}

	function formatUTCWeekNumberISO(d, p) {
	  var day = d.getUTCDay();
	  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
	  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
	}

	function formatUTCWeekdayNumberSunday(d) {
	  return d.getUTCDay();
	}

	function formatUTCWeekNumberMonday(d, p) {
	  return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
	}

	function formatUTCYear(d, p) {
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCFullYear(d, p) {
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCZone() {
	  return "+0000";
	}

	function formatLiteralPercent() {
	  return "%";
	}

	function formatUnixTimestamp(d) {
	  return +d;
	}

	function formatUnixTimestampSeconds(d) {
	  return Math.floor(+d / 1000);
	}

	var locale;

	defaultLocale({
	  dateTime: "%x, %X",
	  date: "%-m/%-d/%Y",
	  time: "%-I:%M:%S %p",
	  periods: ["AM", "PM"],
	  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  exports.timeFormat = locale.format;
	  exports.timeParse = locale.parse;
	  exports.utcFormat = locale.utcFormat;
	  exports.utcParse = locale.utcParse;
	  return locale;
	}

	var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

	function formatIsoNative(date) {
	  return date.toISOString();
	}

	var formatIso = Date.prototype.toISOString
	    ? formatIsoNative
	    : exports.utcFormat(isoSpecifier);

	function parseIsoNative(string) {
	  var date = new Date(string);
	  return isNaN(date) ? null : date;
	}

	var parseIso = +new Date("2000-01-01T00:00:00.000Z")
	    ? parseIsoNative
	    : exports.utcParse(isoSpecifier);

	exports.isoFormat = formatIso;
	exports.isoParse = parseIso;
	exports.timeFormatDefaultLocale = defaultLocale;
	exports.timeFormatLocale = formatLocale;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale-chromatic/ v1.5.0 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(12), __webpack_require__(13)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
	}(this, function (exports, d3Interpolate, d3Color) { 'use strict';

	function colors(specifier) {
	  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
	  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
	  return colors;
	}

	var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

	var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

	var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

	var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

	var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

	var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

	var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

	var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

	var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

	var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

	function ramp(scheme) {
	  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
	}

	var scheme = new Array(3).concat(
	  "d8b365f5f5f55ab4ac",
	  "a6611adfc27d80cdc1018571",
	  "a6611adfc27df5f5f580cdc1018571",
	  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
	  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
	  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
	  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
	  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
	  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
	).map(colors);

	var BrBG = ramp(scheme);

	var scheme$1 = new Array(3).concat(
	  "af8dc3f7f7f77fbf7b",
	  "7b3294c2a5cfa6dba0008837",
	  "7b3294c2a5cff7f7f7a6dba0008837",
	  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
	  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
	  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
	  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
	  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
	  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
	).map(colors);

	var PRGn = ramp(scheme$1);

	var scheme$2 = new Array(3).concat(
	  "e9a3c9f7f7f7a1d76a",
	  "d01c8bf1b6dab8e1864dac26",
	  "d01c8bf1b6daf7f7f7b8e1864dac26",
	  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
	  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
	  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
	  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
	  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
	  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
	).map(colors);

	var PiYG = ramp(scheme$2);

	var scheme$3 = new Array(3).concat(
	  "998ec3f7f7f7f1a340",
	  "5e3c99b2abd2fdb863e66101",
	  "5e3c99b2abd2f7f7f7fdb863e66101",
	  "542788998ec3d8daebfee0b6f1a340b35806",
	  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
	  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
	  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
	  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
	  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
	).map(colors);

	var PuOr = ramp(scheme$3);

	var scheme$4 = new Array(3).concat(
	  "ef8a62f7f7f767a9cf",
	  "ca0020f4a58292c5de0571b0",
	  "ca0020f4a582f7f7f792c5de0571b0",
	  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
	  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
	  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
	  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
	  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
	  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
	).map(colors);

	var RdBu = ramp(scheme$4);

	var scheme$5 = new Array(3).concat(
	  "ef8a62ffffff999999",
	  "ca0020f4a582bababa404040",
	  "ca0020f4a582ffffffbababa404040",
	  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
	  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
	  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
	  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
	  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
	  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
	).map(colors);

	var RdGy = ramp(scheme$5);

	var scheme$6 = new Array(3).concat(
	  "fc8d59ffffbf91bfdb",
	  "d7191cfdae61abd9e92c7bb6",
	  "d7191cfdae61ffffbfabd9e92c7bb6",
	  "d73027fc8d59fee090e0f3f891bfdb4575b4",
	  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
	  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
	  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
	  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
	  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
	).map(colors);

	var RdYlBu = ramp(scheme$6);

	var scheme$7 = new Array(3).concat(
	  "fc8d59ffffbf91cf60",
	  "d7191cfdae61a6d96a1a9641",
	  "d7191cfdae61ffffbfa6d96a1a9641",
	  "d73027fc8d59fee08bd9ef8b91cf601a9850",
	  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
	  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
	  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
	  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
	  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
	).map(colors);

	var RdYlGn = ramp(scheme$7);

	var scheme$8 = new Array(3).concat(
	  "fc8d59ffffbf99d594",
	  "d7191cfdae61abdda42b83ba",
	  "d7191cfdae61ffffbfabdda42b83ba",
	  "d53e4ffc8d59fee08be6f59899d5943288bd",
	  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
	  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
	  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
	  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
	  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
	).map(colors);

	var Spectral = ramp(scheme$8);

	var scheme$9 = new Array(3).concat(
	  "e5f5f999d8c92ca25f",
	  "edf8fbb2e2e266c2a4238b45",
	  "edf8fbb2e2e266c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
	).map(colors);

	var BuGn = ramp(scheme$9);

	var scheme$a = new Array(3).concat(
	  "e0ecf49ebcda8856a7",
	  "edf8fbb3cde38c96c688419d",
	  "edf8fbb3cde38c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
	).map(colors);

	var BuPu = ramp(scheme$a);

	var scheme$b = new Array(3).concat(
	  "e0f3dba8ddb543a2ca",
	  "f0f9e8bae4bc7bccc42b8cbe",
	  "f0f9e8bae4bc7bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
	).map(colors);

	var GnBu = ramp(scheme$b);

	var scheme$c = new Array(3).concat(
	  "fee8c8fdbb84e34a33",
	  "fef0d9fdcc8afc8d59d7301f",
	  "fef0d9fdcc8afc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
	).map(colors);

	var OrRd = ramp(scheme$c);

	var scheme$d = new Array(3).concat(
	  "ece2f0a6bddb1c9099",
	  "f6eff7bdc9e167a9cf02818a",
	  "f6eff7bdc9e167a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
	).map(colors);

	var PuBuGn = ramp(scheme$d);

	var scheme$e = new Array(3).concat(
	  "ece7f2a6bddb2b8cbe",
	  "f1eef6bdc9e174a9cf0570b0",
	  "f1eef6bdc9e174a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
	).map(colors);

	var PuBu = ramp(scheme$e);

	var scheme$f = new Array(3).concat(
	  "e7e1efc994c7dd1c77",
	  "f1eef6d7b5d8df65b0ce1256",
	  "f1eef6d7b5d8df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
	).map(colors);

	var PuRd = ramp(scheme$f);

	var scheme$g = new Array(3).concat(
	  "fde0ddfa9fb5c51b8a",
	  "feebe2fbb4b9f768a1ae017e",
	  "feebe2fbb4b9f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
	).map(colors);

	var RdPu = ramp(scheme$g);

	var scheme$h = new Array(3).concat(
	  "edf8b17fcdbb2c7fb8",
	  "ffffcca1dab441b6c4225ea8",
	  "ffffcca1dab441b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
	).map(colors);

	var YlGnBu = ramp(scheme$h);

	var scheme$i = new Array(3).concat(
	  "f7fcb9addd8e31a354",
	  "ffffccc2e69978c679238443",
	  "ffffccc2e69978c67931a354006837",
	  "ffffccd9f0a3addd8e78c67931a354006837",
	  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
	).map(colors);

	var YlGn = ramp(scheme$i);

	var scheme$j = new Array(3).concat(
	  "fff7bcfec44fd95f0e",
	  "ffffd4fed98efe9929cc4c02",
	  "ffffd4fed98efe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
	).map(colors);

	var YlOrBr = ramp(scheme$j);

	var scheme$k = new Array(3).concat(
	  "ffeda0feb24cf03b20",
	  "ffffb2fecc5cfd8d3ce31a1c",
	  "ffffb2fecc5cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
	).map(colors);

	var YlOrRd = ramp(scheme$k);

	var scheme$l = new Array(3).concat(
	  "deebf79ecae13182bd",
	  "eff3ffbdd7e76baed62171b5",
	  "eff3ffbdd7e76baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
	).map(colors);

	var Blues = ramp(scheme$l);

	var scheme$m = new Array(3).concat(
	  "e5f5e0a1d99b31a354",
	  "edf8e9bae4b374c476238b45",
	  "edf8e9bae4b374c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
	).map(colors);

	var Greens = ramp(scheme$m);

	var scheme$n = new Array(3).concat(
	  "f0f0f0bdbdbd636363",
	  "f7f7f7cccccc969696525252",
	  "f7f7f7cccccc969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
	).map(colors);

	var Greys = ramp(scheme$n);

	var scheme$o = new Array(3).concat(
	  "efedf5bcbddc756bb1",
	  "f2f0f7cbc9e29e9ac86a51a3",
	  "f2f0f7cbc9e29e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
	).map(colors);

	var Purples = ramp(scheme$o);

	var scheme$p = new Array(3).concat(
	  "fee0d2fc9272de2d26",
	  "fee5d9fcae91fb6a4acb181d",
	  "fee5d9fcae91fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
	).map(colors);

	var Reds = ramp(scheme$p);

	var scheme$q = new Array(3).concat(
	  "fee6cefdae6be6550d",
	  "feeddefdbe85fd8d3cd94701",
	  "feeddefdbe85fd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
	).map(colors);

	var Oranges = ramp(scheme$q);

	function cividis(t) {
	  t = Math.max(0, Math.min(1, t));
	  return "rgb("
	      + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
	      + ")";
	}

	var cubehelix = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

	var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	var c = d3Color.cubehelix();

	function rainbow(t) {
	  if (t < 0 || t > 1) t -= Math.floor(t);
	  var ts = Math.abs(t - 0.5);
	  c.h = 360 * t - 100;
	  c.s = 1.5 - 1.5 * ts;
	  c.l = 0.8 - 0.9 * ts;
	  return c + "";
	}

	var c$1 = d3Color.rgb(),
	    pi_1_3 = Math.PI / 3,
	    pi_2_3 = Math.PI * 2 / 3;

	function sinebow(t) {
	  var x;
	  t = (0.5 - t) * Math.PI;
	  c$1.r = 255 * (x = Math.sin(t)) * x;
	  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
	  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
	  return c$1 + "";
	}

	function turbo(t) {
	  t = Math.max(0, Math.min(1, t));
	  return "rgb("
	      + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
	      + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
	      + ")";
	}

	function ramp$1(range) {
	  var n = range.length;
	  return function(t) {
	    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	  };
	}

	var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

	var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

	var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

	var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

	exports.interpolateBlues = Blues;
	exports.interpolateBrBG = BrBG;
	exports.interpolateBuGn = BuGn;
	exports.interpolateBuPu = BuPu;
	exports.interpolateCividis = cividis;
	exports.interpolateCool = cool;
	exports.interpolateCubehelixDefault = cubehelix;
	exports.interpolateGnBu = GnBu;
	exports.interpolateGreens = Greens;
	exports.interpolateGreys = Greys;
	exports.interpolateInferno = inferno;
	exports.interpolateMagma = magma;
	exports.interpolateOrRd = OrRd;
	exports.interpolateOranges = Oranges;
	exports.interpolatePRGn = PRGn;
	exports.interpolatePiYG = PiYG;
	exports.interpolatePlasma = plasma;
	exports.interpolatePuBu = PuBu;
	exports.interpolatePuBuGn = PuBuGn;
	exports.interpolatePuOr = PuOr;
	exports.interpolatePuRd = PuRd;
	exports.interpolatePurples = Purples;
	exports.interpolateRainbow = rainbow;
	exports.interpolateRdBu = RdBu;
	exports.interpolateRdGy = RdGy;
	exports.interpolateRdPu = RdPu;
	exports.interpolateRdYlBu = RdYlBu;
	exports.interpolateRdYlGn = RdYlGn;
	exports.interpolateReds = Reds;
	exports.interpolateSinebow = sinebow;
	exports.interpolateSpectral = Spectral;
	exports.interpolateTurbo = turbo;
	exports.interpolateViridis = viridis;
	exports.interpolateWarm = warm;
	exports.interpolateYlGn = YlGn;
	exports.interpolateYlGnBu = YlGnBu;
	exports.interpolateYlOrBr = YlOrBr;
	exports.interpolateYlOrRd = YlOrRd;
	exports.schemeAccent = Accent;
	exports.schemeBlues = scheme$l;
	exports.schemeBrBG = scheme;
	exports.schemeBuGn = scheme$9;
	exports.schemeBuPu = scheme$a;
	exports.schemeCategory10 = category10;
	exports.schemeDark2 = Dark2;
	exports.schemeGnBu = scheme$b;
	exports.schemeGreens = scheme$m;
	exports.schemeGreys = scheme$n;
	exports.schemeOrRd = scheme$c;
	exports.schemeOranges = scheme$q;
	exports.schemePRGn = scheme$1;
	exports.schemePaired = Paired;
	exports.schemePastel1 = Pastel1;
	exports.schemePastel2 = Pastel2;
	exports.schemePiYG = scheme$2;
	exports.schemePuBu = scheme$e;
	exports.schemePuBuGn = scheme$d;
	exports.schemePuOr = scheme$3;
	exports.schemePuRd = scheme$f;
	exports.schemePurples = scheme$o;
	exports.schemeRdBu = scheme$4;
	exports.schemeRdGy = scheme$5;
	exports.schemeRdPu = scheme$g;
	exports.schemeRdYlBu = scheme$6;
	exports.schemeRdYlGn = scheme$7;
	exports.schemeReds = scheme$p;
	exports.schemeSet1 = Set1;
	exports.schemeSet2 = Set2;
	exports.schemeSet3 = Set3;
	exports.schemeSpectral = scheme$8;
	exports.schemeTableau10 = Tableau10;
	exports.schemeYlGn = scheme$i;
	exports.schemeYlGnBu = scheme$h;
	exports.schemeYlOrBr = scheme$j;
	exports.schemeYlOrRd = scheme$k;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-shape/ v1.3.7 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(18)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
	}(this, function (exports, d3Path) { 'use strict';

	function constant(x) {
	  return function constant() {
	    return x;
	  };
	}

	var abs = Math.abs;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var max = Math.max;
	var min = Math.min;
	var sin = Math.sin;
	var sqrt = Math.sqrt;

	var epsilon = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau = 2 * pi;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
	}

	function arcInnerRadius(d) {
	  return d.innerRadius;
	}

	function arcOuterRadius(d) {
	  return d.outerRadius;
	}

	function arcStartAngle(d) {
	  return d.startAngle;
	}

	function arcEndAngle(d) {
	  return d.endAngle;
	}

	function arcPadAngle(d) {
	  return d && d.padAngle; // Note: optional!
	}

	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	  var x10 = x1 - x0, y10 = y1 - y0,
	      x32 = x3 - x2, y32 = y3 - y2,
	      t = y32 * x10 - x32 * y10;
	  if (t * t < epsilon) return;
	  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
	  return [x0 + t * x10, y0 + t * y10];
	}

	// Compute perpendicular offset line of length rc.
	// http://mathworld.wolfram.com/Circle-LineIntersection.html
	function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
	  var x01 = x0 - x1,
	      y01 = y0 - y1,
	      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
	      ox = lo * y01,
	      oy = -lo * x01,
	      x11 = x0 + ox,
	      y11 = y0 + oy,
	      x10 = x1 + ox,
	      y10 = y1 + oy,
	      x00 = (x11 + x10) / 2,
	      y00 = (y11 + y10) / 2,
	      dx = x10 - x11,
	      dy = y10 - y11,
	      d2 = dx * dx + dy * dy,
	      r = r1 - rc,
	      D = x11 * y10 - x10 * y11,
	      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
	      cx0 = (D * dy - dx * d) / d2,
	      cy0 = (-D * dx - dy * d) / d2,
	      cx1 = (D * dy + dx * d) / d2,
	      cy1 = (-D * dx + dy * d) / d2,
	      dx0 = cx0 - x00,
	      dy0 = cy0 - y00,
	      dx1 = cx1 - x00,
	      dy1 = cy1 - y00;

	  // Pick the closer of the two intersection points.
	  // TODO Is there a faster way to determine which intersection to use?
	  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

	  return {
	    cx: cx0,
	    cy: cy0,
	    x01: -ox,
	    y01: -oy,
	    x11: cx0 * (r1 / r - 1),
	    y11: cy0 * (r1 / r - 1)
	  };
	}

	function arc() {
	  var innerRadius = arcInnerRadius,
	      outerRadius = arcOuterRadius,
	      cornerRadius = constant(0),
	      padRadius = null,
	      startAngle = arcStartAngle,
	      endAngle = arcEndAngle,
	      padAngle = arcPadAngle,
	      context = null;

	  function arc() {
	    var buffer,
	        r,
	        r0 = +innerRadius.apply(this, arguments),
	        r1 = +outerRadius.apply(this, arguments),
	        a0 = startAngle.apply(this, arguments) - halfPi,
	        a1 = endAngle.apply(this, arguments) - halfPi,
	        da = abs(a1 - a0),
	        cw = a1 > a0;

	    if (!context) context = buffer = d3Path.path();

	    // Ensure that the outer radius is always larger than the inner radius.
	    if (r1 < r0) r = r1, r1 = r0, r0 = r;

	    // Is it a point?
	    if (!(r1 > epsilon)) context.moveTo(0, 0);

	    // Or is it a circle or annulus?
	    else if (da > tau - epsilon) {
	      context.moveTo(r1 * cos(a0), r1 * sin(a0));
	      context.arc(0, 0, r1, a0, a1, !cw);
	      if (r0 > epsilon) {
	        context.moveTo(r0 * cos(a1), r0 * sin(a1));
	        context.arc(0, 0, r0, a1, a0, cw);
	      }
	    }

	    // Or is it a circular or annular sector?
	    else {
	      var a01 = a0,
	          a11 = a1,
	          a00 = a0,
	          a10 = a1,
	          da0 = da,
	          da1 = da,
	          ap = padAngle.apply(this, arguments) / 2,
	          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
	          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
	          rc0 = rc,
	          rc1 = rc,
	          t0,
	          t1;

	      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
	      if (rp > epsilon) {
	        var p0 = asin(rp / r0 * sin(ap)),
	            p1 = asin(rp / r1 * sin(ap));
	        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
	        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
	        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
	        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
	      }

	      var x01 = r1 * cos(a01),
	          y01 = r1 * sin(a01),
	          x10 = r0 * cos(a10),
	          y10 = r0 * sin(a10);

	      // Apply rounded corners?
	      if (rc > epsilon) {
	        var x11 = r1 * cos(a11),
	            y11 = r1 * sin(a11),
	            x00 = r0 * cos(a00),
	            y00 = r0 * sin(a00),
	            oc;

	        // Restrict the corner radius according to the sector angle.
	        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
	          var ax = x01 - oc[0],
	              ay = y01 - oc[1],
	              bx = x11 - oc[0],
	              by = y11 - oc[1],
	              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
	              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = min(rc, (r0 - lc) / (kc - 1));
	          rc1 = min(rc, (r1 - lc) / (kc + 1));
	        }
	      }

	      // Is the sector collapsed to a line?
	      if (!(da1 > epsilon)) context.moveTo(x01, y01);

	      // Does the sector’s outer ring have rounded corners?
	      else if (rc1 > epsilon) {
	        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
	        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

	        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
	          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the outer ring just a circular arc?
	      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

	      // Is there no inner ring, and it’s a circular sector?
	      // Or perhaps it’s an annular sector collapsed due to padding?
	      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

	      // Does the sector’s inner ring (or point) have rounded corners?
	      else if (rc0 > epsilon) {
	        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
	        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

	        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
	          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the inner ring just a circular arc?
	      else context.arc(0, 0, r0, a10, a00, cw);
	    }

	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  arc.centroid = function() {
	    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
	        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
	    return [cos(a) * r, sin(a) * r];
	  };

	  arc.innerRadius = function(_) {
	    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
	  };

	  arc.outerRadius = function(_) {
	    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
	  };

	  arc.cornerRadius = function(_) {
	    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
	  };

	  arc.padRadius = function(_) {
	    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
	  };

	  arc.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
	  };

	  arc.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
	  };

	  arc.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
	  };

	  arc.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
	  };

	  return arc;
	}

	function Linear(context) {
	  this._context = context;
	}

	Linear.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: this._context.lineTo(x, y); break;
	    }
	  }
	};

	function curveLinear(context) {
	  return new Linear(context);
	}

	function x(p) {
	  return p[0];
	}

	function y(p) {
	  return p[1];
	}

	function line() {
	  var x$1 = x,
	      y$1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function line(data) {
	    var i,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer;

	    if (context == null) output = curve(buffer = d3Path.path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) output.lineStart();
	        else output.lineEnd();
	      }
	      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  line.x = function(_) {
	    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
	  };

	  line.y = function(_) {
	    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
	  };

	  line.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
	  };

	  line.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	  };

	  line.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	  };

	  return line;
	}

	function area() {
	  var x0 = x,
	      x1 = null,
	      y0 = constant(0),
	      y1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function area(data) {
	    var i,
	        j,
	        k,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer,
	        x0z = new Array(n),
	        y0z = new Array(n);

	    if (context == null) output = curve(buffer = d3Path.path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) {
	          j = i;
	          output.areaStart();
	          output.lineStart();
	        } else {
	          output.lineEnd();
	          output.lineStart();
	          for (k = i - 1; k >= j; --k) {
	            output.point(x0z[k], y0z[k]);
	          }
	          output.lineEnd();
	          output.areaEnd();
	        }
	      }
	      if (defined0) {
	        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
	        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
	      }
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  function arealine() {
	    return line().defined(defined).curve(curve).context(context);
	  }

	  area.x = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
	  };

	  area.x0 = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
	  };

	  area.x1 = function(_) {
	    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
	  };

	  area.y = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
	  };

	  area.y0 = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
	  };

	  area.y1 = function(_) {
	    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
	  };

	  area.lineX0 =
	  area.lineY0 = function() {
	    return arealine().x(x0).y(y0);
	  };

	  area.lineY1 = function() {
	    return arealine().x(x0).y(y1);
	  };

	  area.lineX1 = function() {
	    return arealine().x(x1).y(y0);
	  };

	  area.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
	  };

	  area.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	  };

	  area.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	  };

	  return area;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function identity(d) {
	  return d;
	}

	function pie() {
	  var value = identity,
	      sortValues = descending,
	      sort = null,
	      startAngle = constant(0),
	      endAngle = constant(tau),
	      padAngle = constant(0);

	  function pie(data) {
	    var i,
	        n = data.length,
	        j,
	        k,
	        sum = 0,
	        index = new Array(n),
	        arcs = new Array(n),
	        a0 = +startAngle.apply(this, arguments),
	        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
	        a1,
	        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
	        pa = p * (da < 0 ? -1 : 1),
	        v;

	    for (i = 0; i < n; ++i) {
	      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
	        sum += v;
	      }
	    }

	    // Optionally sort the arcs by previously-computed values or by data.
	    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
	    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

	    // Compute the arcs! They are stored in the original data's order.
	    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
	      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
	        data: data[j],
	        index: i,
	        value: v,
	        startAngle: a0,
	        endAngle: a1,
	        padAngle: p
	      };
	    }

	    return arcs;
	  }

	  pie.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
	  };

	  pie.sortValues = function(_) {
	    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
	  };

	  pie.sort = function(_) {
	    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
	  };

	  pie.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
	  };

	  pie.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
	  };

	  pie.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
	  };

	  return pie;
	}

	var curveRadialLinear = curveRadial(curveLinear);

	function Radial(curve) {
	  this._curve = curve;
	}

	Radial.prototype = {
	  areaStart: function() {
	    this._curve.areaStart();
	  },
	  areaEnd: function() {
	    this._curve.areaEnd();
	  },
	  lineStart: function() {
	    this._curve.lineStart();
	  },
	  lineEnd: function() {
	    this._curve.lineEnd();
	  },
	  point: function(a, r) {
	    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
	  }
	};

	function curveRadial(curve) {

	  function radial(context) {
	    return new Radial(curve(context));
	  }

	  radial._curve = curve;

	  return radial;
	}

	function lineRadial(l) {
	  var c = l.curve;

	  l.angle = l.x, delete l.x;
	  l.radius = l.y, delete l.y;

	  l.curve = function(_) {
	    return arguments.length ? c(curveRadial(_)) : c()._curve;
	  };

	  return l;
	}

	function lineRadial$1() {
	  return lineRadial(line().curve(curveRadialLinear));
	}

	function areaRadial() {
	  var a = area().curve(curveRadialLinear),
	      c = a.curve,
	      x0 = a.lineX0,
	      x1 = a.lineX1,
	      y0 = a.lineY0,
	      y1 = a.lineY1;

	  a.angle = a.x, delete a.x;
	  a.startAngle = a.x0, delete a.x0;
	  a.endAngle = a.x1, delete a.x1;
	  a.radius = a.y, delete a.y;
	  a.innerRadius = a.y0, delete a.y0;
	  a.outerRadius = a.y1, delete a.y1;
	  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
	  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
	  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
	  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

	  a.curve = function(_) {
	    return arguments.length ? c(curveRadial(_)) : c()._curve;
	  };

	  return a;
	}

	function pointRadial(x, y) {
	  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
	}

	var slice = Array.prototype.slice;

	function linkSource(d) {
	  return d.source;
	}

	function linkTarget(d) {
	  return d.target;
	}

	function link(curve) {
	  var source = linkSource,
	      target = linkTarget,
	      x$1 = x,
	      y$1 = y,
	      context = null;

	  function link() {
	    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
	    if (!context) context = buffer = d3Path.path();
	    curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
	    if (buffer) return context = null, buffer + "" || null;
	  }

	  link.source = function(_) {
	    return arguments.length ? (source = _, link) : source;
	  };

	  link.target = function(_) {
	    return arguments.length ? (target = _, link) : target;
	  };

	  link.x = function(_) {
	    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link) : x$1;
	  };

	  link.y = function(_) {
	    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link) : y$1;
	  };

	  link.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), link) : context;
	  };

	  return link;
	}

	function curveHorizontal(context, x0, y0, x1, y1) {
	  context.moveTo(x0, y0);
	  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
	}

	function curveVertical(context, x0, y0, x1, y1) {
	  context.moveTo(x0, y0);
	  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
	}

	function curveRadial$1(context, x0, y0, x1, y1) {
	  var p0 = pointRadial(x0, y0),
	      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
	      p2 = pointRadial(x1, y0),
	      p3 = pointRadial(x1, y1);
	  context.moveTo(p0[0], p0[1]);
	  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
	}

	function linkHorizontal() {
	  return link(curveHorizontal);
	}

	function linkVertical() {
	  return link(curveVertical);
	}

	function linkRadial() {
	  var l = link(curveRadial$1);
	  l.angle = l.x, delete l.x;
	  l.radius = l.y, delete l.y;
	  return l;
	}

	var circle = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / pi);
	    context.moveTo(r, 0);
	    context.arc(0, 0, r, 0, tau);
	  }
	};

	var cross = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / 5) / 2;
	    context.moveTo(-3 * r, -r);
	    context.lineTo(-r, -r);
	    context.lineTo(-r, -3 * r);
	    context.lineTo(r, -3 * r);
	    context.lineTo(r, -r);
	    context.lineTo(3 * r, -r);
	    context.lineTo(3 * r, r);
	    context.lineTo(r, r);
	    context.lineTo(r, 3 * r);
	    context.lineTo(-r, 3 * r);
	    context.lineTo(-r, r);
	    context.lineTo(-3 * r, r);
	    context.closePath();
	  }
	};

	var tan30 = Math.sqrt(1 / 3),
	    tan30_2 = tan30 * 2;

	var diamond = {
	  draw: function(context, size) {
	    var y = Math.sqrt(size / tan30_2),
	        x = y * tan30;
	    context.moveTo(0, -y);
	    context.lineTo(x, 0);
	    context.lineTo(0, y);
	    context.lineTo(-x, 0);
	    context.closePath();
	  }
	};

	var ka = 0.89081309152928522810,
	    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
	    kx = Math.sin(tau / 10) * kr,
	    ky = -Math.cos(tau / 10) * kr;

	var star = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size * ka),
	        x = kx * r,
	        y = ky * r;
	    context.moveTo(0, -r);
	    context.lineTo(x, y);
	    for (var i = 1; i < 5; ++i) {
	      var a = tau * i / 5,
	          c = Math.cos(a),
	          s = Math.sin(a);
	      context.lineTo(s * r, -c * r);
	      context.lineTo(c * x - s * y, s * x + c * y);
	    }
	    context.closePath();
	  }
	};

	var square = {
	  draw: function(context, size) {
	    var w = Math.sqrt(size),
	        x = -w / 2;
	    context.rect(x, x, w, w);
	  }
	};

	var sqrt3 = Math.sqrt(3);

	var triangle = {
	  draw: function(context, size) {
	    var y = -Math.sqrt(size / (sqrt3 * 3));
	    context.moveTo(0, y * 2);
	    context.lineTo(-sqrt3 * y, -y);
	    context.lineTo(sqrt3 * y, -y);
	    context.closePath();
	  }
	};

	var c = -0.5,
	    s = Math.sqrt(3) / 2,
	    k = 1 / Math.sqrt(12),
	    a = (k / 2 + 1) * 3;

	var wye = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / a),
	        x0 = r / 2,
	        y0 = r * k,
	        x1 = x0,
	        y1 = r * k + r,
	        x2 = -x1,
	        y2 = y1;
	    context.moveTo(x0, y0);
	    context.lineTo(x1, y1);
	    context.lineTo(x2, y2);
	    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	    context.closePath();
	  }
	};

	var symbols = [
	  circle,
	  cross,
	  diamond,
	  square,
	  star,
	  triangle,
	  wye
	];

	function symbol() {
	  var type = constant(circle),
	      size = constant(64),
	      context = null;

	  function symbol() {
	    var buffer;
	    if (!context) context = buffer = d3Path.path();
	    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
	    if (buffer) return context = null, buffer + "" || null;
	  }

	  symbol.type = function(_) {
	    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
	  };

	  symbol.size = function(_) {
	    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
	  };

	  symbol.context = function(_) {
	    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	  };

	  return symbol;
	}

	function noop() {}

	function point(that, x, y) {
	  that._context.bezierCurveTo(
	    (2 * that._x0 + that._x1) / 3,
	    (2 * that._y0 + that._y1) / 3,
	    (that._x0 + 2 * that._x1) / 3,
	    (that._y0 + 2 * that._y1) / 3,
	    (that._x0 + 4 * that._x1 + x) / 6,
	    (that._y0 + 4 * that._y1 + y) / 6
	  );
	}

	function Basis(context) {
	  this._context = context;
	}

	Basis.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 3: point(this, this._x1, this._y1); // proceed
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function basis(context) {
	  return new Basis(context);
	}

	function BasisClosed(context) {
	  this._context = context;
	}

	BasisClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x2, this._y2);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
	        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x2, this._y2);
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
	      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
	      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function basisClosed(context) {
	  return new BasisClosed(context);
	}

	function BasisOpen(context) {
	  this._context = context;
	}

	BasisOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
	      case 3: this._point = 4; // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function basisOpen(context) {
	  return new BasisOpen(context);
	}

	function Bundle(context, beta) {
	  this._basis = new Basis(context);
	  this._beta = beta;
	}

	Bundle.prototype = {
	  lineStart: function() {
	    this._x = [];
	    this._y = [];
	    this._basis.lineStart();
	  },
	  lineEnd: function() {
	    var x = this._x,
	        y = this._y,
	        j = x.length - 1;

	    if (j > 0) {
	      var x0 = x[0],
	          y0 = y[0],
	          dx = x[j] - x0,
	          dy = y[j] - y0,
	          i = -1,
	          t;

	      while (++i <= j) {
	        t = i / j;
	        this._basis.point(
	          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
	          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
	        );
	      }
	    }

	    this._x = this._y = null;
	    this._basis.lineEnd();
	  },
	  point: function(x, y) {
	    this._x.push(+x);
	    this._y.push(+y);
	  }
	};

	var bundle = (function custom(beta) {

	  function bundle(context) {
	    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
	  }

	  bundle.beta = function(beta) {
	    return custom(+beta);
	  };

	  return bundle;
	})(0.85);

	function point$1(that, x, y) {
	  that._context.bezierCurveTo(
	    that._x1 + that._k * (that._x2 - that._x0),
	    that._y1 + that._k * (that._y2 - that._y0),
	    that._x2 + that._k * (that._x1 - x),
	    that._y2 + that._k * (that._y1 - y),
	    that._x2,
	    that._y2
	  );
	}

	function Cardinal(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	Cardinal.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x2, this._y2); break;
	      case 3: point$1(this, this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
	      case 2: this._point = 3; // proceed
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinal = (function custom(tension) {

	  function cardinal(context) {
	    return new Cardinal(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	})(0);

	function CardinalClosed(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	CardinalClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.lineTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        this.point(this._x5, this._y5);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinalClosed = (function custom(tension) {

	  function cardinal(context) {
	    return new CardinalClosed(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	})(0);

	function CardinalOpen(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	CardinalOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	      case 3: this._point = 4; // proceed
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinalOpen = (function custom(tension) {

	  function cardinal(context) {
	    return new CardinalOpen(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	})(0);

	function point$2(that, x, y) {
	  var x1 = that._x1,
	      y1 = that._y1,
	      x2 = that._x2,
	      y2 = that._y2;

	  if (that._l01_a > epsilon) {
	    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
	        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
	    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
	    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
	  }

	  if (that._l23_a > epsilon) {
	    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
	        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
	    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
	    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
	  }

	  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
	}

	function CatmullRom(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRom.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x2, this._y2); break;
	      case 3: this.point(this._x2, this._y2); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; // proceed
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRom = (function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	})(0.5);

	function CatmullRomClosed(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRomClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.lineTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        this.point(this._x5, this._y5);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRomClosed = (function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	})(0.5);

	function CatmullRomOpen(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRomOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	      case 3: this._point = 4; // proceed
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRomOpen = (function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	})(0.5);

	function LinearClosed(context) {
	  this._context = context;
	}

	LinearClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._point) this._context.closePath();
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    if (this._point) this._context.lineTo(x, y);
	    else this._point = 1, this._context.moveTo(x, y);
	  }
	};

	function linearClosed(context) {
	  return new LinearClosed(context);
	}

	function sign(x) {
	  return x < 0 ? -1 : 1;
	}

	// Calculate the slopes of the tangents (Hermite-type interpolation) based on
	// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
	// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
	// NOV(II), P. 443, 1990.
	function slope3(that, x2, y2) {
	  var h0 = that._x1 - that._x0,
	      h1 = x2 - that._x1,
	      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
	      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
	      p = (s0 * h1 + s1 * h0) / (h0 + h1);
	  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
	}

	// Calculate a one-sided slope.
	function slope2(that, t) {
	  var h = that._x1 - that._x0;
	  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
	}

	// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
	// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
	// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
	function point$3(that, t0, t1) {
	  var x0 = that._x0,
	      y0 = that._y0,
	      x1 = that._x1,
	      y1 = that._y1,
	      dx = (x1 - x0) / 3;
	  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
	}

	function MonotoneX(context) {
	  this._context = context;
	}

	MonotoneX.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 =
	    this._t0 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    var t1 = NaN;

	    x = +x, y = +y;
	    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
	      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
	    }

	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	    this._t0 = t1;
	  }
	};

	function MonotoneY(context) {
	  this._context = new ReflectContext(context);
	}

	(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
	  MonotoneX.prototype.point.call(this, y, x);
	};

	function ReflectContext(context) {
	  this._context = context;
	}

	ReflectContext.prototype = {
	  moveTo: function(x, y) { this._context.moveTo(y, x); },
	  closePath: function() { this._context.closePath(); },
	  lineTo: function(x, y) { this._context.lineTo(y, x); },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
	};

	function monotoneX(context) {
	  return new MonotoneX(context);
	}

	function monotoneY(context) {
	  return new MonotoneY(context);
	}

	function Natural(context) {
	  this._context = context;
	}

	Natural.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = [];
	    this._y = [];
	  },
	  lineEnd: function() {
	    var x = this._x,
	        y = this._y,
	        n = x.length;

	    if (n) {
	      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
	      if (n === 2) {
	        this._context.lineTo(x[1], y[1]);
	      } else {
	        var px = controlPoints(x),
	            py = controlPoints(y);
	        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
	          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
	        }
	      }
	    }

	    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	    this._x = this._y = null;
	  },
	  point: function(x, y) {
	    this._x.push(+x);
	    this._y.push(+y);
	  }
	};

	// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
	function controlPoints(x) {
	  var i,
	      n = x.length - 1,
	      m,
	      a = new Array(n),
	      b = new Array(n),
	      r = new Array(n);
	  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
	  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
	  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
	  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
	  a[n - 1] = r[n - 1] / b[n - 1];
	  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
	  b[n - 1] = (x[n] + a[n - 1]) / 2;
	  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
	  return [a, b];
	}

	function natural(context) {
	  return new Natural(context);
	}

	function Step(context, t) {
	  this._context = context;
	  this._t = t;
	}

	Step.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = this._y = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: {
	        if (this._t <= 0) {
	          this._context.lineTo(this._x, y);
	          this._context.lineTo(x, y);
	        } else {
	          var x1 = this._x * (1 - this._t) + x * this._t;
	          this._context.lineTo(x1, this._y);
	          this._context.lineTo(x1, y);
	        }
	        break;
	      }
	    }
	    this._x = x, this._y = y;
	  }
	};

	function step(context) {
	  return new Step(context, 0.5);
	}

	function stepBefore(context) {
	  return new Step(context, 0);
	}

	function stepAfter(context) {
	  return new Step(context, 1);
	}

	function none(series, order) {
	  if (!((n = series.length) > 1)) return;
	  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
	    s0 = s1, s1 = series[order[i]];
	    for (j = 0; j < m; ++j) {
	      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	    }
	  }
	}

	function none$1(series) {
	  var n = series.length, o = new Array(n);
	  while (--n >= 0) o[n] = n;
	  return o;
	}

	function stackValue(d, key) {
	  return d[key];
	}

	function stack() {
	  var keys = constant([]),
	      order = none$1,
	      offset = none,
	      value = stackValue;

	  function stack(data) {
	    var kz = keys.apply(this, arguments),
	        i,
	        m = data.length,
	        n = kz.length,
	        sz = new Array(n),
	        oz;

	    for (i = 0; i < n; ++i) {
	      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
	        si[j] = sij = [0, +value(data[j], ki, j, data)];
	        sij.data = data[j];
	      }
	      si.key = ki;
	    }

	    for (i = 0, oz = order(sz); i < n; ++i) {
	      sz[oz[i]].index = i;
	    }

	    offset(sz, oz);
	    return sz;
	  }

	  stack.keys = function(_) {
	    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
	  };

	  stack.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
	  };

	  stack.order = function(_) {
	    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
	  };

	  stack.offset = function(_) {
	    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
	  };

	  return stack;
	}

	function expand(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
	    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
	    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
	  }
	  none(series, order);
	}

	function diverging(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
	    for (yp = yn = 0, i = 0; i < n; ++i) {
	      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
	        d[0] = yp, d[1] = yp += dy;
	      } else if (dy < 0) {
	        d[1] = yn, d[0] = yn += dy;
	      } else {
	        d[0] = 0, d[1] = dy;
	      }
	    }
	  }
	}

	function silhouette(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
	    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
	    s0[j][1] += s0[j][0] = -y / 2;
	  }
	  none(series, order);
	}

	function wiggle(series, order) {
	  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
	    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
	      var si = series[order[i]],
	          sij0 = si[j][1] || 0,
	          sij1 = si[j - 1][1] || 0,
	          s3 = (sij0 - sij1) / 2;
	      for (var k = 0; k < i; ++k) {
	        var sk = series[order[k]],
	            skj0 = sk[j][1] || 0,
	            skj1 = sk[j - 1][1] || 0;
	        s3 += skj0 - skj1;
	      }
	      s1 += sij0, s2 += s3 * sij0;
	    }
	    s0[j - 1][1] += s0[j - 1][0] = y;
	    if (s1) y -= s2 / s1;
	  }
	  s0[j - 1][1] += s0[j - 1][0] = y;
	  none(series, order);
	}

	function appearance(series) {
	  var peaks = series.map(peak);
	  return none$1(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
	}

	function peak(series) {
	  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
	  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
	  return j;
	}

	function ascending(series) {
	  var sums = series.map(sum);
	  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
	}

	function sum(series) {
	  var s = 0, i = -1, n = series.length, v;
	  while (++i < n) if (v = +series[i][1]) s += v;
	  return s;
	}

	function descending$1(series) {
	  return ascending(series).reverse();
	}

	function insideOut(series) {
	  var n = series.length,
	      i,
	      j,
	      sums = series.map(sum),
	      order = appearance(series),
	      top = 0,
	      bottom = 0,
	      tops = [],
	      bottoms = [];

	  for (i = 0; i < n; ++i) {
	    j = order[i];
	    if (top < bottom) {
	      top += sums[j];
	      tops.push(j);
	    } else {
	      bottom += sums[j];
	      bottoms.push(j);
	    }
	  }

	  return bottoms.reverse().concat(tops);
	}

	function reverse(series) {
	  return none$1(series).reverse();
	}

	exports.arc = arc;
	exports.area = area;
	exports.areaRadial = areaRadial;
	exports.curveBasis = basis;
	exports.curveBasisClosed = basisClosed;
	exports.curveBasisOpen = basisOpen;
	exports.curveBundle = bundle;
	exports.curveCardinal = cardinal;
	exports.curveCardinalClosed = cardinalClosed;
	exports.curveCardinalOpen = cardinalOpen;
	exports.curveCatmullRom = catmullRom;
	exports.curveCatmullRomClosed = catmullRomClosed;
	exports.curveCatmullRomOpen = catmullRomOpen;
	exports.curveLinear = curveLinear;
	exports.curveLinearClosed = linearClosed;
	exports.curveMonotoneX = monotoneX;
	exports.curveMonotoneY = monotoneY;
	exports.curveNatural = natural;
	exports.curveStep = step;
	exports.curveStepAfter = stepAfter;
	exports.curveStepBefore = stepBefore;
	exports.line = line;
	exports.lineRadial = lineRadial$1;
	exports.linkHorizontal = linkHorizontal;
	exports.linkRadial = linkRadial;
	exports.linkVertical = linkVertical;
	exports.pie = pie;
	exports.pointRadial = pointRadial;
	exports.radialArea = areaRadial;
	exports.radialLine = lineRadial$1;
	exports.stack = stack;
	exports.stackOffsetDiverging = diverging;
	exports.stackOffsetExpand = expand;
	exports.stackOffsetNone = none;
	exports.stackOffsetSilhouette = silhouette;
	exports.stackOffsetWiggle = wiggle;
	exports.stackOrderAppearance = appearance;
	exports.stackOrderAscending = ascending;
	exports.stackOrderDescending = descending$1;
	exports.stackOrderInsideOut = insideOut;
	exports.stackOrderNone = none$1;
	exports.stackOrderReverse = reverse;
	exports.symbol = symbol;
	exports.symbolCircle = circle;
	exports.symbolCross = cross;
	exports.symbolDiamond = diamond;
	exports.symbolSquare = square;
	exports.symbolStar = star;
	exports.symbolTriangle = triangle;
	exports.symbolWye = wye;
	exports.symbols = symbols;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-voronoi/ v1.1.4 Copyright 2018 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function x(d) {
	  return d[0];
	}

	function y(d) {
	  return d[1];
	}

	function RedBlackTree() {
	  this._ = null; // root node
	}

	function RedBlackNode(node) {
	  node.U = // parent node
	  node.C = // color - true for red, false for black
	  node.L = // left node
	  node.R = // right node
	  node.P = // previous node
	  node.N = null; // next node
	}

	RedBlackTree.prototype = {
	  constructor: RedBlackTree,

	  insert: function(after, node) {
	    var parent, grandpa, uncle;

	    if (after) {
	      node.P = after;
	      node.N = after.N;
	      if (after.N) after.N.P = node;
	      after.N = node;
	      if (after.R) {
	        after = after.R;
	        while (after.L) after = after.L;
	        after.L = node;
	      } else {
	        after.R = node;
	      }
	      parent = after;
	    } else if (this._) {
	      after = RedBlackFirst(this._);
	      node.P = null;
	      node.N = after;
	      after.P = after.L = node;
	      parent = after;
	    } else {
	      node.P = node.N = null;
	      this._ = node;
	      parent = null;
	    }
	    node.L = node.R = null;
	    node.U = parent;
	    node.C = true;

	    after = node;
	    while (parent && parent.C) {
	      grandpa = parent.U;
	      if (parent === grandpa.L) {
	        uncle = grandpa.R;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.R) {
	            RedBlackRotateLeft(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateRight(this, grandpa);
	        }
	      } else {
	        uncle = grandpa.L;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.L) {
	            RedBlackRotateRight(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateLeft(this, grandpa);
	        }
	      }
	      parent = after.U;
	    }
	    this._.C = false;
	  },

	  remove: function(node) {
	    if (node.N) node.N.P = node.P;
	    if (node.P) node.P.N = node.N;
	    node.N = node.P = null;

	    var parent = node.U,
	        sibling,
	        left = node.L,
	        right = node.R,
	        next,
	        red;

	    if (!left) next = right;
	    else if (!right) next = left;
	    else next = RedBlackFirst(right);

	    if (parent) {
	      if (parent.L === node) parent.L = next;
	      else parent.R = next;
	    } else {
	      this._ = next;
	    }

	    if (left && right) {
	      red = next.C;
	      next.C = node.C;
	      next.L = left;
	      left.U = next;
	      if (next !== right) {
	        parent = next.U;
	        next.U = node.U;
	        node = next.R;
	        parent.L = node;
	        next.R = right;
	        right.U = next;
	      } else {
	        next.U = parent;
	        parent = next;
	        node = next.R;
	      }
	    } else {
	      red = node.C;
	      node = next;
	    }

	    if (node) node.U = parent;
	    if (red) return;
	    if (node && node.C) { node.C = false; return; }

	    do {
	      if (node === this._) break;
	      if (node === parent.L) {
	        sibling = parent.R;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateLeft(this, parent);
	          sibling = parent.R;
	        }
	        if ((sibling.L && sibling.L.C)
	            || (sibling.R && sibling.R.C)) {
	          if (!sibling.R || !sibling.R.C) {
	            sibling.L.C = false;
	            sibling.C = true;
	            RedBlackRotateRight(this, sibling);
	            sibling = parent.R;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.R.C = false;
	          RedBlackRotateLeft(this, parent);
	          node = this._;
	          break;
	        }
	      } else {
	        sibling = parent.L;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateRight(this, parent);
	          sibling = parent.L;
	        }
	        if ((sibling.L && sibling.L.C)
	          || (sibling.R && sibling.R.C)) {
	          if (!sibling.L || !sibling.L.C) {
	            sibling.R.C = false;
	            sibling.C = true;
	            RedBlackRotateLeft(this, sibling);
	            sibling = parent.L;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.L.C = false;
	          RedBlackRotateRight(this, parent);
	          node = this._;
	          break;
	        }
	      }
	      sibling.C = true;
	      node = parent;
	      parent = parent.U;
	    } while (!node.C);

	    if (node) node.C = false;
	  }
	};

	function RedBlackRotateLeft(tree, node) {
	  var p = node,
	      q = node.R,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.R = q.L;
	  if (p.R) p.R.U = p;
	  q.L = p;
	}

	function RedBlackRotateRight(tree, node) {
	  var p = node,
	      q = node.L,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.L = q.R;
	  if (p.L) p.L.U = p;
	  q.R = p;
	}

	function RedBlackFirst(node) {
	  while (node.L) node = node.L;
	  return node;
	}

	function createEdge(left, right, v0, v1) {
	  var edge = [null, null],
	      index = edges.push(edge) - 1;
	  edge.left = left;
	  edge.right = right;
	  if (v0) setEdgeEnd(edge, left, right, v0);
	  if (v1) setEdgeEnd(edge, right, left, v1);
	  cells[left.index].halfedges.push(index);
	  cells[right.index].halfedges.push(index);
	  return edge;
	}

	function createBorderEdge(left, v0, v1) {
	  var edge = [v0, v1];
	  edge.left = left;
	  return edge;
	}

	function setEdgeEnd(edge, left, right, vertex) {
	  if (!edge[0] && !edge[1]) {
	    edge[0] = vertex;
	    edge.left = left;
	    edge.right = right;
	  } else if (edge.left === right) {
	    edge[1] = vertex;
	  } else {
	    edge[0] = vertex;
	  }
	}

	// Liang–Barsky line clipping.
	function clipEdge(edge, x0, y0, x1, y1) {
	  var a = edge[0],
	      b = edge[1],
	      ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

	  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
	  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
	  return true;
	}

	function connectEdge(edge, x0, y0, x1, y1) {
	  var v1 = edge[1];
	  if (v1) return true;

	  var v0 = edge[0],
	      left = edge.left,
	      right = edge.right,
	      lx = left[0],
	      ly = left[1],
	      rx = right[0],
	      ry = right[1],
	      fx = (lx + rx) / 2,
	      fy = (ly + ry) / 2,
	      fm,
	      fb;

	  if (ry === ly) {
	    if (fx < x0 || fx >= x1) return;
	    if (lx > rx) {
	      if (!v0) v0 = [fx, y0];
	      else if (v0[1] >= y1) return;
	      v1 = [fx, y1];
	    } else {
	      if (!v0) v0 = [fx, y1];
	      else if (v0[1] < y0) return;
	      v1 = [fx, y0];
	    }
	  } else {
	    fm = (lx - rx) / (ry - ly);
	    fb = fy - fm * fx;
	    if (fm < -1 || fm > 1) {
	      if (lx > rx) {
	        if (!v0) v0 = [(y0 - fb) / fm, y0];
	        else if (v0[1] >= y1) return;
	        v1 = [(y1 - fb) / fm, y1];
	      } else {
	        if (!v0) v0 = [(y1 - fb) / fm, y1];
	        else if (v0[1] < y0) return;
	        v1 = [(y0 - fb) / fm, y0];
	      }
	    } else {
	      if (ly < ry) {
	        if (!v0) v0 = [x0, fm * x0 + fb];
	        else if (v0[0] >= x1) return;
	        v1 = [x1, fm * x1 + fb];
	      } else {
	        if (!v0) v0 = [x1, fm * x1 + fb];
	        else if (v0[0] < x0) return;
	        v1 = [x0, fm * x0 + fb];
	      }
	    }
	  }

	  edge[0] = v0;
	  edge[1] = v1;
	  return true;
	}

	function clipEdges(x0, y0, x1, y1) {
	  var i = edges.length,
	      edge;

	  while (i--) {
	    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
	        || !clipEdge(edge, x0, y0, x1, y1)
	        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
	            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
	      delete edges[i];
	    }
	  }
	}

	function createCell(site) {
	  return cells[site.index] = {
	    site: site,
	    halfedges: []
	  };
	}

	function cellHalfedgeAngle(cell, edge) {
	  var site = cell.site,
	      va = edge.left,
	      vb = edge.right;
	  if (site === vb) vb = va, va = site;
	  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
	  if (site === va) va = edge[1], vb = edge[0];
	  else va = edge[0], vb = edge[1];
	  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
	}

	function cellHalfedgeStart(cell, edge) {
	  return edge[+(edge.left !== cell.site)];
	}

	function cellHalfedgeEnd(cell, edge) {
	  return edge[+(edge.left === cell.site)];
	}

	function sortCellHalfedges() {
	  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
	    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
	      var index = new Array(m),
	          array = new Array(m);
	      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
	      index.sort(function(i, j) { return array[j] - array[i]; });
	      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
	      for (j = 0; j < m; ++j) halfedges[j] = array[j];
	    }
	  }
	}

	function clipCells(x0, y0, x1, y1) {
	  var nCells = cells.length,
	      iCell,
	      cell,
	      site,
	      iHalfedge,
	      halfedges,
	      nHalfedges,
	      start,
	      startX,
	      startY,
	      end,
	      endX,
	      endY,
	      cover = true;

	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      site = cell.site;
	      halfedges = cell.halfedges;
	      iHalfedge = halfedges.length;

	      // Remove any dangling clipped edges.
	      while (iHalfedge--) {
	        if (!edges[halfedges[iHalfedge]]) {
	          halfedges.splice(iHalfedge, 1);
	        }
	      }

	      // Insert any border edges as necessary.
	      iHalfedge = 0, nHalfedges = halfedges.length;
	      while (iHalfedge < nHalfedges) {
	        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
	        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
	        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
	          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
	              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
	              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
	              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
	              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
	              : null)) - 1);
	          ++nHalfedges;
	        }
	      }

	      if (nHalfedges) cover = false;
	    }
	  }

	  // If there weren’t any edges, have the closest site cover the extent.
	  // It doesn’t matter which corner of the extent we measure!
	  if (cover) {
	    var dx, dy, d2, dc = Infinity;

	    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
	      if (cell = cells[iCell]) {
	        site = cell.site;
	        dx = site[0] - x0;
	        dy = site[1] - y0;
	        d2 = dx * dx + dy * dy;
	        if (d2 < dc) dc = d2, cover = cell;
	      }
	    }

	    if (cover) {
	      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
	      cover.halfedges.push(
	        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
	        edges.push(createBorderEdge(site, v01, v11)) - 1,
	        edges.push(createBorderEdge(site, v11, v10)) - 1,
	        edges.push(createBorderEdge(site, v10, v00)) - 1
	      );
	    }
	  }

	  // Lastly delete any cells with no edges; these were entirely clipped.
	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      if (!cell.halfedges.length) {
	        delete cells[iCell];
	      }
	    }
	  }
	}

	var circlePool = [];

	var firstCircle;

	function Circle() {
	  RedBlackNode(this);
	  this.x =
	  this.y =
	  this.arc =
	  this.site =
	  this.cy = null;
	}

	function attachCircle(arc) {
	  var lArc = arc.P,
	      rArc = arc.N;

	  if (!lArc || !rArc) return;

	  var lSite = lArc.site,
	      cSite = arc.site,
	      rSite = rArc.site;

	  if (lSite === rSite) return;

	  var bx = cSite[0],
	      by = cSite[1],
	      ax = lSite[0] - bx,
	      ay = lSite[1] - by,
	      cx = rSite[0] - bx,
	      cy = rSite[1] - by;

	  var d = 2 * (ax * cy - ay * cx);
	  if (d >= -epsilon2) return;

	  var ha = ax * ax + ay * ay,
	      hc = cx * cx + cy * cy,
	      x = (cy * ha - ay * hc) / d,
	      y = (ax * hc - cx * ha) / d;

	  var circle = circlePool.pop() || new Circle;
	  circle.arc = arc;
	  circle.site = cSite;
	  circle.x = x + bx;
	  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

	  arc.circle = circle;

	  var before = null,
	      node = circles._;

	  while (node) {
	    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
	      if (node.L) node = node.L;
	      else { before = node.P; break; }
	    } else {
	      if (node.R) node = node.R;
	      else { before = node; break; }
	    }
	  }

	  circles.insert(before, circle);
	  if (!before) firstCircle = circle;
	}

	function detachCircle(arc) {
	  var circle = arc.circle;
	  if (circle) {
	    if (!circle.P) firstCircle = circle.N;
	    circles.remove(circle);
	    circlePool.push(circle);
	    RedBlackNode(circle);
	    arc.circle = null;
	  }
	}

	var beachPool = [];

	function Beach() {
	  RedBlackNode(this);
	  this.edge =
	  this.site =
	  this.circle = null;
	}

	function createBeach(site) {
	  var beach = beachPool.pop() || new Beach;
	  beach.site = site;
	  return beach;
	}

	function detachBeach(beach) {
	  detachCircle(beach);
	  beaches.remove(beach);
	  beachPool.push(beach);
	  RedBlackNode(beach);
	}

	function removeBeach(beach) {
	  var circle = beach.circle,
	      x = circle.x,
	      y = circle.cy,
	      vertex = [x, y],
	      previous = beach.P,
	      next = beach.N,
	      disappearing = [beach];

	  detachBeach(beach);

	  var lArc = previous;
	  while (lArc.circle
	      && Math.abs(x - lArc.circle.x) < epsilon
	      && Math.abs(y - lArc.circle.cy) < epsilon) {
	    previous = lArc.P;
	    disappearing.unshift(lArc);
	    detachBeach(lArc);
	    lArc = previous;
	  }

	  disappearing.unshift(lArc);
	  detachCircle(lArc);

	  var rArc = next;
	  while (rArc.circle
	      && Math.abs(x - rArc.circle.x) < epsilon
	      && Math.abs(y - rArc.circle.cy) < epsilon) {
	    next = rArc.N;
	    disappearing.push(rArc);
	    detachBeach(rArc);
	    rArc = next;
	  }

	  disappearing.push(rArc);
	  detachCircle(rArc);

	  var nArcs = disappearing.length,
	      iArc;
	  for (iArc = 1; iArc < nArcs; ++iArc) {
	    rArc = disappearing[iArc];
	    lArc = disappearing[iArc - 1];
	    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	  }

	  lArc = disappearing[0];
	  rArc = disappearing[nArcs - 1];
	  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function addBeach(site) {
	  var x = site[0],
	      directrix = site[1],
	      lArc,
	      rArc,
	      dxl,
	      dxr,
	      node = beaches._;

	  while (node) {
	    dxl = leftBreakPoint(node, directrix) - x;
	    if (dxl > epsilon) node = node.L; else {
	      dxr = x - rightBreakPoint(node, directrix);
	      if (dxr > epsilon) {
	        if (!node.R) {
	          lArc = node;
	          break;
	        }
	        node = node.R;
	      } else {
	        if (dxl > -epsilon) {
	          lArc = node.P;
	          rArc = node;
	        } else if (dxr > -epsilon) {
	          lArc = node;
	          rArc = node.N;
	        } else {
	          lArc = rArc = node;
	        }
	        break;
	      }
	    }
	  }

	  createCell(site);
	  var newArc = createBeach(site);
	  beaches.insert(lArc, newArc);

	  if (!lArc && !rArc) return;

	  if (lArc === rArc) {
	    detachCircle(lArc);
	    rArc = createBeach(lArc.site);
	    beaches.insert(newArc, rArc);
	    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
	    attachCircle(lArc);
	    attachCircle(rArc);
	    return;
	  }

	  if (!rArc) { // && lArc
	    newArc.edge = createEdge(lArc.site, newArc.site);
	    return;
	  }

	  // else lArc !== rArc
	  detachCircle(lArc);
	  detachCircle(rArc);

	  var lSite = lArc.site,
	      ax = lSite[0],
	      ay = lSite[1],
	      bx = site[0] - ax,
	      by = site[1] - ay,
	      rSite = rArc.site,
	      cx = rSite[0] - ax,
	      cy = rSite[1] - ay,
	      d = 2 * (bx * cy - by * cx),
	      hb = bx * bx + by * by,
	      hc = cx * cx + cy * cy,
	      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

	  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
	  newArc.edge = createEdge(lSite, site, null, vertex);
	  rArc.edge = createEdge(site, rSite, null, vertex);
	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function leftBreakPoint(arc, directrix) {
	  var site = arc.site,
	      rfocx = site[0],
	      rfocy = site[1],
	      pby2 = rfocy - directrix;

	  if (!pby2) return rfocx;

	  var lArc = arc.P;
	  if (!lArc) return -Infinity;

	  site = lArc.site;
	  var lfocx = site[0],
	      lfocy = site[1],
	      plby2 = lfocy - directrix;

	  if (!plby2) return lfocx;

	  var hl = lfocx - rfocx,
	      aby2 = 1 / pby2 - 1 / plby2,
	      b = hl / plby2;

	  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

	  return (rfocx + lfocx) / 2;
	}

	function rightBreakPoint(arc, directrix) {
	  var rArc = arc.N;
	  if (rArc) return leftBreakPoint(rArc, directrix);
	  var site = arc.site;
	  return site[1] === directrix ? site[0] : Infinity;
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var beaches;
	var cells;
	var circles;
	var edges;

	function triangleArea(a, b, c) {
	  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
	}

	function lexicographic(a, b) {
	  return b[1] - a[1]
	      || b[0] - a[0];
	}

	function Diagram(sites, extent) {
	  var site = sites.sort(lexicographic).pop(),
	      x,
	      y,
	      circle;

	  edges = [];
	  cells = new Array(sites.length);
	  beaches = new RedBlackTree;
	  circles = new RedBlackTree;

	  while (true) {
	    circle = firstCircle;
	    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
	      if (site[0] !== x || site[1] !== y) {
	        addBeach(site);
	        x = site[0], y = site[1];
	      }
	      site = sites.pop();
	    } else if (circle) {
	      removeBeach(circle.arc);
	    } else {
	      break;
	    }
	  }

	  sortCellHalfedges();

	  if (extent) {
	    var x0 = +extent[0][0],
	        y0 = +extent[0][1],
	        x1 = +extent[1][0],
	        y1 = +extent[1][1];
	    clipEdges(x0, y0, x1, y1);
	    clipCells(x0, y0, x1, y1);
	  }

	  this.edges = edges;
	  this.cells = cells;

	  beaches =
	  circles =
	  edges =
	  cells = null;
	}

	Diagram.prototype = {
	  constructor: Diagram,

	  polygons: function() {
	    var edges = this.edges;

	    return this.cells.map(function(cell) {
	      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
	      polygon.data = cell.site.data;
	      return polygon;
	    });
	  },

	  triangles: function() {
	    var triangles = [],
	        edges = this.edges;

	    this.cells.forEach(function(cell, i) {
	      if (!(m = (halfedges = cell.halfedges).length)) return;
	      var site = cell.site,
	          halfedges,
	          j = -1,
	          m,
	          s0,
	          e1 = edges[halfedges[m - 1]],
	          s1 = e1.left === site ? e1.right : e1.left;

	      while (++j < m) {
	        s0 = s1;
	        e1 = edges[halfedges[j]];
	        s1 = e1.left === site ? e1.right : e1.left;
	        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
	          triangles.push([site.data, s0.data, s1.data]);
	        }
	      }
	    });

	    return triangles;
	  },

	  links: function() {
	    return this.edges.filter(function(edge) {
	      return edge.right;
	    }).map(function(edge) {
	      return {
	        source: edge.left.data,
	        target: edge.right.data
	      };
	    });
	  },

	  find: function(x, y, radius) {
	    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

	    // Use the previously-found cell, or start with an arbitrary one.
	    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
	    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

	    // Traverse the half-edges to find a closer cell, if any.
	    do {
	      cell = that.cells[i0 = i1], i1 = null;
	      cell.halfedges.forEach(function(e) {
	        var edge = that.edges[e], v = edge.left;
	        if ((v === cell.site || !v) && !(v = edge.right)) return;
	        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
	        if (v2 < d2) d2 = v2, i1 = v.index;
	      });
	    } while (i1 !== null);

	    that._found = i0;

	    return radius == null || d2 <= radius * radius ? cell.site : null;
	  }
	};

	function voronoi() {
	  var x$$1 = x,
	      y$$1 = y,
	      extent = null;

	  function voronoi(data) {
	    return new Diagram(data.map(function(d, i) {
	      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
	      s.index = i;
	      s.data = d;
	      return s;
	    }), extent);
	  }

	  voronoi.polygons = function(data) {
	    return voronoi(data).polygons();
	  };

	  voronoi.links = function(data) {
	    return voronoi(data).links();
	  };

	  voronoi.triangles = function(data) {
	    return voronoi(data).triangles();
	  };

	  voronoi.x = function(_) {
	    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
	  };

	  voronoi.y = function(_) {
	    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
	  };

	  voronoi.extent = function(_) {
	    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
	  };

	  voronoi.size = function(_) {
	    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
	  };

	  return voronoi;
	}

	exports.voronoi = voronoi;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-zoom/ v1.8.3 Copyright 2019 Mike Bostock
	(function (global, factory) {
	 true ? factory(exports, __webpack_require__(9), __webpack_require__(10), __webpack_require__(12), __webpack_require__(11), __webpack_require__(14)) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
	}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function ZoomEvent(target, type, transform) {
	  this.target = target;
	  this.type = type;
	  this.transform = transform;
	}

	function Transform(k, x, y) {
	  this.k = k;
	  this.x = x;
	  this.y = y;
	}

	Transform.prototype = {
	  constructor: Transform,
	  scale: function(k) {
	    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
	  },
	  translate: function(x, y) {
	    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
	  },
	  apply: function(point) {
	    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
	  },
	  applyX: function(x) {
	    return x * this.k + this.x;
	  },
	  applyY: function(y) {
	    return y * this.k + this.y;
	  },
	  invert: function(location) {
	    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
	  },
	  invertX: function(x) {
	    return (x - this.x) / this.k;
	  },
	  invertY: function(y) {
	    return (y - this.y) / this.k;
	  },
	  rescaleX: function(x) {
	    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
	  },
	  rescaleY: function(y) {
	    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
	  },
	  toString: function() {
	    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
	  }
	};

	var identity = new Transform(1, 0, 0);

	transform.prototype = Transform.prototype;

	function transform(node) {
	  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
	  return node.__zoom;
	}

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	function noevent() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	}

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
	}

	function defaultExtent() {
	  var e = this;
	  if (e instanceof SVGElement) {
	    e = e.ownerSVGElement || e;
	    if (e.hasAttribute("viewBox")) {
	      e = e.viewBox.baseVal;
	      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
	    }
	    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
	  }
	  return [[0, 0], [e.clientWidth, e.clientHeight]];
	}

	function defaultTransform() {
	  return this.__zoom || identity;
	}

	function defaultWheelDelta() {
	  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode === 1 ? 0.05 : d3Selection.event.deltaMode ? 1 : 0.002);
	}

	function defaultTouchable() {
	  return navigator.maxTouchPoints || ("ontouchstart" in this);
	}

	function defaultConstrain(transform, extent, translateExtent) {
	  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
	      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
	      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
	      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
	  return transform.translate(
	    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
	    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
	  );
	}

	function zoom() {
	  var filter = defaultFilter,
	      extent = defaultExtent,
	      constrain = defaultConstrain,
	      wheelDelta = defaultWheelDelta,
	      touchable = defaultTouchable,
	      scaleExtent = [0, Infinity],
	      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
	      duration = 250,
	      interpolate = d3Interpolate.interpolateZoom,
	      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
	      touchstarting,
	      touchending,
	      touchDelay = 500,
	      wheelDelay = 150,
	      clickDistance2 = 0;

	  function zoom(selection) {
	    selection
	        .property("__zoom", defaultTransform)
	        .on("wheel.zoom", wheeled)
	        .on("mousedown.zoom", mousedowned)
	        .on("dblclick.zoom", dblclicked)
	      .filter(touchable)
	        .on("touchstart.zoom", touchstarted)
	        .on("touchmove.zoom", touchmoved)
	        .on("touchend.zoom touchcancel.zoom", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  zoom.transform = function(collection, transform, point) {
	    var selection = collection.selection ? collection.selection() : collection;
	    selection.property("__zoom", defaultTransform);
	    if (collection !== selection) {
	      schedule(collection, transform, point);
	    } else {
	      selection.interrupt().each(function() {
	        gesture(this, arguments)
	            .start()
	            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
	            .end();
	      });
	    }
	  };

	  zoom.scaleBy = function(selection, k, p) {
	    zoom.scaleTo(selection, function() {
	      var k0 = this.__zoom.k,
	          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	      return k0 * k1;
	    }, p);
	  };

	  zoom.scaleTo = function(selection, k, p) {
	    zoom.transform(selection, function() {
	      var e = extent.apply(this, arguments),
	          t0 = this.__zoom,
	          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
	          p1 = t0.invert(p0),
	          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
	    }, p);
	  };

	  zoom.translateBy = function(selection, x, y) {
	    zoom.transform(selection, function() {
	      return constrain(this.__zoom.translate(
	        typeof x === "function" ? x.apply(this, arguments) : x,
	        typeof y === "function" ? y.apply(this, arguments) : y
	      ), extent.apply(this, arguments), translateExtent);
	    });
	  };

	  zoom.translateTo = function(selection, x, y, p) {
	    zoom.transform(selection, function() {
	      var e = extent.apply(this, arguments),
	          t = this.__zoom,
	          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
	      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
	        typeof x === "function" ? -x.apply(this, arguments) : -x,
	        typeof y === "function" ? -y.apply(this, arguments) : -y
	      ), e, translateExtent);
	    }, p);
	  };

	  function scale(transform, k) {
	    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
	    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
	  }

	  function translate(transform, p0, p1) {
	    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
	    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
	  }

	  function centroid(extent) {
	    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
	  }

	  function schedule(transition, transform, point) {
	    transition
	        .on("start.zoom", function() { gesture(this, arguments).start(); })
	        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
	        .tween("zoom", function() {
	          var that = this,
	              args = arguments,
	              g = gesture(that, args),
	              e = extent.apply(that, args),
	              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
	              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
	              a = that.__zoom,
	              b = typeof transform === "function" ? transform.apply(that, args) : transform,
	              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
	          return function(t) {
	            if (t === 1) t = b; // Avoid rounding error on end.
	            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
	            g.zoom(null, t);
	          };
	        });
	  }

	  function gesture(that, args, clean) {
	    return (!clean && that.__zooming) || new Gesture(that, args);
	  }

	  function Gesture(that, args) {
	    this.that = that;
	    this.args = args;
	    this.active = 0;
	    this.extent = extent.apply(that, args);
	    this.taps = 0;
	  }

	  Gesture.prototype = {
	    start: function() {
	      if (++this.active === 1) {
	        this.that.__zooming = this;
	        this.emit("start");
	      }
	      return this;
	    },
	    zoom: function(key, transform) {
	      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
	      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
	      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
	      this.that.__zoom = transform;
	      this.emit("zoom");
	      return this;
	    },
	    end: function() {
	      if (--this.active === 0) {
	        delete this.that.__zooming;
	        this.emit("end");
	      }
	      return this;
	    },
	    emit: function(type) {
	      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
	    }
	  };

	  function wheeled() {
	    if (!filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments),
	        t = this.__zoom,
	        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
	        p = d3Selection.mouse(this);

	    // If the mouse is in the same location as before, reuse it.
	    // If there were recent wheel events, reset the wheel idle timeout.
	    if (g.wheel) {
	      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
	        g.mouse[1] = t.invert(g.mouse[0] = p);
	      }
	      clearTimeout(g.wheel);
	    }

	    // If this wheel event won’t trigger a transform change, ignore it.
	    else if (t.k === k) return;

	    // Otherwise, capture the mouse point and location at the start.
	    else {
	      g.mouse = [p, t.invert(p)];
	      d3Transition.interrupt(this);
	      g.start();
	    }

	    noevent();
	    g.wheel = setTimeout(wheelidled, wheelDelay);
	    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

	    function wheelidled() {
	      g.wheel = null;
	      g.end();
	    }
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments, true),
	        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
	        p = d3Selection.mouse(this),
	        x0 = d3Selection.event.clientX,
	        y0 = d3Selection.event.clientY;

	    d3Drag.dragDisable(d3Selection.event.view);
	    nopropagation();
	    g.mouse = [p, this.__zoom.invert(p)];
	    d3Transition.interrupt(this);
	    g.start();

	    function mousemoved() {
	      noevent();
	      if (!g.moved) {
	        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
	        g.moved = dx * dx + dy * dy > clickDistance2;
	      }
	      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
	    }

	    function mouseupped() {
	      v.on("mousemove.zoom mouseup.zoom", null);
	      d3Drag.dragEnable(d3Selection.event.view, g.moved);
	      noevent();
	      g.end();
	    }
	  }

	  function dblclicked() {
	    if (!filter.apply(this, arguments)) return;
	    var t0 = this.__zoom,
	        p0 = d3Selection.mouse(this),
	        p1 = t0.invert(p0),
	        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
	        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

	    noevent();
	    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
	    else d3Selection.select(this).call(zoom.transform, t1);
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var touches = d3Selection.event.touches,
	        n = touches.length,
	        g = gesture(this, arguments, d3Selection.event.changedTouches.length === n),
	        started, i, t, p;

	    nopropagation();
	    for (i = 0; i < n; ++i) {
	      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
	      p = [p, this.__zoom.invert(p), t.identifier];
	      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
	      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
	    }

	    if (touchstarting) touchstarting = clearTimeout(touchstarting);

	    if (started) {
	      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
	      d3Transition.interrupt(this);
	      g.start();
	    }
	  }

	  function touchmoved() {
	    if (!this.__zooming) return;
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        n = touches.length, i, t, p, l;

	    noevent();
	    if (touchstarting) touchstarting = clearTimeout(touchstarting);
	    g.taps = 0;
	    for (i = 0; i < n; ++i) {
	      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
	      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
	      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
	    }
	    t = g.that.__zoom;
	    if (g.touch1) {
	      var p0 = g.touch0[0], l0 = g.touch0[1],
	          p1 = g.touch1[0], l1 = g.touch1[1],
	          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
	          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
	      t = scale(t, Math.sqrt(dp / dl));
	      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
	      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
	    }
	    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
	    else return;
	    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
	  }

	  function touchended() {
	    if (!this.__zooming) return;
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        n = touches.length, i, t;

	    nopropagation();
	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, touchDelay);
	    for (i = 0; i < n; ++i) {
	      t = touches[i];
	      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
	      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
	    }
	    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
	    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
	    else {
	      g.end();
	      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
	      if (g.taps === 2) {
	        var p = d3Selection.select(this).on("dblclick.zoom");
	        if (p) p.apply(this, arguments);
	      }
	    }
	  }

	  zoom.wheelDelta = function(_) {
	    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
	  };

	  zoom.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
	  };

	  zoom.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
	  };

	  zoom.extent = function(_) {
	    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
	  };

	  zoom.scaleExtent = function(_) {
	    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
	  };

	  zoom.translateExtent = function(_) {
	    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
	  };

	  zoom.constrain = function(_) {
	    return arguments.length ? (constrain = _, zoom) : constrain;
	  };

	  zoom.duration = function(_) {
	    return arguments.length ? (duration = +_, zoom) : duration;
	  };

	  zoom.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, zoom) : interpolate;
	  };

	  zoom.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? zoom : value;
	  };

	  zoom.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
	  };

	  return zoom;
	}

	exports.zoom = zoom;
	exports.zoomIdentity = identity;
	exports.zoomTransform = transform;

	Object.defineProperty(exports, '__esModule', { value: true });

	}));


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 * 
	 * billboard.js, JavaScript chart library
	 * https://naver.github.io/billboard.js/
	 * 
	 * @version 1.12.10
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(32), __webpack_require__(11), __webpack_require__(14), __webpack_require__(7), __webpack_require__(30), __webpack_require__(8), __webpack_require__(21), __webpack_require__(10), __webpack_require__(34), __webpack_require__(12), __webpack_require__(13), __webpack_require__(36), __webpack_require__(16));
		else if(typeof define === 'function' && define.amd)
			define(["d3-time-format", "d3-selection", "d3-transition", "d3-axis", "d3-scale", "d3-brush", "d3-dsv", "d3-drag", "d3-shape", "d3-interpolate", "d3-color", "d3-zoom", "d3-ease"], factory);
		else {
			var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-axis"), require("d3-scale"), require("d3-brush"), require("d3-dsv"), require("d3-drag"), require("d3-shape"), require("d3-interpolate"), require("d3-color"), require("d3-zoom"), require("d3-ease")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
			for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
		}
	})(this, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__4__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__6__, __WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__11__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__, __WEBPACK_EXTERNAL_MODULE__14__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId]) {
	/******/ 			return installedModules[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// define __esModule on exports
	/******/ 	__webpack_require__.r = function(exports) {
	/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	/******/ 		}
	/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
	/******/ 	};
	/******/
	/******/ 	// create a fake namespace object
	/******/ 	// mode & 1: value is a module id, require it
	/******/ 	// mode & 2: merge all properties of value into the ns
	/******/ 	// mode & 4: return value when already ns object
	/******/ 	// mode & 8|1: behave like require
	/******/ 	__webpack_require__.t = function(value, mode) {
	/******/ 		if(mode & 1) value = __webpack_require__(value);
	/******/ 		if(mode & 8) return value;
	/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
	/******/ 		var ns = Object.create(null);
	/******/ 		__webpack_require__.r(ns);
	/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
	/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
	/******/ 		return ns;
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(15);


	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {

	// extracted by mini-css-extract-plugin

	/***/ }),
	/* 2 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

	/***/ }),
	/* 3 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__3__;

	/***/ }),
	/* 4 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__4__;

	/***/ }),
	/* 5 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__5__;

	/***/ }),
	/* 6 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__6__;

	/***/ }),
	/* 7 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__7__;

	/***/ }),
	/* 8 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__8__;

	/***/ }),
	/* 9 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__9__;

	/***/ }),
	/* 10 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__10__;

	/***/ }),
	/* 11 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__11__;

	/***/ }),
	/* 12 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__12__;

	/***/ }),
	/* 13 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__13__;

	/***/ }),
	/* 14 */
	/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE__14__;

	/***/ }),
	/* 15 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {

	"use strict";
	// ESM COMPAT FLAG
	__webpack_require__.r(__webpack_exports__);

	// EXPORTS
	__webpack_require__.d(__webpack_exports__, "bb", function() { return /* binding */ bb; });

	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) {
	    arr2[i] = arr[i];
	  }

	  return arr2;
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}
	// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
	var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(2);

	// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
	var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(3);

	// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
	var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(4);

	// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
	var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(5);

	// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
	var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(6);

	// CONCATENATED MODULE: ./src/config/classes.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

	/**
	 * CSS class names definition
	 * @private
	 */
	/* harmony default export */ var config_classes = ({
	  arc: "bb-arc",
	  arcLabelLine: "bb-arc-label-line",
	  arcs: "bb-arcs",
	  area: "bb-area",
	  areas: "bb-areas",
	  axis: "bb-axis",
	  axisX: "bb-axis-x",
	  axisXLabel: "bb-axis-x-label",
	  axisY: "bb-axis-y",
	  axisY2: "bb-axis-y2",
	  axisY2Label: "bb-axis-y2-label",
	  axisYLabel: "bb-axis-y-label",
	  bar: "bb-bar",
	  bars: "bb-bars",
	  brush: "bb-brush",
	  button: "bb-button",
	  buttonZoomReset: "bb-zoom-reset",
	  chart: "bb-chart",
	  chartArc: "bb-chart-arc",
	  chartArcs: "bb-chart-arcs",
	  chartArcsBackground: "bb-chart-arcs-background",
	  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
	  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
	  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
	  chartArcsTitle: "bb-chart-arcs-title",
	  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
	  chartBar: "bb-chart-bar",
	  chartBars: "bb-chart-bars",
	  chartLine: "bb-chart-line",
	  chartLines: "bb-chart-lines",
	  chartRadar: "bb-chart-radar",
	  chartRadars: "bb-chart-radars",
	  chartText: "bb-chart-text",
	  chartTexts: "bb-chart-texts",
	  circle: "bb-circle",
	  circles: "bb-circles",
	  colorPattern: "bb-color-pattern",
	  colorScale: "bb-colorscale",
	  defocused: "bb-defocused",
	  dragarea: "bb-dragarea",
	  empty: "bb-empty",
	  eventRect: "bb-event-rect",
	  eventRects: "bb-event-rects",
	  eventRectsMultiple: "bb-event-rects-multiple",
	  eventRectsSingle: "bb-event-rects-single",
	  focused: "bb-focused",
	  gaugeValue: "bb-gauge-value",
	  grid: "bb-grid",
	  gridLines: "bb-grid-lines",
	  legendBackground: "bb-legend-background",
	  legendItem: "bb-legend-item",
	  legendItemEvent: "bb-legend-item-event",
	  legendItemFocused: "bb-legend-item-focused",
	  legendItemHidden: "bb-legend-item-hidden",
	  legendItemPoint: "bb-legend-item-point",
	  legendItemTile: "bb-legend-item-tile",
	  level: "bb-level",
	  levels: "bb-levels",
	  line: "bb-line",
	  lines: "bb-lines",
	  region: "bb-region",
	  regions: "bb-regions",
	  selectedCircle: "bb-selected-circle",
	  selectedCircles: "bb-selected-circles",
	  shape: "bb-shape",
	  shapes: "bb-shapes",
	  stanfordElements: "bb-stanford-elements",
	  stanfordLine: "bb-stanford-line",
	  stanfordLines: "bb-stanford-lines",
	  stanfordRegion: "bb-stanford-region",
	  stanfordRegions: "bb-stanford-regions",
	  target: "bb-target",
	  text: "bb-text",
	  texts: "bb-texts",
	  title: "bb-title",
	  tooltip: "bb-tooltip",
	  tooltipContainer: "bb-tooltip-container",
	  tooltipName: "bb-tooltip-name",
	  xgrid: "bb-xgrid",
	  xgridFocus: "bb-xgrid-focus",
	  xgridLine: "bb-xgrid-line",
	  xgridLines: "bb-xgrid-lines",
	  xgrids: "bb-xgrids",
	  ygrid: "bb-ygrid",
	  ygridFocus: "bb-ygrid-focus",
	  ygridLine: "bb-ygrid-line",
	  ygridLines: "bb-ygrid-lines",
	  ygrids: "bb-ygrids",
	  zoomBrush: "bb-zoom-brush",
	  zoomRect: "bb-zoom-rect",
	  EXPANDED: "_expanded_",
	  SELECTED: "_selected_",
	  INCLUDED: "_included_",
	  TextOverlapping: "text-overlapping"
	});
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}
	// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}
	// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
	var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(7);

	// CONCATENATED MODULE: ./src/internals/browser.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

	/**
	 * Window object
	 * @module
	 * @ignore
	 */

	/* eslint-disable no-new-func, no-undef */
	var win = function () {
	  var def = function (o) {
	    return typeof o !== "undefined" && o;
	  };

	  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
	}(),
	    browser_doc = win && win.document;
	/* eslint-enable no-new-func, no-undef */



	// CONCATENATED MODULE: ./src/internals/util.js



	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 * @ignore
	 */





	var isValue = function (v) {
	  return v || v === 0;
	},
	    isFunction = function (v) {
	  return typeof v === "function";
	},
	    isString = function (v) {
	  return typeof v === "string";
	},
	    isNumber = function (v) {
	  return typeof v === "number";
	},
	    isUndefined = function (v) {
	  return typeof v === "undefined";
	},
	    isDefined = function (v) {
	  return typeof v !== "undefined";
	},
	    isBoolean = function (v) {
	  return typeof v === "boolean";
	},
	    ceil10 = function (v) {
	  return Math.ceil(v / 10) * 10;
	},
	    asHalfPixel = function (n) {
	  return Math.ceil(n) + .5;
	},
	    diffDomain = function (d) {
	  return d[1] - d[0];
	},
	    isObjectType = function (v) {
	  return _typeof(v) === "object";
	},
	    isEmpty = function (o) {
	  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
	},
	    notEmpty = function (o) {
	  return !isEmpty(o);
	},
	    isArray = function (arr) {
	  return arr && arr.constructor === Array;
	},
	    isObject = function (obj) {
	  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
	},
	    getOption = function (options, key, defaultValue) {
	  return isDefined(options[key]) ? options[key] : defaultValue;
	},
	    util_hasValue = function (dict, value) {
	  var found = !1;
	  return Object.keys(dict).forEach(function (key) {
	    return dict[key] === value && (found = !0);
	  }), found;
	},
	    callFn = function (fn) {
	  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

	  return isFn && fn.call.apply(fn, args), isFn;
	},
	    sanitise = function (str) {
	  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
	},
	    setTextValue = function (node, text) {
	  var dy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-1, 1],
	      toMiddle = !!(arguments.length > 3 && arguments[3] !== undefined) && arguments[3];
	  if (node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
	    var diff = [node.text(), text].map(function (v) {
	      return v.replace(/[\s\n]/g, "");
	    });

	    if (diff[0] !== diff[1]) {
	      var multiline = text.split("\n"),
	          len = toMiddle ? multiline.length - 1 : 1;
	      node.html(""), multiline.forEach(function (v, i) {
	        node.append("tspan").attr("x", 0).attr("dy", "".concat(i === 0 ? dy[0] * len : dy[1], "em")).text(v);
	      });
	    }
	  }
	},
	    getRectSegList = function (path) {
	  /*
	   * seg1 ---------- seg2
	   *   |               |
	   *   |               |
	   *   |               |
	   * seg0 ---------- seg3
	   * */
	  var _path$getBBox = path.getBBox(),
	      x = _path$getBBox.x,
	      y = _path$getBBox.y,
	      width = _path$getBBox.width,
	      height = _path$getBBox.height;

	  return [{
	    x: x,
	    y: y + height
	  }, // seg0
	  {
	    x: x,
	    y: y
	  }, // seg1
	  {
	    x: x + width,
	    y: y
	  }, // seg2
	  {
	    x: x + width,
	    y: y + height
	  } // seg3
	  ];
	},
	    getPathBox = function (path) {
	  var _path$getBoundingClie = path.getBoundingClientRect(),
	      width = _path$getBoundingClie.width,
	      height = _path$getBoundingClie.height,
	      items = getRectSegList(path),
	      x = items[0].x,
	      y = Math.min(items[0].y, items[1].y);

	  return {
	    x: x,
	    y: y,
	    width: width,
	    height: height
	  };
	},
	    getBrushSelection = function (ctx) {
	  var selection = null,
	      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
	      main = ctx.context || ctx.main;
	  return event && event.constructor.name === "BrushEvent" ? selection = event.selection : main && (selection = main.select(".".concat(config_classes.brush)).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
	},
	    getBoundingRect = function (node) {
	  return node.rect || (node.rect = node.getBoundingClientRect());
	},
	    getRandom = function () {
	  var asStr = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0];
	  return Math.random() + (asStr ? "" : 0);
	},
	    brushEmpty = function (ctx) {
	  var selection = getBrushSelection(ctx);
	  return !selection || selection[0] === selection[1];
	},
	    extend = function () {
	  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      source = arguments.length > 1 ? arguments[1] : undefined;

	  for (var p in source) target[p] = source[p];

	  return target;
	},
	    capitalize = function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	},
	    toArray = function (v) {
	  return [].slice.call(v);
	},
	    getCssRules = function (styleSheets) {
	  var rules = [];
	  return styleSheets.forEach(function (sheet) {
	    try {
	      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
	    } catch (e) {
	      console.error("Error while reading rules from ".concat(sheet.href, ": ").concat(e.toString()));
	    }
	  }), rules;
	},
	    getTranslation = function (node) {
	  var transform = node ? node.transform : null,
	      baseVal = transform && transform.baseVal;
	  return baseVal && baseVal.numberOfItems ? baseVal.getItem(0).matrix : {
	    a: 0,
	    b: 0,
	    c: 0,
	    d: 0,
	    e: 0,
	    f: 0
	  };
	},
	    getUnique = function (data) {
	  var isDate = data[0] instanceof Date,
	      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
	    return self.indexOf(v) === i;
	  });
	  return isDate ? d.map(function (v) {
	    return new Date(v);
	  }) : d;
	},
	    mergeArray = function (arr) {
	  return arr && arr.length ? arr.reduce(function (p, c) {
	    return p.concat(c);
	  }) : [];
	},
	    mergeObj = function (_mergeObj) {
	  function mergeObj() {
	    return _mergeObj.apply(this, arguments);
	  }

	  return mergeObj.toString = function () {
	    return _mergeObj.toString();
	  }, mergeObj;
	}(function (target) {
	  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

	  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
	  var source = objectN.shift();
	  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
	    var value = source[key];
	    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
	  }), mergeObj.apply(void 0, [target].concat(objectN));
	}),
	    sortValue = function (data) {
	  var fn,
	      isAsc = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1];
	  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
	    return a - b;
	  } : function (a, b) {
	    return b - a;
	  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
	    return a - b;
	  } : !isAsc && (fn = function (a, b) {
	    return a > b && -1 || a < b && 1 || a === b && 0;
	  }), data.concat().sort(fn);
	},
	    getMinMax = function (type, data) {
	  var res = data.filter(function (v) {
	    return notEmpty(v);
	  });
	  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, _toConsumableArray(res)) : res[0] instanceof Date && (res = sortValue(res, type === "min")[0]) : res = undefined, res;
	},
	    getRange = function (start, end) {
	  for (var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1, res = [], n = Math.max(0, Math.ceil((end - start) / step)) | 0, i = start; i < n; i++) res.push(start + i * step);

	  return res;
	},
	    emulateEvent = {
	  mouse: function () {
	    var getParams = function () {
	      return {
	        bubbles: !1,
	        cancelable: !1,
	        screenX: 0,
	        screenY: 0,
	        clientX: 0,
	        clientY: 0
	      };
	    };

	    try {
	      return new MouseEvent("t"), function (el, eventType) {
	        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams();
	        el.dispatchEvent(new MouseEvent(eventType, params));
	      };
	    } catch (e) {
	      // Polyfills DOM4 MouseEvent
	      return function (el, eventType) {
	        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getParams(),
	            mouseEvent = browser_doc.createEvent("MouseEvent");
	        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
	        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
	      };
	    }
	  }(),
	  touch: function touch(el, eventType, params) {
	    var touchObj = new Touch(mergeObj({
	      identifier: Date.now(),
	      target: el,
	      radiusX: 2.5,
	      radiusY: 2.5,
	      rotationAngle: 10,
	      force: .5
	    }, params));
	    el.dispatchEvent(new TouchEvent(eventType, {
	      cancelable: !0,
	      bubbles: !0,
	      shiftKey: !0,
	      touches: [touchObj],
	      targetTouches: [],
	      changedTouches: [touchObj]
	    }));
	  }
	},
	    tplProcess = function (tpl, data) {
	  var res = tpl;

	  for (var x in data) res = res.replace(new RegExp("{=".concat(x, "}"), "g"), data[x]);

	  return res;
	};


	// CONCATENATED MODULE: ./src/axis/AxisRendererHelper.js





	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 * @ignore
	 */



	var AxisRendererHelper_AxisRendererHelper = /*#__PURE__*/function () {
	  function AxisRendererHelper(owner) {
	    _classCallCheck(this, AxisRendererHelper);

	    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
	        config = owner.config,
	        params = owner.params;
	    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = scale.rangeExtent ? scale.rangeExtent() : this.scaleExtent((params.orgXScale || scale).range());
	  }
	  /**
	   * Compute a character dimension
	   * @param {d3.selection} node
	   * @return {{w: number, h: number}}
	   * @private
	   */


	  return _createClass(AxisRendererHelper, [{
	    key: "getTickTransformSetter",

	    /**
	     * Get tick transform setter function
	     * @param {String} id Axis id
	     * @private
	     */
	    value: function getTickTransformSetter(id) {
	      var config = this.config,
	          fn = id === "x" ? function (value) {
	        return "translate(".concat(value + config.tickOffset, ",0)");
	      } : function (value) {
	        return "translate(0,".concat(value, ")");
	      };
	      return function (selection, scale) {
	        selection.attr("transform", function (d) {
	          return fn(Math.ceil(scale(d)));
	        });
	      };
	    }
	  }, {
	    key: "scaleExtent",
	    value: function scaleExtent(domain) {
	      var start = domain[0],
	          stop = domain[domain.length - 1];
	      return start < stop ? [start, stop] : [stop, start];
	    }
	  }, {
	    key: "generateTicks",
	    value: function generateTicks(scale, isYAxes) {
	      var tickStepSize = this.owner.params.tickStepSize,
	          ticks = [];
	      // When 'axis[y|y2].tick.stepSize' option is set
	      if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), _scale$domain2 = _slicedToArray(_scale$domain, 2), start = _scale$domain2[0], end = _scale$domain2[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, _toConsumableArray(this.config.tickArguments || [])).map(function (v) {
	        return (// round the tick value if is number
	          isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
	        );
	      });else {
	        for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

	        ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
	      }
	      return ticks;
	    }
	  }, {
	    key: "copyScale",
	    value: function copyScale() {
	      var newScale = this.scale.copy();
	      return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
	    }
	  }, {
	    key: "textFormatted",
	    value: function textFormatted(v) {
	      var tickFormat = this.config.tickFormat,
	          value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
	          formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
	      // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
	      // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

	      return isDefined(formatted) ? formatted : "";
	    }
	  }, {
	    key: "transitionise",
	    value: function transitionise(selection) {
	      var config = this.config;
	      return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
	    }
	  }], [{
	    key: "getSizeFor1Char",
	    value: function getSizeFor1Char(node) {
	      // default size for one character
	      var size = {
	        w: 5.5,
	        h: 11.5
	      };
	      return node.empty() || node.select("text").text("0").call(function (el) {
	        try {
	          var _el$node$getBBox = el.node().getBBox(),
	              width = _el$node$getBBox.width,
	              height = _el$node$getBBox.height;

	          width && height && (size.w = width, size.h = height);
	        } catch (e) {} finally {
	          el.text("");
	        }
	      }), this.getSizeFor1Char = function () {
	        return size;
	      }, size;
	    }
	  }]), AxisRendererHelper;
	}();


	// CONCATENATED MODULE: ./src/axis/AxisRenderer.js



	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 * @ignore
	 */




	var AxisRenderer_AxisRenderer = /*#__PURE__*/function () {
	  function AxisRenderer() {
	    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, AxisRenderer);

	    var config = {
	      innerTickSize: 6,
	      outerTickSize: params.outerTick ? 6 : 0,
	      orient: "bottom",
	      range: [],
	      tickArguments: null,
	      tickCentered: null,
	      tickCulling: !0,
	      tickFormat: null,
	      tickLength: 9,
	      tickOffset: 0,
	      tickPadding: 3,
	      tickValues: null,
	      transition: null,
	      noTransition: params.noTransition
	    };
	    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
	  }
	  /**
	   * Create axis element
	   * @param {d3.selection} g
	   * @private
	   */


	  return _createClass(AxisRenderer, [{
	    key: "create",
	    value: function create(g) {
	      var ctx = this,
	          config = this.config,
	          helper = this.helper,
	          params = this.params,
	          scale = helper.scale,
	          orient = config.orient,
	          splitTickText = this.splitTickText.bind(this),
	          isLeftRight = /^(left|right)$/.test(orient),
	          isTopBottom = /^(top|bottom)$/.test(orient),
	          tickTransform = helper.getTickTransformSetter(isTopBottom ? "x" : "y"),
	          axisPx = tickTransform === helper.axisX ? "y" : "x",
	          sign = /^(top|left)$/.test(orient) ? -1 : 1,
	          rotate = params.tickTextRotate;
	      this.config.range = scale.rangeExtent ? scale.rangeExtent() : helper.scaleExtent((params.orgXScale || scale).range());
	      var _config2 = config,
	          innerTickSize = _config2.innerTickSize,
	          tickLength = _config2.tickLength,
	          range = _config2.range,
	          name = params.name,
	          tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_".concat(name, "_tick_text_position")] : {
	        x: 0,
	        y: 0
	      },
	          prefix = name === "subX" ? "subchart_axis_x" : "axis_".concat(name),
	          axisShow = params.config["".concat(prefix, "_show")],
	          tickShow = {
	        tick: !!axisShow && params.config["".concat(prefix, "_tick_show")],
	        text: !!axisShow && params.config["".concat(prefix, "_tick_text_show")]
	      },
	          $g = null; // // get the axis' tick position configuration

	      g.each(function () {
	        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	            scale0 = this.__chart__ || scale,
	            scale1 = helper.copyScale();
	        $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
	        // update selection - data join
	        var path = g.selectAll(".domain").data([0]); // enter + update selection

	        if (path.enter().append("path").attr("class", "domain").merge(helper.transitionise(path)).attr("d", function () {
	          var outerTickSized = config.outerTickSize * sign;
	          return isTopBottom ? "M".concat(range[0], ",").concat(outerTickSized, "V0H").concat(range[1], "V").concat(outerTickSized) : "M".concat(outerTickSized, ",").concat(range[0], "H0V").concat(range[1], "H").concat(outerTickSized);
	        }), tickShow.tick || tickShow.text) {
	          // count of tick data in array
	          var ticks = config.tickValues || helper.generateTicks(scale1, isLeftRight),
	              tick = g.selectAll(".tick").data(ticks, scale1),
	              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
	              tickExit = tick.exit().remove(); // update selection

	          tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
	          var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
	              counts = [],
	              tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
	            var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helper.textFormatted(d)) ? helper.textFormatted(d).concat() : [helper.textFormatted(d)];
	            return counts[index] = split.length, split.map(function (splitted) {
	              return {
	                index: index,
	                splitted: splitted
	              };
	            });
	          });
	          tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
	            return d.splitted;
	          }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
	            var dx = 0;
	            return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
	          }()).attr("dy", function (d, i) {
	            var dy = 0;
	            return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
	          });
	          var lineUpdate = tick.select("line"),
	              textUpdate = tick.select("text");

	          // Append <title> for tooltip display
	          if (tickEnter.select("line").attr("".concat(axisPx, "2"), innerTickSize * sign), tickEnter.select("text").attr(axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle) {
	            var title = textUpdate.select("title");
	            (title.empty() ? textUpdate.append("title") : title).text(function (index) {
	              return params.tickTitle[index];
	            });
	          }

	          if (scale1.bandwidth) {
	            var x = scale1,
	                dx = x.bandwidth() / 2;
	            scale0 = function (d) {
	              return x(d) + dx;
	            }, scale1 = scale0;
	          } else scale0.bandwidth ? scale0 = scale1 : tickTransform(tickExit, scale1);

	          tickTransform(tickEnter, scale0), tickTransform(helper.transitionise(tick).style("opacity", "1"), scale1);
	        }
	      }), this.g = $g;
	    }
	    /**
	     * Get tick x/y coordinate
	     * @return {{x: number, y: number}}
	     * @private
	     */

	  }, {
	    key: "getTickXY",
	    value: function getTickXY() {
	      var config = this.config,
	          pos = {
	        x: 0,
	        y: 0
	      };
	      return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
	    }
	    /**
	     * Get tick size
	     * @param d
	     * @return {number}
	     * @private
	     */

	  }, {
	    key: "getTickSize",
	    value: function getTickSize(d) {
	      var scale = this.helper.scale,
	          config = this.config,
	          innerTickSize = config.innerTickSize,
	          range = config.range,
	          tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
	      return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
	    }
	    /**
	     * Set tick's line & text position
	     * @param lineUpdate
	     * @param textUpdate
	     * @param scale
	     * @private
	     */

	  }, {
	    key: "setTickLineTextPosition",
	    value: function setTickLineTextPosition(lineUpdate, textUpdate) {
	      var tickPos = this.getTickXY(),
	          _this$config = this.config,
	          innerTickSize = _this$config.innerTickSize,
	          orient = _this$config.orient,
	          tickLength = _this$config.tickLength,
	          tickOffset = _this$config.tickOffset,
	          rotate = this.params.tickTextRotate,
	          textAnchorForText = function (r) {
	        var value = ["start", "end"];
	        return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
	      },
	          textTransform = function (r) {
	        return r ? "rotate(".concat(r, ")") : null;
	      },
	          yForText = function (r) {
	        var r2 = r / (orient === "bottom" ? 15 : 23);
	        return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
	      };

	      orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
	    } // this should be called only when category axis

	  }, {
	    key: "splitTickText",
	    value: function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
	      function split(splitted, text) {
	        for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
	        if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

	        return splitted.concat(text);
	      }

	      var params = this.params,
	          tickText = this.helper.textFormatted(d),
	          splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
	      if (splitted.length) return splitted;
	      if (isArray(tickText)) return tickText;
	      var tickWidth = params.tickWidth;
	      return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
	    }
	  }, {
	    key: "scale",
	    value: function scale(x) {
	      return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
	    }
	  }, {
	    key: "orient",
	    value: function orient(x) {
	      return arguments.length ? (this.config.orient = x in {
	        top: 1,
	        right: 1,
	        bottom: 1,
	        left: 1
	      } ? x + "" : "bottom", this) : this.config.orient;
	    }
	  }, {
	    key: "tickFormat",
	    value: function tickFormat(format) {
	      return arguments.length ? (this.config.tickFormat = format, this) : this.config.tickFormat;
	    }
	  }, {
	    key: "tickCentered",
	    value: function tickCentered(isCentered) {
	      var config = this.config;
	      return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
	    }
	    /**
	     * Return tick's offset value.
	     * The value will be set for 'category' axis type.
	     * @return {number}
	     * @private
	     */

	  }, {
	    key: "tickOffset",
	    value: function tickOffset() {
	      return this.config.tickOffset;
	    }
	    /**
	     * Get tick interval count
	     * @private
	     * @param {Number} size Total data size
	     * @return {number}
	     */

	  }, {
	    key: "tickInterval",
	    value: function tickInterval(size) {
	      var interval;
	      if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
	        var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
	        interval = length / (size || this.g.selectAll("line").size());
	      }
	      return interval === Infinity ? 0 : interval;
	    }
	  }, {
	    key: "ticks",
	    value: function ticks() {
	      for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

	      return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
	    }
	  }, {
	    key: "tickCulling",
	    value: function tickCulling(culling) {
	      var config = this.config;
	      return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
	    }
	  }, {
	    key: "tickValues",
	    value: function tickValues(x) {
	      var _this = this,
	          config = this.config;

	      if (isFunction(x)) config.tickValues = function () {
	        return x(_this.helper.scale.domain());
	      };else {
	        if (!arguments.length) return config.tickValues;
	        config.tickValues = x;
	      }
	      return this;
	    }
	  }, {
	    key: "setTransition",
	    value: function setTransition(t) {
	      return this.config.transition = t, this;
	    }
	  }]), AxisRenderer;
	}();


	// CONCATENATED MODULE: ./src/axis/Axis.js




	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */






	var isHorizontal = function ($$, forHorizontal) {
	  var isRotated = $$.config.axis_rotated;
	  return forHorizontal ? isRotated : !isRotated;
	},
	    getAxisClassName = function (id) {
	  return "".concat(config_classes.axis, " ").concat(config_classes["axis".concat(capitalize(id))]);
	};

	var Axis_Axis = /*#__PURE__*/function () {
	  function Axis(owner) {
	    _classCallCheck(this, Axis), this.owner = owner, this.setOrient();
	  }

	  return _createClass(Axis, [{
	    key: "init",
	    value: function init() {
	      var _this = this,
	          $$ = this.owner,
	          config = $$.config,
	          isRotated = config.axis_rotated,
	          main = $$.main,
	          target = ["x", "y"];

	      config.axis_y2_show && target.push("y2"), $$.axesList = {}, target.forEach(function (v) {
	        var classAxis = getAxisClassName(v),
	            classLabel = config_classes["axis".concat(v.toUpperCase(), "Label")];
	        $$.axes[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
	          var res = null;
	          return v === "x" ? res = $$.clipPathForXAxis : v === "y" && config.axis_y_inner && (res = $$.clipPathForYAxis), res;
	        }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_".concat(v, "_show")] ? "visible" : "hidden"), $$.axes[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", function () {
	          return _this.textAnchorForAxisLabel(v);
	        }), _this.generateAxes(v);
	      });
	    }
	    /**
	     * Set axis orient according option value
	     * @private
	     */

	  }, {
	    key: "setOrient",
	    value: function setOrient() {
	      var $$ = this.owner,
	          config = $$.config,
	          isRotated = config.axis_rotated,
	          yInner = config.axis_y_inner,
	          y2Inner = config.axis_y2_inner;
	      $$.xOrient = isRotated ? "left" : "bottom", $$.yOrient = isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left", $$.y2Orient = isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right", $$.subXOrient = isRotated ? "left" : "bottom";
	    }
	    /**
	     * Generate axes
	     * It's used when axis' axes option is set
	     * @param {String} id Axis id
	     * @private
	     */

	  }, {
	    key: "generateAxes",
	    value: function generateAxes(id) {
	      var d3Axis,
	          $$ = this.owner,
	          config = $$.config,
	          axes = [],
	          axesConfig = config["axis_".concat(id, "_axes")],
	          isRotated = config.axis_rotated;
	      id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
	        var tick = v.tick || {},
	            scale = $$[id].copy();
	        v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(tick.format || function (x) {
	          return x;
	        }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
	      }), $$.axesList[id] = axes;
	    }
	    /**
	     * Update axes nodes
	     * @private
	     */

	  }, {
	    key: "updateAxes",
	    value: function updateAxes() {
	      var $$ = this.owner,
	          config = $$.config;
	      Object.keys($$.axesList).forEach(function (id) {
	        var axesConfig = config["axis_".concat(id, "_axes")],
	            scale = $$[id].copy(),
	            range = scale.range();
	        $$.axesList[id].forEach(function (v, i) {
	          var axisRange = v.scale().range(); // adjust range value with the current
	          // https://github.com/naver/billboard.js/issues/859

	          range.every(function (v, i) {
	            return v === axisRange[i];
	          }) || v.scale().range(range);
	          var className = "".concat(getAxisClassName(id), "-").concat(i + 1),
	              g = $$.main.select(".".concat(className.replace(/\s/, ".")));
	          g.empty() ? g = $$.main.append("g").attr("class", className).style("visibility", config["axis_".concat(id, "_show")] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), $$.xAxis.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
	        });
	      });
	    } // called from : updateScales() & getMaxTickWidth()

	  }, {
	    key: "getAxis",
	    value: function getAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
	      var $$ = this.owner,
	          config = $$.config,
	          isX = /^(x|subX)$/.test(name),
	          type = isX ? "x" : name,
	          isCategory = isX && $$.isCategorized(),
	          orient = $$["".concat(name, "Orient")],
	          tickFormat = isX ? $$.xAxisTickFormat : config["axis_".concat(name, "_tick_format")],
	          tickTextRotate = noTickTextRotate ? 0 : $$.getAxisTickRotate(type),
	          tickValues = isX ? $$.xAxisTickValues : $$["".concat(name, "AxisTickValues")],
	          axisParams = mergeObj({
	        outerTick: outerTick,
	        noTransition: noTransition,
	        config: config,
	        name: name,
	        tickTextRotate: tickTextRotate
	      }, isX && {
	        isCategory: isCategory,
	        tickMultiline: config.axis_x_tick_multiline,
	        tickWidth: config.axis_x_tick_width,
	        tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
	        orgXScale: $$.x
	      });
	      isX || (axisParams.tickStepSize = config["axis_".concat(type, "_tick_stepSize")]);
	      var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.zoomScale || scale).orient(orient);
	      isX && $$.isTimeSeries() && tickValues && !isFunction(tickValues) ? tickValues = tickValues.map(function (v) {
	        return $$.parseDate(v);
	      }) : !isX && $$.isTimeSeriesY() && (axis.ticks(config.axis_y_tick_time_value), tickValues = null), tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
	        return "".concat(x, "%");
	      }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1));
	      var tickCount = config["axis_".concat(type, "_tick_count")];
	      return tickCount && axis.ticks(tickCount), axis;
	    }
	  }, {
	    key: "updateXAxisTickValues",
	    value: function updateXAxisTickValues(targets, axis) {
	      var values,
	          $$ = this.owner,
	          config = $$.config,
	          fit = config.axis_x_tick_fit,
	          count = config.axis_x_tick_count;
	      return (fit || count && fit) && (values = $$.mapTargetsToUniqueXs(targets), $$.isCategorized() && count > values.length && (count = values.length), values = this.generateTickValues(values, count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.xAxis && ($$.xAxis.tickValues(values), $$.subXAxis.tickValues(values)), values;
	    }
	  }, {
	    key: "getId",
	    value: function getId(id) {
	      var config = this.owner.config;
	      return id in config.data_axes ? config.data_axes[id] : "y";
	    }
	  }, {
	    key: "getXAxisTickFormat",
	    value: function getXAxisTickFormat() {
	      var format,
	          $$ = this.owner,
	          config = $$.config,
	          tickFormat = config.axis_x_tick_format,
	          isTimeSeries = $$.isTimeSeries(),
	          isCategorized = $$.isCategorized();
	      return tickFormat ? isFunction(tickFormat) ? format = tickFormat : isTimeSeries && (format = function (date) {
	        return date ? $$.axisTimeFormat(tickFormat)(date) : "";
	      }) : format = isTimeSeries ? $$.defaultAxisTimeFormat : isCategorized ? $$.categoryName : function (v) {
	        return v < 0 ? v.toFixed(0) : v;
	      }, isFunction(format) ? function (v) {
	        return format.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
	      } : format;
	    }
	  }, {
	    key: "getTickValues",
	    value: function getTickValues(id) {
	      var $$ = this.owner,
	          tickValues = $$.config["axis_".concat(id, "_tick_values")],
	          axis = $$["".concat(id, "Axis")];
	      return (isFunction(tickValues) ? tickValues() : tickValues) || (axis ? axis.tickValues() : undefined);
	    }
	  }, {
	    key: "getLabelOptionByAxisId",
	    value: function getLabelOptionByAxisId(id) {
	      return this.owner.config["axis_".concat(id, "_label")];
	    }
	  }, {
	    key: "getLabelText",
	    value: function getLabelText(id) {
	      var option = this.getLabelOptionByAxisId(id);
	      return isString(option) ? option : option ? option.text : null;
	    }
	  }, {
	    key: "setLabelText",
	    value: function setLabelText(id, text) {
	      var $$ = this.owner,
	          config = $$.config,
	          option = this.getLabelOptionByAxisId(id);
	      isString(option) ? config["axis_".concat(id, "_label")] = text : option && (option.text = text);
	    }
	  }, {
	    key: "getLabelPosition",
	    value: function getLabelPosition(id, defaultPosition) {
	      var isRotated = this.owner.config.axis_rotated,
	          option = this.getLabelOptionByAxisId(id),
	          position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
	          has = function (v) {
	        return !!~position.indexOf(v);
	      };

	      return {
	        isInner: has("inner"),
	        isOuter: has("outer"),
	        isLeft: has("left"),
	        isCenter: has("center"),
	        isRight: has("right"),
	        isTop: has("top"),
	        isMiddle: has("middle"),
	        isBottom: has("bottom")
	      };
	    }
	  }, {
	    key: "getAxisLabelPosition",
	    value: function getAxisLabelPosition(id) {
	      return this.getLabelPosition(id, id === "x" ? ["inner-top", "inner-right"] : ["inner-right", "inner-top"]);
	    }
	  }, {
	    key: "getLabelPositionById",
	    value: function getLabelPositionById(id) {
	      return this.getAxisLabelPosition(id);
	    }
	  }, {
	    key: "xForAxisLabel",
	    value: function xForAxisLabel(id) {
	      var $$ = this.owner,
	          position = this.getAxisLabelPosition(id),
	          x = position.isMiddle ? -$$.height / 2 : 0;
	      return isHorizontal($$, id !== "x") ? x = position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width : position.isBottom && (x = -$$.height), x;
	    }
	  }, {
	    key: "dxForAxisLabel",
	    value: function dxForAxisLabel(id) {
	      var $$ = this.owner,
	          position = this.getAxisLabelPosition(id),
	          dx = position.isBottom ? "0.5em" : "0";
	      return isHorizontal($$, id !== "x") ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
	    }
	  }, {
	    key: "textAnchorForAxisLabel",
	    value: function textAnchorForAxisLabel(id) {
	      var $$ = this.owner,
	          position = this.getAxisLabelPosition(id),
	          anchor = position.isMiddle ? "middle" : "end";
	      return isHorizontal($$, id !== "x") ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
	    }
	  }, {
	    key: "dyForAxisLabel",
	    value: function dyForAxisLabel(id) {
	      var dy,
	          $$ = this.owner,
	          config = $$.config,
	          isRotated = config.axis_rotated,
	          isInner = this.getAxisLabelPosition(id).isInner,
	          tickRotate = config["axis_".concat(id, "_tick_rotate")] ? $$.getHorizontalAxisHeight(id) : 0,
	          maxTickWidth = this.getMaxTickWidth(id);

	      if (id === "x") {
	        var xHeight = config.axis_x_height;
	        dy = isRotated ? isInner ? "1.2em" : -25 - maxTickWidth : isInner ? "-0.5em" : xHeight ? xHeight - 10 : tickRotate ? tickRotate - 10 : "3em";
	      } else dy = {
	        y: ["-0.5em", 10, "3em", "1.2em", 10],
	        y2: ["1.2em", -20, "-2.2em", "-0.5em", 15]
	      }[id], dy = isRotated ? isInner ? dy[0] : tickRotate ? tickRotate * (id === "y2" ? -1 : 1) - dy[1] : dy[2] : isInner ? dy[3] : (dy[4] + (config["axis_".concat(id, "_inner")] ? 0 : maxTickWidth + dy[4])) * (id === "y" ? -1 : 1);

	      return dy;
	    }
	  }, {
	    key: "getMaxTickWidth",
	    value: function getMaxTickWidth(id, withoutRecompute) {
	      var $$ = this.owner,
	          config = $$.config,
	          currentTickMax = $$.currentMaxTickWidths[id],
	          maxWidth = 0;
	      if (withoutRecompute || !config["axis_".concat(id, "_show")] || $$.filterTargetsToShow().length === 0) return currentTickMax.size;

	      if ($$.svg) {
	        var isYAxis = /^y2?$/.test(id),
	            targetsToShow = $$.filterTargetsToShow($$.data.targets),
	            scale = $$[id].copy().domain($$["get".concat(isYAxis ? "Y" : "X", "Domain")](targetsToShow, id)),
	            domain = scale.domain();
	        // do not compute if domain is same
	        if (domain[0] === domain[1] || isArray(currentTickMax.domain) && currentTickMax.domain[0] === currentTickMax.domain[1]) return currentTickMax.size;
	        currentTickMax.domain = domain;
	        var axis = this.getAxis(id, scale, !1, !1, !0),
	            tickCount = config["axis_".concat(id, "_tick_count")],
	            tickValues = config["axis_".concat(id, "_tick_values")];
	        !tickValues && tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
	        var dummy = $$.selectChart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
	        axis.create(dummy), dummy.selectAll("text").each(function (d, i) {
	          var currentTextWidth = this.getBoundingClientRect().width;
	          maxWidth = Math.max(maxWidth, currentTextWidth), id === "x" && ($$.currentMaxTickWidths.x.ticks[i] = currentTextWidth);
	        }), dummy.remove();
	      }

	      return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
	    }
	  }, {
	    key: "getXAxisTickTextY2Overflow",
	    value: function getXAxisTickTextY2Overflow(defaultPadding) {
	      var $$ = this.owner,
	          config = $$.config,
	          xAxisTickRotate = $$.getAxisTickRotate("x");

	      if (($$.isCategorized() || $$.isTimeSeries()) && config.axis_x_tick_fit && !config.axis_x_tick_culling && !config.axis_x_tick_multiline && xAxisTickRotate > 0 && xAxisTickRotate < 90) {
	        var widthWithoutCurrentPaddingLeft = $$.currentWidth - $$.getCurrentPaddingLeft(),
	            maxOverflow = this.getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft - defaultPadding),
	            xAxisTickTextY2Overflow = Math.max(0, maxOverflow) + defaultPadding;
	        // for display inconsistencies between browsers
	        return Math.min(xAxisTickTextY2Overflow, widthWithoutCurrentPaddingLeft / 2);
	      }

	      return 0;
	    }
	  }, {
	    key: "getXAxisTickMaxOverflow",
	    value: function getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft) {
	      for (var $$ = this.owner, config = $$.config, isTimeSeries = $$.isTimeSeries(), tickTextWidths = $$.currentMaxTickWidths.x.ticks, tickCount = tickTextWidths.length, _this$x$padding = this.x.padding, left = _this$x$padding.left, right = _this$x$padding.right, maxOverflow = 0, remaining = tickCount - (isTimeSeries && config.axis_x_tick_fit ? .5 : 0), i = 0; i < tickCount; i++) {
	        var tickIndex = i + 1,
	            rotatedTickTextWidth = Math.cos(Math.PI * xAxisTickRotate / 180) * tickTextWidths[i],
	            ticksBeforeTickText = tickIndex - (isTimeSeries ? 1 : .5) + left;

	        // Skip ticks if there are no ticks before them
	        if (!(ticksBeforeTickText <= 0)) {
	          var tickLength = (widthWithoutCurrentPaddingLeft - rotatedTickTextWidth) / ticksBeforeTickText;
	          maxOverflow = Math.max(maxOverflow, rotatedTickTextWidth - tickLength / 2 - ((remaining - tickIndex) * tickLength + right * tickLength));
	        }
	      }

	      var tickOffset = 0;

	      if (!isTimeSeries) {
	        var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])().domain([left * -1, $$.getXDomainMax($$.data.targets) + 1 + right]).range([0, widthWithoutCurrentPaddingLeft - maxOverflow]);
	        tickOffset = Math.ceil((scale(1) - scale(0)) / 2);
	      }

	      return maxOverflow + tickOffset;
	    }
	    /**
	     * Get x Axis padding
	     * @param {Number} tickCount Tick count
	     * @return {Object} Padding object values with 'left' & 'right' key
	     * @private
	     */

	  }, {
	    key: "getXAxisPadding",
	    value: function getXAxisPadding(tickCount) {
	      var $$ = this.owner,
	          padding = $$.config.axis_x_padding;

	      if (isEmpty(padding) ? padding = {
	        left: 0,
	        right: 0
	      } : (padding.left = padding.left || 0, padding.right = padding.right || 0), $$.isTimeSeries()) {
	        var firstX = +$$.getXDomainMin($$.data.targets),
	            lastX = +$$.getXDomainMax($$.data.targets),
	            timeDiff = lastX - firstX,
	            range = timeDiff + padding.left + padding.right,
	            relativeTickWidth = timeDiff / tickCount / range,
	            left = padding.left / range / relativeTickWidth || 0,
	            _right = padding.right / range / relativeTickWidth || 0;

	        padding = {
	          left: left,
	          right: _right
	        };
	      }

	      return padding;
	    }
	  }, {
	    key: "updateLabels",
	    value: function updateLabels(withTransition) {
	      var _this2 = this,
	          $$ = this.owner,
	          labels = {
	        x: $$.main.select(".".concat(config_classes.axisX, " .").concat(config_classes.axisXLabel)),
	        y: $$.main.select(".".concat(config_classes.axisY, " .").concat(config_classes.axisYLabel)),
	        y2: $$.main.select(".".concat(config_classes.axisY2, " .").concat(config_classes.axisY2Label))
	      };

	      Object.keys(labels).filter(function (id) {
	        return !labels[id].empty();
	      }).forEach(function (v) {
	        var node = labels[v];
	        (withTransition ? node.transition() : node).attr("x", function () {
	          return _this2.xForAxisLabel(v);
	        }).attr("dx", function () {
	          return _this2.dxForAxisLabel(v);
	        }).attr("dy", function () {
	          return _this2.dyForAxisLabel(v);
	        }).text(function () {
	          return _this2.getLabelText(v);
	        });
	      });
	    }
	  }, {
	    key: "getPadding",
	    value: function getPadding(padding, key, defaultValue, domainLength) {
	      var p = isNumber(padding) ? padding : padding[key];
	      return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
	    }
	  }, {
	    key: "convertPixelsToAxisPadding",
	    value: function convertPixelsToAxisPadding(pixels, domainLength) {
	      var $$ = this.owner,
	          length = $$.config.axis_rotated ? $$.width : $$.height;
	      return domainLength * (pixels / length);
	    }
	  }, {
	    key: "generateTickValues",
	    value: function generateTickValues(values, tickCount, forTimeSeries) {
	      var tickValues = values;

	      if (tickCount) {
	        var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

	        if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
	          var tickValue,
	              isCategorized = this.owner.isCategorized(),
	              count = targetCount - 2,
	              start = values[0],
	              end = values[values.length - 1];
	          tickValues = [start];

	          for (var i = 0; i < count; i++) tickValue = +start + (end - start) / (count + 1) * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

	          tickValues.push(end);
	        }
	      }

	      return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
	        return a - b;
	      })), tickValues;
	    }
	  }, {
	    key: "generateTransitions",
	    value: function generateTransitions(duration) {
	      var $$ = this.owner,
	          axes = $$.axes,
	          _map = ["x", "y", "y2", "subx"].map(function (v) {
	        var axis = axes[v];
	        return axis && duration && (axis = axis.transition().duration(duration)), axis;
	      }),
	          _map2 = _slicedToArray(_map, 4),
	          axisX = _map2[0],
	          axisY = _map2[1],
	          axisY2 = _map2[2],
	          axisSubX = _map2[3];

	      return {
	        axisX: axisX,
	        axisY: axisY,
	        axisY2: axisY2,
	        axisSubX: axisSubX
	      };
	    }
	  }, {
	    key: "redraw",
	    value: function redraw(transitions, isHidden, isInit) {
	      var $$ = this.owner,
	          opacity = isHidden ? "0" : "1";
	      ["x", "y", "y2", "subX"].forEach(function (id) {
	        var axis = $$["".concat(id, "Axis")];
	        axis && (!isInit && (axis.config.withoutTransition = !$$.config.transition_duration), $$.axes[id.toLowerCase()].style("opacity", opacity), axis.create(transitions["axis".concat(capitalize(id))]));
	      }), this.updateAxes();
	    }
	    /**
	     * Redraw axis
	     * @param {Object} targetsToShow targets data to be shown
	     * @param {Object} wth
	     * @param {Ojbect} transitions
	     * @param {Object} flow
	     * @private
	     */

	  }, {
	    key: "redrawAxis",
	    value: function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
	      var xDomainForZoom,
	          _this3 = this,
	          $$ = this.owner,
	          config = $$.config,
	          hasZoom = !!$$.zoomScale;

	      !hasZoom && $$.isCategorized() && targetsToShow.length === 0 && $$.x.domain([0, $$.axes.x.selectAll(".tick").size()]), $$.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : $$.xAxis && ($$.xAxis.tickValues([]), $$.subXAxis.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = $$.x.orgDomain()), ["y", "y2"].forEach(function (key) {
	        var axis = $$[key];

	        if (axis) {
	          var tickValues = config["axis_".concat(key, "_tick_values")],
	              tickCount = config["axis_".concat(key, "_tick_count")];

	          if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
	            var domain = axis.domain();
	            $$["".concat(key, "Axis")].tickValues(_this3.generateTickValues(domain, domain.every(function (v) {
	              return v === 0;
	            }) ? 1 : tickCount, $$.isTimeSeriesY()));
	          }
	        }
	      }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && ($$.subY && $$.subY.domain($$.getYDomain(targetsToShow, "y")), $$.subY2 && $$.subY2.domain($$.getYDomain(targetsToShow, "y2")));
	    }
	    /**
	     * Set manual culling
	     * @private
	     */

	  }, {
	    key: "setCulling",
	    value: function setCulling() {
	      var $$ = this.owner,
	          config = $$.config;
	      ["subx", "x", "y", "y2"].forEach(function (type) {
	        var axis = $$.axes[type],
	            id = type === "subx" ? "x" : type,
	            toCull = config["axis_".concat(id, "_tick_culling")]; // subchart x axis should be aligned with x axis culling

	        if (axis && toCull) {
	          var intervalForCulling,
	              tickText = axis.selectAll(".tick text"),
	              tickValues = sortValue(tickText.data()),
	              tickSize = tickValues.length,
	              cullingMax = config["axis_".concat(id, "_tick_culling_max")];

	          if (tickSize) {
	            for (var i = 1; i < tickSize; i++) if (tickSize / i < cullingMax) {
	              intervalForCulling = i;
	              break;
	            }

	            tickText.each(function (d) {
	              this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
	            });
	          } else tickText.style("display", "block"); // set/unset x_axis_tick_clippath


	          if (type === "x") {
	            var clipPath = $$.clipXAxisTickMaxWidth ? $$.clipPathForXAxisTickTexts : null;
	            $$.svg.selectAll(".".concat(config_classes.axisX, " .tick text")).attr("clip-path", clipPath);
	          }
	        }
	      });
	    }
	  }]), Axis;
	}();


	// CONCATENATED MODULE: ./src/internals/ChartInternal.js




	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 * @ignore
	 */







	/**
	 * Internal chart class.
	 * - Note: Instantiated internally, not exposed for public.
	 * @class ChartInternal
	 * @ignore
	 * @private
	 */

	var ChartInternal_ChartInternal = /*#__PURE__*/function () {
	  function ChartInternal(api) {
	    _classCallCheck(this, ChartInternal);

	    var $$ = this;
	    $$.api = api, $$.config = $$.getOptions(), $$.data = {}, $$.cache = {}, $$.axes = {}, $$.rendered = !1;
	  }

	  return _createClass(ChartInternal, [{
	    key: "beforeInit",
	    value: function beforeInit() {
	      var $$ = this;
	      $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$, $$.api);
	    }
	  }, {
	    key: "afterInit",
	    value: function afterInit() {
	      var $$ = this;
	      $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$, $$.api);
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      var $$ = this,
	          config = $$.config;
	      $$.initParams();
	      var bindto = {
	        element: config.bindto,
	        classname: "bb"
	      };
	      isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $$.selectChart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $$.selectChart.empty() && ($$.selectChart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $$.selectChart.html("").classed(bindto.classname, !0), $$.initToRender();
	    }
	    /**
	     * Initialize the rendering process
	     * @param {Boolean} forced Force to render process
	     * @private
	     */

	  }, {
	    key: "initToRender",
	    value: function initToRender(forced) {
	      var $$ = this,
	          config = $$.config,
	          target = $$.selectChart,
	          isHidden = function () {
	        return target.style("display") === "none" || target.style("visibility") === "hidden";
	      },
	          isLazy = config.render.lazy || isHidden(),
	          MutationObserver = win.MutationObserver;

	      if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
	        isHidden() || (observer.disconnect(), !$$.rendered && $$.initToRender(!0));
	      }).observe(target.node(), {
	        attributes: !0,
	        attributeFilter: ["class", "style"]
	      }), !isLazy || forced) {
	        var convertedData = $$.convertData(config, $$.initWithData);
	        convertedData && $$.initWithData(convertedData), $$.afterInit();
	      }
	    }
	  }, {
	    key: "initParams",
	    value: function initParams() {
	      var _this = this,
	          $$ = this,
	          config = $$.config,
	          isRotated = config.axis_rotated;

	      $$.datetimeId = "bb-".concat(+new Date()), $$.initClip(), $$.dragStart = null, $$.dragging = !1, $$.flowing = !1, $$.cancelClick = !1, $$.mouseover = !1, $$.transiting = !1, $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), $$.extraLineClasses = $$.generateExtraLineClass(), $$.dataTimeFormat = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], $$.axisTimeFormat = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
	      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";
	      $$.defaultAxisTimeFormat = function (d) {
	        var isZoomed = isDragZoom ? _this.zoomScale : _this.zoomScale && $$.x.orgDomain().toString() !== _this.zoomScale.domain().toString(),
	            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
	        return $$.axisTimeFormat(specifier)(d);
	      }, $$.hiddenTargetIds = [], $$.hiddenLegendIds = [], $$.focusedTargetIds = [], $$.defocusedTargetIds = [], $$.isLegendRight = config.legend_position === "right", $$.isLegendInset = config.legend_position === "inset", $$.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", $$.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", $$.legendStep = 0, $$.legendItemWidth = 0, $$.legendItemHeight = 0, $$.currentMaxTickWidths = {
	        x: {
	          size: 0,
	          ticks: [],
	          domain: ""
	        },
	        y: {
	          size: 0,
	          domain: ""
	        },
	        y2: {
	          size: 0,
	          domain: ""
	        }
	      }, $$.rotated_padding_left = 30, $$.rotated_padding_right = isRotated && !config.axis_x_show ? 0 : 30, $$.rotated_padding_top = 5, $$.withoutFadeIn = {}, $$.inputType = $$.convertInputType(), $$.axes.subx = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
	    }
	  }, {
	    key: "initWithData",
	    value: function initWithData(data) {
	      var $$ = this,
	          config = $$.config;

	      if ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom(), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0), $$.x && ($$.x.domain(sortValue($$.getXDomain($$.data.targets))), $$.subX.domain($$.x.domain()), $$.orgXDomain = $$.x.domain()), $$.y && ($$.y.domain($$.getYDomain($$.data.targets, "y")), $$.subY.domain($$.y.domain())), $$.y2 && ($$.y2.domain($$.getYDomain($$.data.targets, "y2")), $$.subY2 && $$.subY2.domain($$.y2.domain())), $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && $$.inputType) {
	        var isTouch = $$.inputType === "touch";
	        $$.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
	          return callFn(config.onover, $$, $$.api);
	        }).on(isTouch ? "touchend" : "mouseleave", function () {
	          return callFn(config.onout, $$, $$.api);
	        });
	      }

	      config.svg_classname && $$.svg.attr("class", config.svg_classname), $$.defs = $$.svg.append("defs"), $$.clipChart = $$.appendClip($$.defs, $$.clipId), $$.clipXAxis = $$.appendClip($$.defs, $$.clipIdForXAxis), $$.clipYAxis = $$.appendClip($$.defs, $$.clipIdForYAxis), $$.clipGrid = $$.appendClip($$.defs, $$.clipIdForGrid), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
	        return $$.defs.append(function () {
	          return p.node;
	        });
	      }), $$.updateSvgSize(), $$.bindResize();
	      // Define regions
	      var main = $$.svg.append("g").attr("transform", $$.getTranslate("main"));

	      // data.onmin/max callback
	      if ($$.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", "".concat(config_classes.text, " ").concat(config_classes.empty)).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
	      .attr("dominant-baseline", "middle"), $$.initRegion(), config.clipPath || $$.axis.init(), main.append("g").attr("class", config_classes.chart).attr("clip-path", $$.clipPath), $$.callPluginHook("$init"), $$.initEventRect(), $$.initChartElements(), $$.initGrid(), main.insert("rect", config.zoom_privileged ? null : "g.".concat(config_classes.regions)).attr("class", config_classes.zoomRect).attr("width", $$.width).attr("height", $$.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$, $$.api), $$.setBackground(), $$.redraw({
	        withTransition: !1,
	        withTransform: !0,
	        withUpdateXDomain: !0,
	        withUpdateOrgXDomain: !0,
	        withTransitionForAxis: !1,
	        initializing: !0
	      }), config.data_onmin || config.data_onmax) {
	        var minMax = $$.getMinMaxData();
	        callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
	      } // export element of the chart


	      $$.api.element = $$.selectChart.node(), $$.rendered = !0;
	    }
	  }, {
	    key: "initChartElements",
	    value: function initChartElements() {
	      var $$ = this;
	      ["Bar", "Radar", "Line", "Bubble", "Arc", "Gauge", "Pie"].forEach(function (v) {
	        $$["init".concat(v)]();
	      }), notEmpty($$.config.data_labels) && $$.initText();
	    }
	  }, {
	    key: "setChartElements",
	    value: function setChartElements() {
	      var $$ = this;
	      $$.api.$ = {
	        chart: $$.selectChart,
	        svg: $$.svg,
	        defs: $$.defs,
	        main: $$.main,
	        tooltip: $$.tooltip,
	        legend: $$.legend,
	        title: $$.title,
	        grid: $$.grid,
	        arc: $$.arcs,
	        bar: {
	          bars: $$.mainBar
	        },
	        line: {
	          lines: $$.mainLine,
	          areas: $$.mainArea,
	          circles: $$.mainCircle
	        },
	        text: {
	          texts: $$.mainText
	        }
	      };
	    }
	    /**
	     * Set background element/image
	     * @private
	     */

	  }, {
	    key: "setBackground",
	    value: function setBackground() {
	      var $$ = this,
	          bg = $$.config.background;

	      if (notEmpty(bg)) {
	        var element = $$.svg.select(".".concat(config_classes[$$.hasArcType() ? "chart" : "regions"])).insert(bg.imgUrl ? "image" : "rect", ":first-child");
	        bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color), element.attr("class", bg["class"] || null).attr("width", "100%").attr("height", "100%");
	      }
	    }
	  }, {
	    key: "smoothLines",
	    value: function smoothLines(el, type) {
	      type === "grid" && el.each(function () {
	        var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
	        ["x1", "x2", "y1", "y2"].forEach(function (v) {
	          return g.attr(v, Math.ceil(g.attr(v)));
	        });
	      });
	    }
	    /**
	     * Update size values
	     * @param {Boolean} isInit If is called at initialization
	     * @private
	     */

	  }, {
	    key: "updateSizes",
	    value: function updateSizes(isInit) {
	      var $$ = this;
	      isInit || $$.setContainerSize();
	      var config = $$.config,
	          isRotated = config.axis_rotated,
	          hasArc = $$.hasArcType(),
	          legend = {
	        width: $$.legend ? $$.getLegendWidth() : 0,
	        height: $$.legend ? $$.getLegendHeight() : 0
	      },
	          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legend.height,
	          xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
	          subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
	          subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
	      $$.margin = isRotated ? {
	        top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
	        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
	        bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
	        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
	      } : {
	        top: 4 + $$.getCurrentPaddingTop(),
	        // for top tick text
	        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
	        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
	        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
	      }, $$.margin2 = isRotated ? {
	        top: $$.margin.top,
	        right: NaN,
	        bottom: 20 + legendHeightForBottom,
	        left: $$.rotated_padding_left
	      } : {
	        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
	        right: NaN,
	        bottom: subchartXAxisHeight + legendHeightForBottom,
	        left: $$.margin.left
	      }, $$.margin3 = {
	        top: 0,
	        right: NaN,
	        bottom: 0,
	        left: 0
	      }, $$.updateSizeForLegend && $$.updateSizeForLegend(legend), $$.width = $$.currentWidth - $$.margin.left - $$.margin.right, $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom, $$.width < 0 && ($$.width = 0), $$.height < 0 && ($$.height = 0), $$.width2 = isRotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width, $$.height2 = isRotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom, $$.width2 < 0 && ($$.width2 = 0), $$.height2 < 0 && ($$.height2 = 0), $$.arcWidth = $$.width - ($$.isLegendRight ? legend.width + 10 : 0), $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && ($$.arcHeight += $$.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), $$.isLegendRight && hasArc && ($$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1), !hasArc && config.axis_x_show && config.axis_x_tick_autorotate && $$.updateXAxisTickClip();
	    }
	    /**
	     * Update targeted element with given data
	     * @param {Object} targets Data object formatted as 'target'
	     * @private
	     */

	  }, {
	    key: "updateTargets",
	    value: function updateTargets(targets) {
	      var $$ = this; // Text

	      $$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
	    }
	    /**
	     * Display targeted elements
	     * @private
	     */

	  }, {
	    key: "showTargets",
	    value: function showTargets() {
	      var $$ = this;
	      $$.svg.selectAll(".".concat(config_classes.target)).filter(function (d) {
	        return $$.isTargetToShow(d.id);
	      }).transition().duration($$.config.transition_duration).style("opacity", "1");
	    }
	  }, {
	    key: "getWithOption",
	    value: function getWithOption(options) {
	      var withOptions = {
	        Y: !0,
	        Subchart: !0,
	        Transition: !0,
	        EventRect: !0,
	        Dimension: !0,
	        TrimXDomain: !0,
	        Transform: !1,
	        UpdateXDomain: !1,
	        UpdateOrgXDomain: !1,
	        Legend: !1,
	        UpdateXAxis: "UpdateXDomain",
	        TransitionForExit: "Transition",
	        TransitionForAxis: "Transition"
	      };
	      return Object.keys(withOptions).forEach(function (key) {
	        var defVal = withOptions[key];
	        isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with".concat(key), defVal);
	      }), withOptions;
	    }
	  }, {
	    key: "redraw",
	    value: function redraw() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          transitionsValue = arguments.length > 1 ? arguments[1] : undefined,
	          $$ = this,
	          main = $$.main,
	          config = $$.config,
	          targetsToShow = $$.filterTargetsToShow($$.data.targets),
	          initializing = options.initializing,
	          flow = options.flow,
	          wth = $$.getWithOption(options),
	          duration = wth.Transition ? config.transition_duration : 0,
	          durationForExit = wth.TransitionForExit ? duration : 0,
	          durationForAxis = wth.TransitionForAxis ? duration : 0,
	          transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);
	      $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), config.data_empty_label_text && main.select("text.".concat(config_classes.text, ".").concat(config_classes.empty)).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $$.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(durationForExit), $$.mainText && main.selectAll(".".concat(config_classes.selectedCircles)).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent(), initializing && $$.setChartElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
	    }
	    /**
	     * Generate redraw list
	     * @param {Object} targets targets data to be shown
	     * @param {Object} flow
	     * @param {Object} duration
	     * @param {Boolean} withSubchart whether or not to show subchart
	     * @private
	     */

	  }, {
	    key: "generateRedrawList",
	    value: function generateRedrawList(targets, flow, duration, withSubchart) {
	      var $$ = this,
	          config = $$.config,
	          shape = $$.getDrawShape();
	      config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
	      // generate flow
	      var flowFn = flow && $$.generateFlow({
	        targets: targets,
	        flow: flow,
	        duration: flow.duration,
	        shape: shape,
	        xv: $$.xv.bind($$)
	      }),
	          isTransition = (duration || flowFn) && $$.isTabVisible(),
	          redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
	          afterRedraw = flow || config.onrendered ? function () {
	        flowFn && flowFn(), callFn(config.onrendered, $$, $$.api);
	      } : null;
	      if (afterRedraw) // Only use transition when current tab is visible.
	        if (isTransition && redrawList.length) {
	          // Wait for end of transitions for callback
	          var waitForDraw = $$.generateWait(); // transition should be derived from one transition

	          Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
	            redrawList.reduce(function (acc, t1) {
	              return acc.concat(t1);
	            }, []).forEach(function (t) {
	              return waitForDraw.add(t);
	            });
	          }).call(waitForDraw, afterRedraw);
	        } else $$.transiting || afterRedraw(); // update fadein condition

	      $$.mapToIds($$.data.targets).forEach(function (id) {
	        $$.withoutFadeIn[id] = !0;
	      });
	    }
	    /**
	     * Get the shape draw function
	     * @return {Object}
	     * @private
	     */

	  }, {
	    key: "getDrawShape",
	    value: function getDrawShape() {
	      var $$ = this,
	          isRotated = $$.config.axis_rotated,
	          hasRadar = $$.hasType("radar"),
	          shape = {
	        type: {},
	        indices: {}
	      };

	      // setup drawer - MEMO: these must be called after axis updated
	      if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
	        var indices = $$.getShapeIndices($$.isLineType);

	        if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
	          var _indices = $$.getShapeIndices($$.isAreaType);

	          shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
	        }
	      }

	      if ($$.hasType("bar")) {
	        var _indices2 = $$.getShapeIndices($$.isBarType);

	        shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
	      }

	      return shape.pos = {
	        xForText: $$.generateXYForText(shape.indices, !0),
	        yForText: $$.generateXYForText(shape.indices, !1),
	        // generate circle x/y functions depending on updated params
	        cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
	        cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
	      }, shape;
	    }
	  }, {
	    key: "getRedrawList",
	    value: function getRedrawList(shape, flow, flowFn, isTransition) {
	      var $$ = this,
	          config = $$.config,
	          hasArcType = $$.hasArcType(),
	          _shape$pos = shape.pos,
	          cx = _shape$pos.cx,
	          cy = _shape$pos.cy,
	          xForText = _shape$pos.xForText,
	          yForText = _shape$pos.yForText,
	          list = [];

	      if (!hasArcType) {
	        var _shape$type = shape.type,
	            area = _shape$type.area,
	            bar = _shape$type.bar,
	            line = _shape$type.line;
	        (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), flow || list.push($$.updateGridFocus());
	      }

	      return (!hasArcType || $$.hasType("radar")) && (notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition)), list.push($$.redrawCircle(cx, cy, isTransition, flowFn))), list;
	    }
	  }, {
	    key: "updateAndRedraw",
	    value: function updateAndRedraw() {
	      var transitions,
	          options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          $$ = this,
	          config = $$.config;
	      options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
	    }
	  }, {
	    key: "redrawWithoutRescale",
	    value: function redrawWithoutRescale() {
	      this.redraw({
	        withY: !1,
	        withSubchart: !1,
	        withEventRect: !1,
	        withTransitionForAxis: !1
	      });
	    }
	  }, {
	    key: "isTimeSeries",
	    value: function isTimeSeries() {
	      return this.config.axis_x_type === "timeseries";
	    }
	  }, {
	    key: "isCategorized",
	    value: function isCategorized() {
	      return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
	    }
	  }, {
	    key: "isCustomX",
	    value: function isCustomX() {
	      var $$ = this,
	          config = $$.config;
	      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
	    }
	  }, {
	    key: "isTimeSeriesY",
	    value: function isTimeSeriesY() {
	      return this.config.axis_y_type === "timeseries";
	    }
	  }, {
	    key: "getTranslate",
	    value: function getTranslate(target) {
	      var x,
	          y,
	          index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0,
	          $$ = this,
	          config = $$.config,
	          isRotated = config.axis_rotated,
	          hasGauge = $$.hasType("gauge"),
	          padding = 0;
	      if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel($$.margin.left), y = asHalfPixel($$.margin.top);else if (target === "context") x = asHalfPixel($$.margin2.left), y = asHalfPixel($$.margin2.top);else if (target === "legend") x = $$.margin3.left, y = $$.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : $$.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? $$.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : $$.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subx") x = 0, y = isRotated ? 0 : $$.height2;else if (target === "arc") x = $$.arcWidth / 2, y = $$.arcHeight / 2;else if (target === "radar") {
	        var _$$$getRadarSize = $$.getRadarSize(),
	            _$$$getRadarSize2 = _slicedToArray(_$$$getRadarSize, 1),
	            width = _$$$getRadarSize2[0];

	        x = $$.width / 2 - width, y = asHalfPixel($$.margin.top);
	      }
	      return "translate(".concat(x, ", ").concat(y, ")");
	    }
	  }, {
	    key: "initialOpacity",
	    value: function initialOpacity(d) {
	      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? "1" : "0";
	    }
	  }, {
	    key: "initialOpacityForCircle",
	    value: function initialOpacityForCircle(d) {
	      return this.getBaseValue(d) !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
	    }
	  }, {
	    key: "opacityForCircle",
	    value: function opacityForCircle(d) {
	      var opacity = this.config.point_show ? "1" : "0";
	      return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
	    }
	  }, {
	    key: "opacityForText",
	    value: function opacityForText() {
	      return this.hasDataLabel() ? "1" : "0";
	    }
	    /**
	     * Get the zoom or unzoomed scaled value
	     * @param {Date|Number|Object} d Data value
	     * @private
	     */

	  }, {
	    key: "xx",
	    value: function xx(d) {
	      var $$ = this,
	          fn = $$.config.zoom_enabled && $$.zoomScale ? $$.zoomScale : this.x;
	      return d ? fn(isValue(d.x) ? d.x : d) : null;
	    }
	  }, {
	    key: "xv",
	    value: function xv(d) {
	      var $$ = this,
	          value = $$.getBaseValue(d);
	      return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = $$.config.axis_x_categories.indexOf(value)), Math.ceil($$.x(value));
	    }
	  }, {
	    key: "yv",
	    value: function yv(d) {
	      var $$ = this,
	          yScale = d.axis && d.axis === "y2" ? $$.y2 : $$.y;
	      return Math.ceil(yScale($$.getBaseValue(d)));
	    }
	  }, {
	    key: "subxx",
	    value: function subxx(d) {
	      return d ? this.subX(d.x) : null;
	    }
	  }, {
	    key: "transformMain",
	    value: function transformMain(withTransition, transitions) {
	      var xAxis,
	          yAxis,
	          y2Axis,
	          $$ = this;
	      transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = $$.main.select(".".concat(config_classes.axisX)), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = $$.main.select(".".concat(config_classes.axisY)), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = $$.main.select(".".concat(config_classes.axisY2)), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), $$.main.select(".".concat(config_classes.chartArcs)).attr("transform", $$.getTranslate("arc"));
	    }
	  }, {
	    key: "transformAll",
	    value: function transformAll(withTransition, transitions) {
	      var $$ = this;
	      $$.transformMain(withTransition, transitions), $$.config.subchart_show && $$.transformContext(withTransition, transitions), $$.legend && $$.transformLegend(withTransition);
	    }
	  }, {
	    key: "updateSvgSize",
	    value: function updateSvgSize() {
	      var $$ = this,
	          brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
	          brushSize = {
	        width: 0,
	        height: 0
	      };
	      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), $$.svg.attr("width", $$.currentWidth).attr("height", $$.currentHeight), $$.svg.selectAll(["#".concat($$.clipId), "#".concat($$.clipIdForGrid)]).select("rect").attr("width", $$.width).attr("height", $$.height), $$.svg.select("#".concat($$.clipIdForXAxis)).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForYAxis)).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), $$.svg.select("#".concat($$.clipIdForSubchart)).select("rect").attr("width", $$.width).attr("height", brushSize.height), $$.svg.select(".".concat(config_classes.zoomRect)).attr("width", $$.width).attr("height", $$.height);
	    }
	  }, {
	    key: "updateDimension",
	    value: function updateDimension(withoutAxis) {
	      var $$ = this;
	      withoutAxis || ($$.xAxis && $$.config.axis_rotated ? ($$.xAxis.create($$.axes.x), $$.subXAxis.create($$.axes.subx)) : ($$.yAxis && $$.yAxis.create($$.axes.y), $$.y2Axis && $$.y2Axis.create($$.axes.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
	    }
	  }, {
	    key: "bindResize",
	    value: function bindResize() {
	      var $$ = this,
	          config = $$.config,
	          resizeFunction = $$.generateResize(),
	          list = [];
	      list.push(function () {
	        return callFn(config.onresize, $$, $$.api);
	      }), config.resize_auto && list.push(function () {
	        return $$.api.flush(!1, !0);
	      }), list.push(function () {
	        return callFn(config.onresized, $$, $$.api);
	      }), list.forEach(function (v) {
	        return resizeFunction.add(v);
	      }), win.addEventListener("resize", $$.resizeFunction = resizeFunction);
	    }
	  }, {
	    key: "generateResize",
	    value: function generateResize() {
	      function callResizeFn() {
	        callResizeFn.timeout && (win.clearTimeout(callResizeFn.timeout), callResizeFn.timeout = null), callResizeFn.timeout = win.setTimeout(function () {
	          fn.forEach(function (f) {
	            return f();
	          });
	        }, 200);
	      }

	      var fn = [];
	      return callResizeFn.add = function (f) {
	        return fn.push(f);
	      }, callResizeFn.remove = function (f) {
	        return fn.splice(fn.indexOf(f), 1);
	      }, callResizeFn;
	    }
	  }, {
	    key: "endall",
	    value: function endall(transition, callback) {
	      var n = 0;
	      transition.each(function () {
	        return ++n;
	      }).on("end", function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

	        --n || callback.apply.apply(callback, [this].concat(args));
	      });
	    }
	  }, {
	    key: "generateWait",
	    value: function generateWait() {
	      var transitionsToWait = [],
	          f = function (transition, callback) {
	        function loop() {
	          for (var t, done = 0, i = 0; t = transitionsToWait[i]; i++) {
	            if (t === !0 || t.empty && t.empty()) {
	              done++;
	              continue;
	            }

	            try {
	              t.transition();
	            } catch (e) {
	              done++;
	            }
	          }

	          timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
	        }

	        var timer;
	        loop();
	      };

	      return f.add = function (transition) {
	        isArray(transition) ? transitionsToWait = transitionsToWait.concat(transition) : transitionsToWait.push(transition);
	      }, f;
	    }
	  }, {
	    key: "parseDate",
	    value: function parseDate(date) {
	      var parsedDate,
	          $$ = this;
	      return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.dataTimeFormat($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '".concat(date, "' to Date object")), parsedDate;
	    }
	  }, {
	    key: "isTabVisible",
	    value: function isTabVisible() {
	      return !browser_doc.hidden;
	    }
	  }, {
	    key: "convertInputType",
	    value: function convertInputType() {
	      var $$ = this,
	          config = $$.config,
	          isMobile = !1;

	      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop
	      if (/Mobi/.test(win.navigator.userAgent) && config.interaction_inputType_touch) {
	        // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
	        var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
	            hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
	        // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

	        isMobile = hasTouchPoints || hasTouch;
	      }

	      var hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in win;
	      return hasMouse && "mouse" || isMobile && "touch" || null;
	    }
	    /**
	     * Call plugin hook
	     * @param {String} phase The lifecycle phase
	     * @private
	     */

	  }, {
	    key: "callPluginHook",
	    value: function callPluginHook(phase) {
	      for (var _this2 = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

	      this.config.plugins.forEach(function (v) {
	        phase === "$beforeInit" && (v.$$ = _this2, _this2.api.plugins.push(v)), v[phase].apply(v, args);
	      });
	    }
	  }]), ChartInternal;
	}();


	// CONCATENATED MODULE: ./src/internals/Chart.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

	/**
	 * Main chart class.
	 * - Note: Instantiated via `bb.generate()`.
	 * @class Chart
	 * @example
	 * var chart = bb.generate({
	 *  data: {
	 *    columns: [
	 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
	 * 	    ["count1", 11, 8, 7, 6, 5 ],
	 *	    ["count2", 9, 3, 6, 2, 8 ]
	 *   ]}
	 * }
	 * @see {@link bb.generate} for the initialization.
	*/

	/**
	 * Access instance's primary node elements
	 * @member {Object} $
	 * @property {Object} $
	 * @property {d3.selection} $.chart Wrapper element
	 * @property {d3.selection} $.svg Main svg element
	 * @property {d3.selection} $.defs Definition element
	 * @property {d3.selection} $.main Main grouping element
	 * @property {d3.selection} $.tooltip Tooltip element
	 * @property {d3.selection} $.legend Legend element
	 * @property {d3.selection} $.title Title element
	 * @property {d3.selection} $.grid Grid element
	 * @property {d3.selection} $.arc Arc element
	 * @property {Object} $.bar
	 * @property {d3.selection} $.bar.bars Bar elements
	 * @property {Object} $.line
	 * @property {d3.selection} $.line.lines Line elements
	 * @property {d3.selection} $.line.areas Areas elements
	 * @property {d3.selection} $.line.circles Data point circle elements
	 * @property {Object} $.text
	 * @property {d3.selection} $.text.texts Data label text elements
	 * @memberof Chart
	 * @example
	 * var chart = bb.generate({ ... });
	 *
	 * chart.$.chart; // wrapper element
	 * chart.$.line.circles;  // all data point circle elements
	 */

	var Chart_Chart = function Chart(config) {
	  _classCallCheck(this, Chart);

	  var $$ = new ChartInternal_ChartInternal(this);
	  /**
	   * Plugin instance array
	   * @member {Array} plugins
	   * @memberof Chart
	   * @instance
	   	 * @example
	   *  var chart = bb.generate({
	   *     ...
	   *     plugins: [
	   *        new bb.plugin.stanford({ ... }),
	   *        new PluginA()
	   *     ]
	   *  });
	   *
	   *  chart.plugins; // [Stanford, PluginA] - instance array
	   */

	  // bind "this" to nested API
	  this.plugins = [], this.internal = $$, $$.loadConfig(config), $$.beforeInit(config), $$.init(), function bindThis(fn, target, argThis) {
	    Object.keys(fn).forEach(function (key) {
	      target[key] = fn[key].bind(argThis), Object.keys(fn[key]).length && bindThis(fn[key], target[key], argThis);
	    });
	  }(Chart.prototype, this, this);
	};


	// CONCATENATED MODULE: ./src/config/Options.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

	/**
	 * Class to set options on generating chart.
	 * - It's instantiated internally, not exposed for public.
	 * @class Options
	 * @see {@link bb.generate} to use these options on generating the chart
	 */
	var Options_Options = function Options() {
	  return _classCallCheck(this, Options), {
	    /**
	     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
	     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
	     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
	     * @name bindto
	     * @memberof Options
	     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
	     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
	     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
	     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
	     * @default #chart
	     * @example
	     * bindto: "#myContainer"
	     *
	     * // or HTMLElement
	     * bindto: document.getElementById("myContainer")
	     *
	     * // or D3 selection object
	     * bindto: d3.select("#myContainer")
	     *
	     * // or to change default classname
	     * bindto: {
	     *    element: "#chart",
	     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
	     * }
	     */
	    bindto: "#chart",

	    /**
	     * Set chart background.
	     * @name background
	     * @memberof Options
	     * @property {String} background.class Specify the class name for background element.
	     * @property {String} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
	     * @property {String} background.imgUrl Specify the image url string for background.
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
	     * @example
	     * background: {
	     *    class: "myClass",
	     *    color: "red",
	     *
	     *    // Set image url for background.
	     *    // If specified, 'color' option will be ignored.
	     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
	     * }
	     */
	    background: {},

	    /**
	     * Set 'clip-path' attribute for chart element
	     * - **NOTE:**
	     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
	     *  > Is to make chart element positioned over axis element.
	     * @name clipPath
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
	     * @example
	     * // don't set 'clip-path' attribute
	     * clipPath: false
	     */
	    clipPath: !0,

	    /**
	     * Set svg element's class name
	     * @name svg
	     * @memberof Options
	     * @type {Object}
	     * @property {String} [svg.classname] class name for svg element
	     * @example
	     * svg: {
	              *   classname: "test_class"
	     * }
	     */
	    svg_classname: undefined,

	    /**
	     * The desired size of the chart element.
	     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
	     * @name size
	     * @memberof Options
	     * @type {Object}
	     * @property {Number} [size.width] width of the chart element
	     * @property {Number} [size.height] height of the chart element
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
	     * @example
	     * size: {
	              *   width: 640,
	              *   height: 480
	     * }
	     */
	    size_width: undefined,
	    size_height: undefined,

	    /**
	     * The padding of the chart element.
	     * @name padding
	     * @memberof Options
	     * @type {Object}
	     * @property {Number} [padding.top] padding on the top of chart
	     * @property {Number} [padding.right] padding on the right of chart
	     * @property {Number} [padding.bottom] padding on the bottom of chart
	     * @property {Number} [padding.left] padding on the left of chart
	     * @example
	     * padding: {
	              *   top: 20,
	              *   right: 20,
	              *   bottom: 20,
	              *   left: 20
	     * }
	     */
	    padding_left: undefined,
	    padding_right: undefined,
	    padding_top: undefined,
	    padding_bottom: undefined,

	    /**
	     * Set chart resize options
	     * @name resize
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
	     * @example
	     *  resize: {
	     *      auto: false
	     *  }
	     */
	    resize_auto: !0,

	    /**
	     * Set zoom options
	     * @name zoom
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [zoom.enabled=false] Enable zooming.
	     * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
	     *  - **Available types:**
	     *    - wheel
	     *    - drag
	     * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
	     *  If true set, y domain will be updated according to the zoomed region.
	     * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
	     * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
	     * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
	     * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
	     *  Specified function receives the zoom event.
	     * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
	     *  Specified function receives the zoomed domain.
	     * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
	     *  Specified function receives the zoomed domain.
	     * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
	     * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
	     * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
	     * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
	     * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
	     * @example
	     *  zoom: {
	     *      enabled: {
	              *          type: "drag"
	              *      },
	     *      rescale: true,
	     *      extent: [1, 100]  // enable more zooming
	     *      x: {
	     *          min: -1,  // set min range
	     *          max: 10  // set max range
	     *      },
	     *      onzoomstart: function(event) { ... },
	     *      onzoom: function(domain) { ... },
	     *      onzoomend: function(domain) { ... },
	     *
	     *      // show reset button when is zoomed-in
	     *      resetButton: true,
	     *
	     *      resetButton: {
	     *          // onclick callback when reset button is clicked
	     *          onclick: function(button) {
	     *            button; // Reset button element reference
	     *            ...
	     *          },
	     *
	     *          // customized text value for reset zoom button
	     *          text: "Unzoom"
	     *      }
	     *  }
	     */
	    zoom_enabled: undefined,
	    zoom_extent: undefined,
	    zoom_privileged: !1,
	    zoom_rescale: !1,
	    zoom_onzoom: undefined,
	    zoom_onzoomstart: undefined,
	    zoom_onzoomend: undefined,
	    zoom_resetButton: !0,
	    zoom_x_min: undefined,
	    zoom_x_max: undefined,

	    /**
	     * Interaction options
	     * @name interaction
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
	     *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
	     * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
	     * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
	     * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
	     * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
	     * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
	     * @example
	     * interaction: {
	              *    enabled: false,
	              *    brighten: false,
	              *    inputType: {
	              *        mouse: true,
	              *        touch: false
	              *
	              *        // or declare preventDefault explicitly.
	              *        // In this case touch inputType is enabled by default
	              *        touch: {
	              *            preventDefault: true
	              *
	              *            // or threshold pixel value (pixel moved from touchstart to touchmove)
	              *            preventDefault: 5
	              *        }
	              *    }
	     * }
	     */
	    interaction_enabled: !0,
	    interaction_brighten: !0,
	    interaction_inputType_mouse: !0,
	    interaction_inputType_touch: {},

	    /**
	     * Set a callback to execute when mouse/touch enters the chart.
	     * @name onover
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onover: function(ctx) {
	     *   ...
	     * }
	     */
	    onover: undefined,

	    /**
	     * Set a callback to execute when mouse/touch leaves the chart.
	     * @name onout
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onout: function(ctx) {
	     *   ...
	     * }
	     */
	    onout: undefined,

	    /**
	     * Set a callback to execute when user resizes the screen.
	     * @name onresize
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onresize: function(ctx) {
	     *   ...
	     * }
	     */
	    onresize: undefined,

	    /**
	     * Set a callback to execute when screen resize finished.
	     * @name onresized
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onresized: function(ctx) {
	     *   ...
	     * }
	     */
	    onresized: undefined,

	    /**
	     * Set a callback to execute before the chart is initialized
	     * @name onbeforeinit
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onbeforeinit: function(ctx) {
	     *   ...
	     * }
	     */
	    onbeforeinit: undefined,

	    /**
	     * Set a callback to execute when the chart is initialized.
	     * @name oninit
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * oninit: function(ctx) {
	     *   ...
	     * }
	     */
	    oninit: undefined,

	    /**
	     * Set a callback to execute after the chart is initialized
	     * @name onafterinit
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onafterinit: function(ctx) {
	     *   ...
	     * }
	     */
	    onafterinit: undefined,

	    /**
	     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
	     * @name onrendered
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * // @param {Chart} ctx - Instance itself
	     * onrendered: function(ctx) {
	     *   ...
	     * }
	     */
	    onrendered: undefined,

	    /**
	     * Set duration of transition (in milliseconds) for chart animation.<br><br>
	     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
	     * @name transition
	     * @memberof Options
	     * @type {Object}
	     * @property {Number} [transition.duration=350] duration in milliseconds
	     * @example
	     * transition: {
	     *    duration: 500
	     * }
	     */
	    transition_duration: 350,

	    /**
	     * Specify the key of x values in the data.<br><br>
	     * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
	     * @name data․x
	     * @memberof Options
	     * @type {String}
	     * @default undefined
	     * @example
	     * data: {
	              *   x: "date"
	     * }
	     */
	    data_x: undefined,

	    /**
	     * Specify the keys of the x values for each data.<br><br>
	     * This option can be used if we want to show the data that has different x values.
	     * @name data․xs
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @example
	     * data: {
	              *   xs: {
	              *      data1: "x1",
	              *      data2: "x2"
	              *   }
	     * }
	     */
	    data_xs: {},

	    /**
	     * Set a format specifier to parse string specifed as x.
	     * @name data․xFormat
	     * @memberof Options
	     * @type {String}
	     * @default %Y-%m-%d
	     * @example
	     * data: {
	     *    x: "x",
	     *    columns: [
	     *        ["x", "01012019", "02012019", "03012019"],
	     *        ["data1", 30, 200, 100]
	     *    ],
	     *    // Format specifier to parse as datetime for given 'x' string value
	     *    xFormat: "%m%d%Y"
	     * },
	     * axis: {
	     *    x: {
	     *        type: "timeseries"
	     *    }
	     * }
	     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
	     */
	    data_xFormat: "%Y-%m-%d",

	    /**
	     * Set localtime format to parse x axis.
	     * @name data․xLocaltime
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * data: {
	              *   xLocaltime: false
	     * }
	     */
	    data_xLocaltime: !0,

	    /**
	     * Sort on x axis.
	     * @name data․xSort
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * data: {
	              *   xSort: false
	     * }
	     */
	    data_xSort: !0,

	    /**
	     * Converts data id value
	     * @name data․idConverter
	     * @memberof Options
	     * @type {Function}
	     * @default function(id) { return id; }
	     * @example
	     * data: {
	              *    idConverter: function(id) {
	              *       // when id is 'data1', converts to be 'data2'
	              *       // 'data2' should be given as the initial data value
	              *       if (id === "data1") {
	              *          return "data2";
	              *       } else {
	              *          return id;
	              *       }
	              *    }
	     * }
	     */
	    data_idConverter: function data_idConverter(id) {
	      return id;
	    },

	    /**
	     * Set custom data name.
	     * @name data․names
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
	     * @example
	     * data: {
	              *   names: {
	              *     data1: "Data Name 1",
	              *     data2: "Data Name 2"
	              *   }
	     * }
	     */
	    data_names: {},

	    /**
	     * Set custom data class.<br><br>
	     * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
	     * @name data․classes
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @example
	     * data: {
	              *   classes: {
	              *     data1: "additional-data1-class",
	              *     data2: "additional-data2-class"
	              *   }
	     * }
	     */
	    data_classes: {},

	    /**
	     * Set groups for the data for stacking.
	     * @name data․groups
	     * @memberof Options
	     * @type {Array}
	     * @default []
	     * @example
	     * data: {
	              *   groups: [
	              *     ["data1", "data2"],
	              *     ["data3"]
	              *   ]
	     * }
	     */
	    data_groups: [],

	    /**
	     * Set y axis the data related to. y and y2 can be used.
	     * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
	     * @name data․axes
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @example
	     * data: {
	     *   axes: {
	     *     data1: "y",
	     *     data2: "y2"
	     *   }
	     * }
	     */
	    data_axes: {},

	    /**
	     * Set chart type at once.<br><br>
	     * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
	     * **Available Values:**
	     * - area
	     * - area-line-range
	     * - area-spline
	     * - area-spline-range
	     * - area-step
	     * - bar
	     * - bubble
	     * - donut
	     * - gauge
	     * - line
	     * - pie
	     * - radar
	     * - scatter
	     * - spline
	     * - step
	     * @name data․type
	     * @memberof Options
	     * @type {String}
	     * @default line
	     * @example
	     * data: {
	     *    type: "bar"
	     * }
	     */
	    data_type: undefined,

	    /**
	     * Set chart type for each data.<br>
	     * This setting overwrites data.type setting.
	     * - **NOTE:** `radar` type can't be combined with other types.
	     * @name data․types
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @example
	     * data: {
	     *   types: {
	     *     data1: "bar",
	     *     data2: "spline"
	     *   }
	     * }
	     */
	    data_types: {},

	    /**
	     * Set labels options
	     * @name data․labels
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [data.labels=false] Show or hide labels on each data points
	     * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
	     * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
	     * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
	     *  - `v` is the value of the data point where the label is shown.
	     *  - `id` is the id of the data where the label is shown.
	     *  - `i` is the index of the data point where the label is shown.
	     *  - `j` is the sub index of the data point where the label is shown.<br><br>
	     * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
	    	 * @property {String|Object} [data.labels.colors] Set label text colors.
	     * @property {Object} [data.labels.position] Set each dataset position, relative the original.
	     * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
	     * @property {Number} [data.labels.position.y=0] y coordinate position, relative the original.
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
	     * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
	     * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
	     * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
	     * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
	     * @example
	     * data: {
	     *   labels: true,
	     *
	     *   // or set specific options
	     *   labels: {
	     *     format: function(v, id, i, j) { ... },
	     *
	     *     // it's possible to set for each data
	     *     format: {
	     *         data1: function(v, id, i, j) { ... },
	     *         ...
	     *     },
	     *
	     *     // align text to center of the 'bar' shape (works only for 'bar' type)
	     *     centered: true,
	     *
	     *     // apply for all label texts
	     *     colors: "red",
	     *
	     *     // or set different colors per dataset
	     *     // for not specified dataset, will have the default color value
	     *     colors: {
	     *        data1: "yellow",
	     *        data3: "green"
	     *     },
	     *
	     *     // set x, y coordinate position
	     *     position: {
	     *        x: -10,
	     *        y: 10
	     *     },
	     *
	     *     // or set x, y coordinate position by each dataset
	     *     position: {
	     *        data1: {x: 5, y: 5},
	     *        data2: {x: 10, y: -20}
	     *     }
	     *   }
	     * }
	     */
	    data_labels: {},
	    data_labels_colors: undefined,
	    data_labels_position: {},

	    /**
	     *  This option changes the order of stacking data and pieces of pie/donut.
	     *  - If `null` specified, it will be the order the data loaded.
	     *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
	     *
	     *  **Available Values:**
	     *  - `desc`: In descending order
	     *  - `asc`: In ascending order
	     *  - `null`: It keeps the data load order
	     *  - `function(data1, data2) { ... }`: Array.sort compareFunction
	     * @name data․order
	     * @memberof Options
	     * @type {String|Function|null}
	     * @default desc
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
	     * @example
	     * data: {
	     *   // in descending order (default)
	     *   order: "desc"
	     *
	     *   // in ascending order
	     *   order: "asc"
	     *
	     *   // keeps data input order
	     *   order: null
	     *
	     *   // specifying sort function
	     *   order: function(a, b) {
	     *       // param data passed format
	     *       {
	     *          id: "data1", id_org: "data1", values: [
	     *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
	     *              ...
	     *          ]
	     *       }
	     *   }
	     * }
	     */
	    data_order: "desc",

	    /**
	     * Define regions for each data.<br>
	     * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
	     * - The object type should be as:
	     *   - start {Number}: Start data point number. If not set, the start will be the first data point.
	     *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
	     *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
	     * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
	     * @name data․regions
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @example
	     * data: {
	     *   regions: {
	     *     data1: [{
	     *         start: 1,
	     *         end: 2,
	     *         style: {
	     *             dasharray: "5 2"
	     *         }
	     *     }, {
	     *         start: 3
	     *     }],
	     *     ...
	     *   }
	     * }
	     */
	    data_regions: {},

	    /**
	     * Set color converter function.<br><br>
	     * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
	     * @name data․color
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
	     * @example
	     * data: {
	     *   color: function(color, d) { ... }
	     * }
	     */
	    data_color: undefined,

	    /**
	     * Set color for each data.
	     * @name data․colors
	     * @memberof Options
	     * @type {Object}
	     * @default {}
	     * @example
	     * data: {
	     *   colors: {
	     *     data1: "#ff0000",
	     *     data2: function(d) {
	     *        return "#000";
	     *     }
	     *     ...
	     *   }
	     * }
	     */
	    data_colors: {},

	    /**
	     * Hide each data when the chart appears.<br><br>
	     * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
	     * @name data․hide
	     * @memberof Options
	     * @type {Boolean|Array}
	     * @default false
	     * @example
	     * data: {
	     *   // all of data will be hidden
	     *   hide: true
	     *
	     *   // specified data will be hidden
	     *   hide: ["data1", ...]
	     * }
	     */
	    data_hide: !1,

	    /**
	     * Filter values to be shown
	     * The data value is the same as the returned by `.data()`.
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
	     * @name data․filter
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * data: {
	     *   // filter for id value
	     *   filter: function(v) {
	     *      // v: [{id: "data1", id_org: "data1", values: [
	     *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
	     *      //    }, ...]
	     *      return v.id !== "data1";
	     *   }
	     */
	    data_filter: undefined,

	    /**
	     * Set the stacking to be normalized
	     * - **NOTE:**
	     *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
	     *   - y Axis will be set in percentage value (0 ~ 100%)
	     *   - Must have postive values
	     * @name data․stack․normalize
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
	     * @example
	     * data: {
	        *   stack: {
	        *      normalize: true
	        *   }
	        * }
	     */
	    data_stack_normalize: !1,

	    /**
	     * Set data selection enabled<br><br>
	     * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
	     * @name data․selection․enabled
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
	     * @example
	     * data: {
	     *    selection: {
	     *       enabled: true
	     *    }
	     * }
	     */
	    data_selection_enabled: !1,

	    /**
	     * Set grouped selection enabled.<br><br>
	     * If this option set true, multiple data points that have same x value will be selected by one selection.
	     * @name data․selection․grouped
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * data: {
	     *    selection: {
	     *       grouped: true
	     *    }
	     * }
	     */
	    data_selection_grouped: !1,

	    /**
	     * Set a callback for each data point to determine if it's selectable or not.<br><br>
	     * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
	     * @name data․selection․isselectable
	     * @memberof Options
	     * @type {Function}
	     * @default function() { return true; }
	     * @example
	     * data: {
	     *    selection: {
	     *       isselectable: function(d) { ... }
	     *    }
	     * }
	     */
	    data_selection_isselectable: function data_selection_isselectable() {
	      return !0;
	    },

	    /**
	     * Set multiple data points selection enabled.<br><br>
	     * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
	     * @name data․selection․multiple
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * data: {
	     *    selection: {
	     *       multiple: false
	     *    }
	     * }
	     */
	    data_selection_multiple: !0,

	    /**
	     * Enable to select data points by dragging.
	     * If this option set true, data points can be selected by dragging.
	     * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
	     * @name data․selection․draggable
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * data: {
	     *    selection: {
	     *       draggable: true
	     *   }
	     * }
	     */
	    data_selection_draggable: !1,

	    /**
	     * Set a callback for click event on each data point.<br><br>
	     * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
	     * - `d` is the data clicked and element is the element clicked.
	     * - `element` is the current interacting svg element.
	     * - In this callback, `this` will be the Chart object.
	     * @name data․onclick
	     * @memberof Options
	     * @type {Function}
	     * @default function() {}
	     * @example
	     * data: {
	     *     onclick: function(d, element) {
	     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
	     *        // element - <circle>
	     *        ...
	     *     }
	     * }
	     */
	    data_onclick: function data_onclick() {},

	    /**
	     * Set a callback for mouse/touch over event on each data point.<br><br>
	     * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
	     * - `d` is the data where mouse cursor moves onto.
	     * - `element` is the current interacting svg element.
	     * - In this callback, `this` will be the Chart object.
	     * @name data․onover
	     * @memberof Options
	     * @type {Function}
	     * @default function() {}
	     * @example
	     * data: {
	     *     onover: function(d, element) {
	     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
	     *        // element - <circle>
	     *        ...
	     *     }
	     * }
	     */
	    data_onover: function data_onover() {},

	    /**
	     * Set a callback for mouse/touch out event on each data point.<br><br>
	     * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
	     * - `d` is the data where mouse cursor moves out.
	     * - `element` is the current interacting svg element.
	     * - In this callback, `this` will be the Chart object.
	     * @name data․onout
	     * @memberof Options
	     * @type {Function}
	     * @default function() {}
	     * @example
	     * data: {
	     *     onout: function(d, element) {
	     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
	     *        // element - <circle>
	     *        ...
	     *     }
	     * }
	     */
	    data_onout: function data_onout() {},

	    /**
	     * Set a callback for on data selection.
	     * @name data․onselected
	     * @memberof Options
	     * @type {Function}
	     * @default function() {}
	     * @example
	     * data: {
	     *     onselected: function(d, element) {
	     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
	     *        // element - <circle>
	     *        ...
	     *    }
	     * }
	     */
	    data_onselected: function data_onselected() {},

	    /**
	     * Set a callback for on data un-selection.
	     * @name data․onunselected
	     * @memberof Options
	     * @type {Function}
	     * @default function() {}
	     * @example
	     * data: {
	     *     onunselected: function(d, element) {
	     *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
	     *        // element - <circle>
	     *        ...
	     *    }
	     * }
	     */
	    data_onunselected: function data_onunselected() {},

	    /**
	     * Set a callback for minimum data
	     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
	     * @name data․onmin
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
	     * @example
	     *  onmin: function(data) {
	     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
	        *    ...
	     *  }
	     */
	    data_onmin: undefined,

	    /**
	     * Set a callback for maximum data
	     * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
	     * @name data․onmax
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
	     * @example
	     *  onmax: function(data) {
	     *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
	        *    ...
	     *  }
	     */
	    data_onmax: undefined,

	    /**
	     * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
	     * @name data․url
	     * @memberof Options
	     * @type {String}
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
	     * @example
	     * data: {
	     *     url: "/data/test.csv"
	     * }
	     */
	    data_url: undefined,

	    /**
	     * XHR header value
	     * - **NOTE:** Should be used with `data.url` option
	     * @name data․headers
	     * @memberof Options
	     * @type {String}
	     * @default undefined
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
	     * @example
	     * data: {
	     *     url: "/data/test.csv",
	     *     headers: {
	     *        "Content-Type": "text/xml",
	     *        ...
	     *     }
	     * }
	     */
	    data_headers: undefined,

	    /**
	     * Parse a JSON object for data. See also data.keys.
	     * @name data․json
	     * @memberof Options
	     * @type {Object}
	     * @default undefined
	     * @see [data․keys](#.data%25E2%2580%25A4keys)
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
	     * @example
	     * data: {
	     *     json: [
	     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
	     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
	     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
	     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
	     *     ],
	     *     keys: {
	     *       // x: "name", // it's possible to specify 'x' when category axis
	     *       value: ["upload", "download"]
	     *     }
	     * }
	     */
	    data_json: undefined,

	    /**
	     * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
	     * @name data․rows
	     * @memberof Options
	     * @type {Array}
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
	     * @example
	     * data: {
	     *   rows: [
	     *     ["A", "B", "C"],
	     *     [90, 120, 300],
	     *     [40, 160, 240],
	     *     [50, 200, 290],
	     *     [120, 160, 230],
	     *     [80, 130, 300],
	     *     [90, 220, 320]
	     *   ]
	     * }
	     *
	     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
	     * // - an array of [high, mid, low] data following the order
	     * // - or an object with 'high', 'mid' and 'low' key value
	     * data: {
	     *   rows: [
	     *      ["data1", "data2"],
	     *      [
	     *        // or {high:150, mid: 140, low: 110}, 120
	     *        [150, 140, 110], 120
	     *      ],
	     *      [[155, 130, 115], 55],
	     *      [[160, 135, 120], 60]
	     *   ],
	     *   types: {
	     *       data1: "area-line-range",
	     *       data2: "line"
	     *   }
	     * }
	     *
	     * // for 'bubble' type, data can contain dimension value:
	     * // - an array of [y, z] data following the order
	     * // - or an object with 'y' and 'z' key value
	     * // 'y' is for y axis coordination and 'z' is the bubble radius value
	     * data: {
	     *   rows: [
	     *      ["data1", "data2"],
	     *      [
	     *        // or {y:10, z: 140}, 120
	     *        [10, 140], 120
	     *      ],
	     *      [[100, 30], 55],
	     *      [[50, 100], 60]
	     *   ],
	     *   types: {
	     *       data1: "bubble",
	     *       data2: "line"
	     *   }
	     * }
	     */
	    data_rows: undefined,

	    /**
	     * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
	     * @name data․columns
	     * @memberof Options
	     * @type {Array}
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
	     * @example
	     * data: {
	     *   columns: [
	     *      ["data1", 30, 20, 50, 40, 60, 50],
	     *      ["data2", 200, 130, 90, 240, 130, 220],
	     *      ["data3", 300, 200, 160, 400, 250, 250]
	     *   ]
	     * }
	     *
	     * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
	     * // - an array of [high, mid, low] data following the order
	     * // - or an object with 'high', 'mid' and 'low' key value
	     * data: {
	     *   columns: [
	     *      ["data1",
	     *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
	     *          [150, 140, 110],
	     *          [150, 140, 110]
	     *      ]
	     *   ],
	     *   type: "area-line-range"
	     * }
	     *
	     * // for 'bubble' type, data can contain dimension value:
	     * // - an array of [y, z] data following the order
	     * // - or an object with 'y' and 'z' key value
	     * // 'y' is for y axis coordination and 'z' is the bubble radius value
	     * data: {
	     *   columns: [
	     *      ["data1",
	     *          [10, 140],  // or {y:10, z: 140}
	     *          [100, 30],
	     *          [50, 100]
	     *      ]
	     *   ],
	     *   type: "bubble"
	     * }
	     */
	    data_columns: undefined,

	    /**
	     * Used if loading JSON via data.url.
	     * - **Available Values:**
	     *   - json
	     *   - csv
	     *   - tsv
	     * @name data․mimeType
	     * @memberof Options
	     * @type {String}
	     * @default csv
	     * @example
	     * data: {
	     *     mimeType: "json"
	     * }
	     */
	    data_mimeType: "csv",

	    /**
	     * Choose which JSON object keys correspond to desired data.
	     * - **NOTE:** Only for JSON object given as array.
	     * @name data․keys
	     * @memberof Options
	     * @type {String}
	     * @default undefined
	     * @example
	     * data: {
	     *     json: [
	     *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
	     *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
	     *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
	     *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
	     *     ],
	     *     keys: {
	     *       // x: "name", // it's possible to specify 'x' when category axis
	     *       value: ["upload", "download"]
	     *     }
	     * }
	     */
	    data_keys: undefined,

	    /**
	     * Set text label to be displayed when there's no data to show.
	     * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
	     * @name data․empty․label․text
	     * @memberof Options
	     * @type {String}
	     * @default ""
	     * @example
	     * data: {
	     *   empty: {
	     *     label: {
	     *       text: "No Data"
	     *     }
	     *   }
	     * }
	     */
	    data_empty_label_text: "",

	    /**
	     * Set subchart options
	     * @name subchart
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
	     * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
	     * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
	     * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
	     * @property {Number} [subchart.size.height] Change the height of the subchart.
	     * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
	     *  Specified function receives the current zoomed x domain.
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
	     * @example
	     *  subchart: {
	     *      axis: {
	     *      	x: {
	     *      	  show: true,
	     *      	    tick: {
	     *      	      show: true,
	     *      	      text: {
	     *      	        show: false
	     *      	      }
	     *      	    }
	     *      	}
	     *      },
	     *      show: true,
	     *      size: {
	     *          height: 20
	     *      },
	     *      onbrush: function(domain) { ... }
	     *  }
	     */
	    subchart_show: !1,
	    subchart_size_height: 60,
	    subchart_axis_x_show: !0,
	    subchart_axis_x_tick_show: !0,
	    subchart_axis_x_tick_text_show: !0,
	    subchart_onbrush: function subchart_onbrush() {},

	    /**
	     * Set color of the data values
	     * @name color
	     * @memberof Options
	     * @type {Object}
	     * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
	     * @property {Array|null} [color.pattern=[]] Set custom color pattern. Passing `null` will not set a color for these elements, which requires the usage of custom CSS-based theming to work.
	     * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
	     *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
	     *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
	     *    - `bb-colorize-pattern-red`
	     *    - `bb-colorize-pattern-fff`
	     * @property {Object} [color.threshold] color threshold for gauge and tooltip color
	     * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
	     * @property {Array} [color.threshold.values] Threshold values for each steps
	     * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
	     * @example
	     *  color: {
	     *      pattern: ["#1f77b4", "#aec7e8", ...],
	     *
	     *      // Set colors' patterns
	     *      // it should return an array of SVGPatternElement
	     *      tiles: function() {
	     *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
	     *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
	     *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	     *
	     *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
	     *         pattern.setAttribute("width", "32");
	     *         pattern.setAttribute("height", "32");
	     *
	     *         g.style.fill = "#000";
	     *         g.style.opacity = "0.2";
	              *
	     *         circle1.setAttribute("cx", "3");
	     *         circle1.setAttribute("cy", "3");
	     *         circle1.setAttribute("r", "3");
	              *
	     *         g.appendChild(circle1);
	     *         pattern.appendChild(g);
	     *
	     *         return [pattern];
	     *      },
	     *
	     *      // for threshold usage, pattern values should be set for each steps
	     *      pattern: ["grey", "green", "yellow", "orange", "red"],
	     *      threshold: {
	     *          unit: "value",
	     *
	     *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
	     *          values: [10, 20, 30, 40, 50],
	     *
	     *          // the equation for max:
	     *          // - unit == 'value': max => 30
	     *          // - unit != 'value': max => value*100/30
	     *          max: 30
	     *      },
	     *
	     *      // set all data to 'red'
	     *      onover: "red",
	     *
	     *      // set different color for data
	     *      onover: {
	     *          data1: "red",
	     *          data2: "yellow"
	     *      },
	     *
	     *      // will pass data object to the callback
	     *      onover: function(d) {
	     *          return d.id === "data1" ? "red" : "green";
	     *      }
	     *  }
	     */
	    color_pattern: [],
	    color_tiles: undefined,
	    color_threshold: {},
	    color_onover: undefined,

	    /**
	     * Legend options
	     * @name legend
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [legend.show=true] Show or hide legend.
	     * @property {Boolean} [legend.hide=false] Hide legend
	     *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
	     * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
	     * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
	     *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
	     *    - {=COLOR}: data color value
	     *    - {=TITLE}: data title value
	     *  - If set `function` value, will pass following arguments to the given function:
	     *   - title {String}: data's id value
	     *   - color {String}: color string
	     *   - data {Array}: data array
	     * @property {String} [legend.position=bottom] Change the position of legend.<br>
	     *  Available values are: `bottom`, `right` and `inset` are supported.
	     * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
	     *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
	     *  - **anchor** decides the position of the legend:
	     *   - top-left
	     *   - top-right
	     *   - bottom-left
	     *   - bottom-right
	     *  - **x** and **y**:
	     *   - set the position of the legend based on the anchor.
	     *  - **step**:
	     *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
	     * @property {Boolean} [legend.equally=false] Set to all items have same width size.
	     * @property {Boolean} [legend.padding=0] Set padding value
	     * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
	     * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
	     * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
	     * @property {Number} [legend.item.tile.width=10] Set width of item tile element
	     * @property {Number} [legend.item.tile.height=10] Set height of item tile element
	     * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
	     * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
	     * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
	     * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
	     * @example
	     *  legend: {
	     *      show: true,
	     *      hide: true,
	     *      //or hide: "data1"
	              *      //or hide: ["data1", "data2"]
	     *      contents: {
	     *          bindto: "#legend",   // <ul id='legend'></ul>
	     *
	     *          // will be as: <li style='background-color:#1f77b4'>data1</li>
	     *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
	     *
	     *          // or using function
	     *          template: function(id, color, data) {
	     *               // if you want omit some legend, return falsy value
	     *               if (title !== "data1") {
	     *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
	     *               }
	     *          }
	     *      },
	              *      position: "bottom",  // bottom, right, inset
	     *      inset: {
	     *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
	     *          x: 20,
	     *          y: 10,
	     *          step: 2
	     *      },
	              *      equally: false,
	              *      padding: 10,
	              *      item: {
	     *          onclick: function(id) { ... },
	     *          onover: function(id) { ... },
	     *          onout: function(id) { ... },
	     *
	     *          // set tile's size
	     *          tile: {
	     *              width: 20,
	     *              height: 15
	     *          }
	     *      },
	     *      usePoint: true
	     *  }
	     */
	    legend_show: !0,
	    legend_hide: !1,
	    legend_contents_bindto: undefined,
	    legend_contents_template: undefined,
	    legend_position: "bottom",
	    legend_inset_anchor: "top-left",
	    legend_inset_x: 10,
	    legend_inset_y: 0,
	    legend_inset_step: undefined,
	    legend_item_onclick: undefined,
	    legend_item_onover: undefined,
	    legend_item_onout: undefined,
	    legend_equally: !1,
	    legend_padding: 0,
	    legend_item_tile_width: 10,
	    legend_item_tile_height: 10,
	    legend_usePoint: !1,

	    /**
	     * Switch x and y axis position.
	     * @name axis․rotated
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   rotated: true
	     * }
	     */
	    axis_rotated: !1,

	    /**
	     * Set clip-path attribute for x axis element
	     * @name axis․x․clipPath
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo]()
	     * @example
	     * // don't set 'clip-path' attribute
	     * clipPath: false
	     */
	    axis_x_clipPath: !0,

	    /**
	     * Show or hide x axis.
	     * @name axis․x․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * axis: {
	     *   x: {
	     *     show: false
	     *   }
	     * }
	     */
	    axis_x_show: !0,

	    /**
	     * Set type of x axis.<br><br>
	     * **Available Values:**
	     * - timeseries
	     * - category
	     * - indexed
	     * @name axis․x․type
	     * @memberof Options
	     * @type {String}
	     * @default indexed
	     * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
	     * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
	     * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
	     * @example
	     * axis: {
	     *   x: {
	     *     type: "timeseries"
	     *   }
	     * }
	     */
	    axis_x_type: "indexed",

	    /**
	     * Set how to treat the timezone of x values.<br>
	     * If true, treat x value as localtime. If false, convert to UTC internally.
	     * @name axis․x․localtime
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * axis: {
	     *   x: {
	     *     localtime: false
	     *   }
	     * }
	     */
	    axis_x_localtime: !0,

	    /**
	     * Set category names on category axis.
	     * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
	     * @name axis․x․categories
	     * @memberof Options
	     * @type {Array}
	     * @default []
	     * @example
	     * axis: {
	     *   x: {
	     *     categories: ["Category 1", "Category 2", ...]
	     *   }
	     * }
	     */
	    axis_x_categories: [],

	    /**
	     * centerize ticks on category axis.
	     * @name axis․x․tick․centered
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       centered: true
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_centered: !1,

	    /**
	     * A function to format tick value. Format string is also available for timeseries data.
	     * @name axis․x․tick․format
	     * @memberof Options
	     * @type {Function|String}
	     * @default undefined
	     * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *        // for timeseries, a 'datetime' object is given as parameter
	     *       format: function(x) {
	     *           return x.getFullYear();
	     *       }
	     *
	     *       // for category, index(Number) and categoryName(String) are given as parameter
	     *       format: function(index, categoryName) {
	     *           return categoryName.substr(0, 10);
	     *       },
	     *
	     *        // for timeseries format specifier
	     *        format: "%Y-%m-%d %H:%M:%S"
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_format: undefined,

	    /**
	     * Setting for culling ticks.<br><br>
	     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
	     * We can change the number of ticks to be shown by axis.x.tick.culling.max.
	     * @name axis․x․tick․culling
	     * @memberof Options
	     * @type {Boolean}
	     * @default
	     * - true for indexed axis and timeseries axis
	     * - false for category axis
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       culling: false
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_culling: {},

	    /**
	     * The number of tick texts will be adjusted to less than this value.
	     * @name axis․x․tick․culling․max
	     * @memberof Options
	     * @type {Number}
	     * @default 10
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       culling: {
	     *           max: 5
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_culling_max: 10,

	    /**
	     * The number of x axis ticks to show.<br><br>
	     * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
	     * @name axis․x․tick․count
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       count: 5
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_count: undefined,

	    /**
	     * Show or hide x axis tick line.
	     * @name axis․x․tick․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       show: false
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_show: !0,

	    /**
	     * Show or hide x axis tick text.
	     * @name axis․x․tick․text․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       text: {
	     *           show: false
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_text_show: !0,

	    /**
	     * Set the x Axis tick text's position relatively its original position
	     * @name axis․x․tick․text․position
	     * @memberof Options
	     * @type {Object}
	     * @default {x: 0, y:0}
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       text: {
	     *         position: {
	     *           x: 10,
	     *           y: 10
	     *         }
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_text_position: {
	      x: 0,
	      y: 0
	    },

	    /**
	     * Fit x axis ticks.
	     * - **true**: ticks will be positioned nicely to have same intervals.
	     * - **false**: ticks will be positioned according to x value of the data points.
	     * @name axis․x․tick․fit
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
	     * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       fit: false
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_fit: !0,

	    /**
	     * Set the x values of ticks manually.<br><br>
	     * If this option is provided, the position of the ticks will be determined based on those values.<br>
	     * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
	     * @name axis․x․tick․values
	     * @memberof Options
	     * @type {Array|Function}
	     * @default null
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       values: [1, 2, 4, 8, 16, 32, ...],
	     *
	     *       // an Array value should be returned
	     *       values: function() {
	     *       	return [ ... ];
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_values: null,

	    /**
	     * Rotate x axis tick text if there is not enough space for 'category' and 'timeseries' type axis.
	     * - **NOTE:** The conditions where `autorotate` is enabled are:
	     *   - axis.x.type='category' or 'timeseries
	     *   - axis.x.tick.multiline=false
	     *   - axis.x.tick.culling=false
	     *   - axis.x.tick.fit=true
	     * @name axis․x․tick․autorotate
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickAutorotate)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       rotate: 15,
	     *       autorotate: true,
	     *       multiline: false,
	     *       culling: false,
	     *       fit: true
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_autorotate: !1,

	    /**
	     * Rotate x axis tick text.
	     * - If you set negative value, it will rotate to opposite direction.
	     * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
	     * - As long as `axis_x_tick_fit` is set to `true` it will calculate an overflow for the y2 axis and add this value to the right padding.
	     * @name axis․x․tick․rotate
	     * @memberof Options
	     * @type {Number}
	     * @default 0
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       rotate: 60
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_rotate: 0,

	    /**
	     * Show x axis outer tick.
	     * @name axis․x․tick․outer
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       outer: false
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_outer: !0,

	    /**
	     * Set tick text to be multiline
	     * - **NOTE:**
	     *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
	     * @name axis․x․tick․multiline
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       multiline: false
	     *     }
	     *   }
	     * }
	     * @example
	     * // example of line break with '\n'
	     * // In this case, 'axis.x.tick.width' is ignored
	     * data: {
	     *    x: "x",
	     *    columns: [
	     *        ["x", "long\ntext", "Another\nLong\nText"],
	     *        ...
	     *    ],
	     * }
	     */
	    axis_x_tick_multiline: !0,

	    /**
	     * Set tick width
	     * - **NOTE:**
	     *  > When x tick text contains `\n`, this option is ignored.
	     * @name axis․x․tick․width
	     * @memberof Options
	     * @type {Number}
	     * @default null
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       width: 50
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_width: null,

	    /**
	     * Set to display system tooltip(via 'title' attribute) for tick text
	     * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
	     * @name axis․x․tick․tooltip
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   x: {
	     *     tick: {
	     *       tooltip: true
	     *     }
	     *   }
	     * }
	     */
	    axis_x_tick_tooltip: !1,

	    /**
	     * Set max value of x axis range.
	     * @name axis․x․max
	     * @memberof Options
	     * @property {Number} max Set the max value
	     * @property {Boolean} [max.fit=false] When specified `max.value` is greater than the bound data value, setting `true` will make x axis max to be fitted to the bound data max value.
	     * - **NOTE:** If the bound data max value is greater than the `max.value`, the x axis max will be limited as the given `max.value`.
	     * @property {Number} [max.value] Set the max value
	     * @example
	     * axis: {
	     *   x: {
	     *     max: 100,
	     *
	     *     max: {
	     *       // 'fit=true' will make x axis max to be limited as the bound data value max when 'max.value' is greater.
	     *       // - when bound data max is '10' and max.value: '100' ==>  x axis max will be '10'
	     *       // - when bound data max is '1000' and max.value: '100' ==> x axis max will be '100'
	     *       fit: true,
	     *       value: 100
	     *     }
	     *   }
	     * }
	     */
	    axis_x_max: undefined,

	    /**
	     * Set min value of x axis range.
	     * @name axis․x․min
	     * @memberof Options
	     * @property {Number} min Set the min value
	     * @property {Boolean} [min.fit=false] When specified `min.value` is lower than the bound data value, setting `true` will make x axis min to be fitted to the bound data min value.
	     * - **NOTE:** If the bound data min value is lower than the `min.value`, the x axis min will be limited as the given `min.value`.
	     * @property {Number} [min.value] Set the min value
	     * @example
	     * axis: {
	     *   x: {
	     *     min: -100,
	     *
	     *     min: {
	     *       // 'fit=true' will make x axis min to be limited as the bound data value min when 'min.value' is lower.
	     *       // - when bound data min is '-10' and min.value: '-100' ==>  x axis min will be '-10'
	     *       // - when bound data min is '-1000' and min.value: '-100' ==> x axis min will be '-100'
	     *       fit: true,
	     *       value: -100
	     *     }
	     *   }
	     * }
	     */
	    axis_x_min: undefined,

	    /**
	     * Set padding for x axis.<br><br>
	     * If this option is set, the range of x axis will increase/decrease according to the values.
	     * If no padding is needed in the rage of x axis, 0 should be set.
	     * - **NOTE:**
	     *   The padding values aren't based on pixels. It differs according axis types<br>
	     *   - **category:** The unit of tick value
	     *     ex. the given value `1`, is same as the width of 1 tick width
	     *   - **timeseries:** Numeric time value
	     *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
	     * @name axis․x․padding
	     * @memberof Options
	     * @type {Object|Number}
	     * @default {}
	     * @example
	     * axis: {
	     *   x: {
	     *     padding: {
	     *       // when axis type is 'category'
	     *       left: 1,  // set left padding width of equivalent value of a tick's width
	     *       right: 0.5  // set right padding width as half of equivalent value of tick's width
	     *
	     *       // when axis type is 'timeseries'
	     *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
	     *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
	     *     },
	     *
	     *     // or set both values at once.
	     *     padding: 10
	     *   }
	     * }
	     */
	    axis_x_padding: {},

	    /**
	     * Set height of x axis.<br><br>
	     * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
	     * @name axis․x․height
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   x: {
	     *     height: 20
	     *   }
	     * }
	     */
	    axis_x_height: undefined,

	    /**
	     * Set default extent for subchart and zoom. This can be an array or function that returns an array.
	     * @name axis․x․extent
	     * @memberof Options
	     * @type {Array|Function}
	     * @default undefined
	     * @example
	     * axis: {
	     *   x: {
	     *     // extent range as a pixel value
	     *     extent: [0, 200],
	     *
	     *     // when axis is 'timeseries', parsable datetime string
	     *     extent: ["2019-03-01", "2019-03-05"],
	     *
	     *     // return extent value
	     *     extent: function(domain, scale) {
	     *    	 var extent = domain.map(function(v) {
	     *     	    return scale(v);
	     *     	 });
	     *
	     *   	 // it should return a format of array
	     *   	 // ex) [0, 584]
	     *     	 return extent;
	     *     }
	     *   }
	     * }
	     */
	    axis_x_extent: undefined,

	    /**
	     * Set label on x axis.<br><br>
	     * You can set x axis label and change its position by this option.
	     * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
	     * Available position differs according to the axis direction (vertical or horizontal).
	     * If string set, the position will be the default.
	     *
	     *  - **If it's horizontal axis:**
	     *    - inner-right [default]
	     *    - inner-center
	     *    - inner-left
	     *    - outer-right
	     *    - outer-center
	     *    - outer-left
	     *  - **If it's vertical axis:**
	     *    - inner-top [default]
	     *    - inner-middle
	     *    - inner-bottom
	     *    - outer-top
	     *    - outer-middle
	     *    - outer-bottom
	     * @name axis․x․label
	     * @memberof Options
	     * @type {String|Object}
	     * @default undefined
	     * @example
	     * axis: {
	     *   x: {
	     *     label: "Your X Axis"
	     *   }
	     * }
	     *
	     * axis: {
	     *   x: {
	     *     label: {
	     *        text: "Your X Axis",
	     *        position: "outer-center"
	     *     }
	     *   }
	     * }
	     */
	    axis_x_label: {},

	    /**
	     * Set additional axes for x Axis.
	     * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
	     *
	     * Each axis object should consist with following options:
	     *
	     * | Name | Type | Default | Description |
	     * | --- | --- | --- | --- |
	     * | domain | Array | - | Set the domain value |
	     * | tick.outer | Boolean | true | Show outer tick |
	     * | tick.format | Function | - | Set formatter for tick text |
	     * | tick.count | Number | - | Set the number of y axis ticks |
	     * | tick.values | Array | - | Set tick values manually |
	     * @name axis․x․axes
	     * @memberof Options
	     * @type {Array}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
	     * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
	     * @example
	     * x: {
	     *    axes: [
	     *      {
	     *        // if set, will not be correlated with the main x Axis domain value
	    	 *        domain: [0, 1000],
	     *        tick: {
	     *          outer: false,
	     *          format: function(x) {
	     *             return x + "%";
	     *          },
	     *          count: 2,
	     *          values: [10, 20, 30]
	     *        }
	     *      },
	     *      ...
	     *    ]
	     * }
	     */
	    axis_x_axes: [],

	    /**
	     * Set clip-path attribute for y axis element
	     * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
	     * @name axis․y․clipPath
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * // don't set 'clip-path' attribute
	     * clipPath: false
	     */
	    axis_y_clipPath: !0,

	    /**
	     * Show or hide y axis.
	     * @name axis․y․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * axis: {
	     *   y: {
	     *     show: false
	     *   }
	     * }
	     */
	    axis_y_show: !0,

	    /**
	     * Set type of y axis.<br><br>
	     * **Available Values:**
	     *   - timeseries
	     *   - indexed
	     * @name axis․y․type
	     * @memberof Options
	     * @type {String}
	     * @default "indexed"
	     * @example
	     * axis: {
	     *   y: {
	     *     type: "timeseries"
	     *   }
	     * }
	     */
	    axis_y_type: undefined,

	    /**
	     * Set max value of y axis.
	     * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
	     * @name axis․y․max
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y: {
	     *     max: 1000
	     *   }
	     * }
	     */
	    axis_y_max: undefined,

	    /**
	     * Set min value of y axis.
	     * - **NOTE:**
	     *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
	     * @name axis․y․min
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y: {
	     *     min: 1000
	     *   }
	     * }
	     */
	    axis_y_min: undefined,

	    /**
	     * Change the direction of y axis.<br><br>
	     * If true set, the direction will be from the top to the bottom.
	     * @name axis․y․inverted
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y: {
	     *     inverted: true
	     *   }
	     * }
	     */
	    axis_y_inverted: !1,

	    /**
	     * Set center value of y axis.
	     * @name axis․y․center
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y: {
	     *     center: 0
	     *   }
	     * }
	     */
	    axis_y_center: undefined,

	    /**
	     * Show y axis inside of the chart.
	     * @name axis․y․inner
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y: {
	     *     inner: true
	     *   }
	     * }
	     */
	    axis_y_inner: !1,

	    /**
	     * Set label on y axis.<br><br>
	     * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
	     * @name axis․y․label
	     * @memberof Options
	     * @type {String|Object}
	     * @default {}
	     * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
	     * @example
	     * axis: {
	     *   y: {
	     *     label: "Your Y Axis"
	     *   }
	     * }
	     *
	     * axis: {
	     *   y: {
	     *     label: {
	     *        text: "Your Y Axis",
	     *        position: "outer-middle"
	     *     }
	     *   }
	     * }
	     */
	    axis_y_label: {},

	    /**
	     * Set formatter for y axis tick text.<br><br>
	     * This option accepts d3.format object as well as a function you define.
	     * @name axis․y․tick․format
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       format: function(x) {
	     *           return x.getFullYear();
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_format: undefined,

	    /**
	     * Setting for culling ticks.<br><br>
	     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
	     * We can change the number of ticks to be shown by axis.y.tick.culling.max.
	     * @name axis․y․tick․culling
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       culling: false
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_culling: !1,

	    /**
	     * The number of tick texts will be adjusted to less than this value.
	     * @name axis․y․tick․culling․max
	     * @memberof Options
	     * @type {Number}
	     * @default 5
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       culling: {
	     *           max: 5
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_culling_max: 5,

	    /**
	     * Show y axis outer tick.
	     * @name axis․y․tick․outer
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       outer: false
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_outer: !0,

	    /**
	     * Set y axis tick values manually.
	     * @name axis․y․tick․values
	     * @memberof Options
	     * @type {Array|Function}
	     * @default null
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       values: [100, 1000, 10000],
	     *
	     *       // an Array value should be returned
	     *       values: function() {
	     *       	return [ ... ];
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_values: null,

	    /**
	     * Rotate y axis tick text.
	     * - If you set negative value, it will rotate to opposite direction.
	     * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
	     * @name axis․y․tick․rotate
	     * @memberof Options
	     * @type {Number}
	     * @default 0
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       rotate: 60
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_rotate: 0,

	    /**
	     * Set the number of y axis ticks.<br><br>
	     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
	     * @name axis․y․tick․count
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       count: 5
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_count: undefined,

	    /**
	     * Show or hide y axis tick line.
	     * @name axis․y․tick․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       show: false
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_show: !0,

	    /**
	     * Set axis tick step(interval) size.
	     * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
	     * @name axis․y․tick․stepSize
	     * @memberof Options
	     * @type {Number}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       // tick value will step as indicated interval value.
	     *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
	     *       stepSize: 15
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_stepSize: null,

	    /**
	    * Show or hide y axis tick text.
	    * @name axis․y․tick․text․show
	    * @memberof Options
	    * @type {Boolean}
	    * @default true
	    * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
	    * @example
	    * axis: {
	    *   y: {
	    *     tick: {
	    *       text: {
	    *           show: false
	    *       }
	    *     }
	    *   }
	    * }
	    */
	    axis_y_tick_text_show: !0,

	    /**
	     * Set the y Axis tick text's position relatively its original position
	     * @name axis․y․tick․text․position
	     * @memberof Options
	     * @type {Object}
	     * @default {x: 0, y:0}
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       text: {
	     *         position: {
	     *           x: 10,
	     *           y: 10
	     *         }
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y_tick_text_position: {
	      x: 0,
	      y: 0
	    },

	    /**
	     * Set the number of y axis ticks.<br><br>
	     * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
	     * @name axis․y․tick․time
	     * @memberof Options
	     * @private
	     * @type {Object}
	     * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
	     * @example
	     * axis: {
	     *   y: {
	     *     tick: {
	     *       time: {
	     *          // ticks at 15-minute intervals
	     *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
	     *          value: d3.timeMinute.every(15)
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    // @TODO: not fully implemented yet
	    axis_y_tick_time_value: undefined,

	    /**
	     * Set padding for y axis.<br><br>
	     * You can set padding for y axis to create more space on the edge of the axis.
	     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
	     *
	     * - **NOTE:**
	     *   - Given values are translated relative to the y Axis domain value for padding
	     *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
	     * @name axis․y․padding
	     * @memberof Options
	     * @type {Object|Number}
	     * @default {}
	     * @example
	     * axis: {
	     *   y: {
	     *     padding: {
	     *       top: 0,
	     *       bottom: 0
	     *     },
	     *
	     *     // or set both values at once.
	     *     padding: 10
	     *   }
	     * }
	     */
	    axis_y_padding: {},

	    /**
	     * Set default range of y axis.<br><br>
	     * This option set the default value for y axis when there is no data on init.
	     * @name axis․y․default
	     * @memberof Options
	     * @type {Array}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y: {
	     *     default: [0, 1000]
	     *   }
	     * }
	     */
	    axis_y_default: undefined,

	    /**
	     * Set additional axes for y Axis.
	     * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
	     *
	     * Each axis object should consist with following options:
	     *
	     * | Name | Type | Default | Description |
	     * | --- | --- | --- | --- |
	     * | domain | Array | - | Set the domain value |
	     * | tick.outer | Boolean | true | Show outer tick |
	     * | tick.format | Function | - | Set formatter for tick text |
	     * | tick.count | Number | - | Set the number of y axis ticks |
	     * | tick.values | Array | - | Set tick values manually |
	     * @name axis․y․axes
	     * @memberof Options
	     * @type {Array}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
	     * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
	     * @example
	     * y: {
	     *    axes: [
	     *      {
	     *        // if set, will not be correlated with the main y Axis domain value
	     *        domain: [0, 1000],
	     *        tick: {
	     *          outer: false,
	     *          format: function(x) {
	     *             return x + "%";
	     *          },
	     *          count: 2,
	     *          values: [10, 20, 30]
	     *        }
	     *      },
	     *      ...
	     *    ]
	     * }
	     */
	    axis_y_axes: [],

	    /**
	     * Show or hide y2 axis.
	     * - **NOTE**:
	     *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
	     *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
	     * @name axis․y2․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y2: {
	     *     show: true
	     *   }
	     * }
	     */
	    axis_y2_show: !1,

	    /**
	     * Set max value of y2 axis.
	     * @name axis․y2․max
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y2: {
	     *     max: 1000
	     *   }
	     * }
	     */
	    axis_y2_max: undefined,

	    /**
	     * Set min value of y2 axis.
	     * @name axis․y2․min
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y2: {
	     *     min: -1000
	     *   }
	     * }
	     */
	    axis_y2_min: undefined,

	    /**
	     * Change the direction of y2 axis.<br><br>
	     * If true set, the direction will be from the top to the bottom.
	     * @name axis․y2․inverted
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y2: {
	     *     inverted: true
	     *   }
	     * }
	     */
	    axis_y2_inverted: !1,

	    /**
	     * Set center value of y2 axis.
	     * @name axis․y2․center
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y2: {
	     *     center: 0
	     *   }
	     * }
	     */
	    axis_y2_center: undefined,

	    /**
	     * Show y2 axis inside of the chart.
	     * @name axis․y2․inner
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y2: {
	     *     inner: true
	     *   }
	     * }
	     */
	    axis_y2_inner: !1,

	    /**
	     * Set label on y2 axis.<br><br>
	     * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
	     * @name axis․y2․label
	     * @memberof Options
	     * @type {String|Object}
	     * @default {}
	     * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
	     * @example
	     * axis: {
	     *   y2: {
	     *     label: "Your Y2 Axis"
	     *   }
	     * }
	     *
	     * axis: {
	     *   y2: {
	     *     label: {
	     *        text: "Your Y2 Axis",
	     *        position: "outer-middle"
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_label: {},

	    /**
	     * Set formatter for y2 axis tick text.<br><br>
	     * This option works in the same way as axis.y.format.
	     * @name axis․y2․tick․format
	     * @memberof Options
	     * @type {Function}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       format: d3.format("$,")
	     *       //or format: function(d) { return "$" + d; }
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_format: undefined,

	    /**
	     * Setting for culling ticks.<br><br>
	     * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
	     * We can change the number of ticks to be shown by axis.y.tick.culling.max.
	     * @name axis․y2․tick․culling
	     * @memberof Options
	     * @type {Boolean}
	     * @default false
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       culling: false
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_culling: !1,

	    /**
	     * The number of tick texts will be adjusted to less than this value.
	     * @name axis․y2․tick․culling․max
	     * @memberof Options
	     * @type {Number}
	     * @default 5
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       culling: {
	     *           max: 5
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_culling_max: 5,

	    /**
	     * Show or hide y2 axis outer tick.
	     * @name axis․y2․tick․outer
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       outer: false
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_outer: !0,

	    /**
	     * Set y2 axis tick values manually.
	     * @name axis․y2․tick․values
	     * @memberof Options
	     * @type {Array|Function}
	     * @default null
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       values: [100, 1000, 10000],
	     *
	     *       // an Array value should be returned
	     *       values: function() {
	     *       	return [ ... ];
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_values: null,

	    /**
	     * Rotate y2 axis tick text.
	     * - If you set negative value, it will rotate to opposite direction.
	     * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
	     * @name axis․y2․tick․rotate
	     * @memberof Options
	     * @type {Number}
	     * @default 0
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       rotate: 60
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_rotate: 0,

	    /**
	     * Set the number of y2 axis ticks.
	     * - **NOTE:** This works in the same way as axis.y.tick.count.
	     * @name axis․y2․tick․count
	     * @memberof Options
	     * @type {Number}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       count: 5
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_count: undefined,

	    /**
	     * Show or hide y2 axis tick line.
	     * @name axis․y2․tick․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       show: false
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_show: !0,

	    /**
	     * Set axis tick step(interval) size.
	     * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
	     * @name axis․y2․tick․stepSize
	     * @memberof Options
	     * @type {Number}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       // tick value will step as indicated interval value.
	     *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
	     *       stepSize: 15
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_stepSize: null,

	    /**
	     * Show or hide y2 axis tick text.
	     * @name axis․y2․tick․text․show
	     * @memberof Options
	     * @type {Boolean}
	     * @default true
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       text: {
	     *           show: false
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_text_show: !0,

	    /**
	     * Set the y2 Axis tick text's position relatively its original position
	     * @name axis․y2․tick․text․position
	     * @memberof Options
	     * @type {Object}
	     * @default {x: 0, y:0}
	     * @example
	     * axis: {
	     *   y2: {
	     *     tick: {
	     *       text: {
	     *         position: {
	     *           x: 10,
	     *           y: 10
	     *         }
	     *       }
	     *     }
	     *   }
	     * }
	     */
	    axis_y2_tick_text_position: {
	      x: 0,
	      y: 0
	    },

	    /**
	     * Set padding for y2 axis.<br><br>
	     * You can set padding for y2 axis to create more space on the edge of the axis.
	     * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
	     *
	     * - **NOTE:**
	     *   - Given values are translated relative to the y2 Axis domain value for padding
	     *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
	     * @name axis․y2․padding
	     * @memberof Options
	     * @type {Object|Number}
	     * @default {}
	     * @example
	     * axis: {
	     *   y2: {
	     *     padding: {
	     *       top: 100,
	     *       bottom: 100
	     *     }
	     *
	     *     // or set both values at once.
	     *     padding: 10
	     * }
	     */
	    axis_y2_padding: {},

	    /**
	     * Set default range of y2 axis.<br><br>
	     * This option set the default value for y2 axis when there is no data on init.
	     * @name axis․y2․default
	     * @memberof Options
	     * @type {Array}
	     * @default undefined
	     * @example
	     * axis: {
	     *   y2: {
	     *     default: [0, 1000]
	     *   }
	     * }
	     */
	    axis_y2_default: undefined,

	    /**
	     * Set additional axes for y2 Axis.
	     * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
	     *
	     * Each axis object should consist with following options:
	     *
	     * | Name | Type | Default | Description |
	     * | --- | --- | --- | --- |
	     * | domain | Array | - | Set the domain value |
	     * | tick.outer | Boolean | true | Show outer tick |
	     * | tick.format | Function | - | Set formatter for tick text |
	     * | tick.count | Number | - | Set the number of y axis ticks |
	     * | tick.values | Array | - | Set tick values manually |
	     * @name axis․y2․axes
	     * @memberof Options
	     * @type {Array}
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
	     * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
	     * @example
	     * y2: {
	     *    axes: [
	     *      {
	     *        // if set, will not be correlated with the main y2 Axis domain value
	     *        domain: [0, 1000],
	     *        tick: {
	     *          outer: false,
	     *          format: function(x) {
	     *             return x + "%";
	     *          },
	     *          count: 2,
	     *          values: [10, 20, 30]
	     *        }
	     *      },
	     *      ...
	     *    ]
	     * }
	     */
	    axis_y2_axes: [],

	    /**
	     * Set related options
	     * @name grid
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
	     * @property {Boolean} [x.show=false] Show grids along x axis.
	     * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
	     *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
	     *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
	     * @property {Boolean} [y.show=false] Show grids along x axis.
	     * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
	     *  This option accepts array including object that has value, text, position and class.
	     * @property {Number} [y.ticks=10] Number of y grids to be shown.
	     * @property {Boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
	     * @property {Boolean} [focus.show=true] Show grid line when focus.
	     * @property {Boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
	     * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
	     * @default undefined
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
	     * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
	     * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
	     * @example
	     * grid: {
	     *   x: {
	     *     show: true,
	     *     lines: [
	     *       {value: 2, text: "Label on 2"},
	     *       {value: 5, text: "Label on 5", class: "label-5"},
	     *       {value: 6, text: "Label on 6", position: "start"}
	     *     ]
	     *   },
	     *   y: {
	     *     show: true,
	     *     lines: [
	     *       {value: 100, text: "Label on 100"},
	     *       {value: 200, text: "Label on 200", class: "label-200"},
	     *       {value: 300, text: "Label on 300", position: 'middle'}
	     *     ],
	     *     ticks: 5
	     *   },
	     *   front: true,
	     *   focus: {
	     *      show: false,
	     *
	     *      // Below options are available when 'tooltip.grouped=false' option is set
	     *      edge: true,
	     *      y: true
	     *   },
	     *   lines: {
	     *      front: false
	     *   }
	     * }
	     */
	    grid_x_show: !1,
	    grid_x_type: "tick",
	    grid_x_lines: [],
	    grid_y_show: !1,
	    grid_y_lines: [],
	    grid_y_ticks: 10,
	    grid_focus_edge: !1,
	    grid_focus_show: !0,
	    grid_focus_y: !1,
	    grid_front: !1,
	    grid_lines_front: !0,

	    /**
	     * Set point options
	     * @name point
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [point.show=true] Whether to show each point in line.
	     * @property {Number|Function} [point.r=2.5] The radius size of each point.
	     *  - **NOTE:** Disabled for 'bubble' type
	     * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
	     * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
	     *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
	     * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
	     * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
	     * @property {String} [point.type="circle"] The type of point to be drawn
	     * - **NOTE:**
	     *   - If chart has 'bubble' type, only circle can be used.
	     *   - For IE, non circle point expansions are not supported due to lack of transform support.
	     * - **Available Values:**
	     *   - circle
	     *   - rectangle
	     * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
	     * - **NOTE:**
	     *   - This is an `experimental` feature and can have some unexpected behaviors.
	     *   - If chart has 'bubble' type, only circle can be used.
	     *   - For IE, non circle point expansions are not supported due to lack of transform support.
	     * - **Available Values:**
	     *   - circle
	     *   - rectangle
	     *   - svg shape tag interpreted as string<br>
	     *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
	     * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
	     * @example
	     *  point: {
	     *      show: false,
	     *      r: 5,
	     *
	     *      // or customize the radius
	     *      r: function(d) {
	     *          ...
	     *          return r;
	     *      },
	     *
	     *      focus: {
	     *          expand: {
	     *              enabled: true,
	     *              r: 1
	     *          }
	     *      },
	     *      select: {
	     *          r: 3
	     *      },
	     *
	     *      // having lower value, means how closer to be for interaction
	     *      sensitivity: 3,
	     *
	     *      // valid values are "circle" or "rectangle"
	     *      type: "rectangle",
	     *
	     *      // or indicate as pattern
	    	 *      pattern: [
	    	 *        "circle",
	    	 *        "rectangle",
	    	 *        "<polygon points='0 6 4 0 -4 0'></polygon>"
	    	 *     ],
	     *  }
	     */
	    point_show: !0,
	    point_r: 2.5,
	    point_sensitivity: 10,
	    point_focus_expand_enabled: !0,
	    point_focus_expand_r: undefined,
	    point_pattern: [],
	    point_select_r: undefined,
	    point_type: "circle",

	    /**
	     * Set line options
	     * @name line
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
	     *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
	     * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
	     * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
	     * **Available values:**
	     * - step
	     * - step-before
	     * - step-after
	     * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
	     * @property {Boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
	     * @example
	     *  line: {
	     *      connectNull: true,
	     *      classes: [
	     *          "line-class1",
	     *          "line-class2"
	     *      ],
	     *      step: {
	     *          type: "step-after"
	     *      },
	     *
	     *      // hide all data points ('point.show=false' also has similar effect)
	     *      point: false,
	     *
	     *      // show data points for only indicated datas
	     *      point: [
	     *          "data1", "data3"
	     *      ],
	     *
	     *      zerobased: false
	     *  }
	     */
	    line_connectNull: !1,
	    line_step_type: "step",
	    line_zerobased: !1,
	    line_classes: undefined,
	    line_point: !0,

	    /**
	    	* Set scatter options
	    	* @name scatter
	    	* @memberof Options
	    	* @type {Object}
	    	* @property {Boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
	    	* @example
	    	*  scatter: {
	    	*      connectNull: true,
	    	*      step: {
	    	*          type: "step-after"
	    	*      },
	    	*
	    	*      // hide all data points ('point.show=false' also has similar effect)
	    	*      point: false,
	    	*
	    	*      // show data points for only indicated datas
	    	*      point: [
	    	*          "data1", "data3"
	    	*      ],
	    	*
	    	*      zerobased: false
	    	*  }
	    	*/
	    scatter_zerobased: !1,

	    /**
	     * Set bar options
	     * @name bar
	     * @memberof Options
	     * @type {Object}
	     * @property {Number} [bar.padding=0] The padding pixel value between each bar.
	     * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
	     * - **NOTE:** Works only for non-stacked bar
	     * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
	    	 * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
	     * @property {Number} [bar.width] Change the width of bar chart.
	     * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
	     * @property {Number} [bar.width.max] The maximum width value for ratio.
	     * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
	     * - **NOTE:**
	     *   - Works only for non-stacked bar
	     *   - Bars are centered accoding its total width value
	     * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
	     * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
	     * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
	     * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
	     * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
	     * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
	     * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
	     * @example
	     *  bar: {
	     *      padding: 1,
	     *
	     *      // the 'radius' option can be used only for non-stacking bars
	     *      radius: 10,
	     *      // or
	     *      radius: {
	     *          ratio: 0.5
	     *      }
	     *
	     *      // will not have offset between each bar elements for interaction
	     *      sensitivity: 0,
	     *
	     *      width: 10,
	     *
	     *      // or
	     *      width: {
	     *          ratio: 0.2,
	     *          max: 20
	     *      },
	     *
	     *      // or specify width per dataset
	     *      width: {
	     *          data1: 20,
	     *          data2: {
	     *              ratio: 0.2,
	     *              max: 20
	     *          }
	     *      },
	     *
	     *      zerobased: false
	     *  }
	     */
	    bar_padding: 0,
	    bar_radius: undefined,
	    bar_radius_ratio: undefined,
	    bar_sensitivity: 2,
	    bar_width: undefined,
	    bar_width_ratio: .6,
	    bar_width_max: undefined,
	    bar_zerobased: !0,

	    /**
	     * Set bubble options
	     * @name bubble
	     * @memberof Options
	     * @type {Object}
	     * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
	     * @property {Boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
	     * @example
	     *  bubble: {
	     *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
	     *      // And the lesser will have radius relatively from tha max value.
	     *      maxR: 50,
	     *
	     *      // or set radius callback
	     *      maxR: function(d) {
	     *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
	     *          ...
	     *          return Math.sqrt(d.value * 2);
	     *      },
	     *      zerobased: false
	     *  }
	     */
	    bubble_maxR: 35,
	    bubble_zerobased: !1,

	    /**
	     * Set area options
	     * @name area
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
	     * @property {Boolean} [area.above=false] Set background area above the data chart line.
	     * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
	     * Or customize by giving below object value:
	     *  - x {Array}: `x1`, `x2` value
	     *  - y {Array}: `y1`, `y2` value
	     *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
	     * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
	     * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
	     * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
	     * @example
	     *  area: {
	     *      zerobased: false,
	     *      above: true,
	     *
	     *      // will generate follwing linearGradient:
	     *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
	     *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
	     *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
	     *      // </linearGradient>
	     *      linearGradient: true,
	     *
	     *      // Or customized gradient
	     *      linearGradient: {
	     *      	x: [0, 0],  // x1, x2 attributes
	     *      	y: [0, 0],  // y1, y2 attributes
	     *      	stops: [
	     *      	  // offset, stop-color, stop-opacity
	     *      	  [0, "#7cb5ec", 1],
	     *
	     *      	  // setting 'null' for stop-color, will set its original data color
	     *      	  [0.5, null, 0],
	     *
	     *      	  // setting 'function' for stop-color, will pass data id as argument.
	     *      	  // It should return color string or null value
	     *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
	     *      	]
	     *      }
	     *  }
	     */
	    area_zerobased: !0,
	    area_above: !1,
	    area_linearGradient: !1,

	    /**
	     * Set pie options
	     * @name pie
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
	     * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
	     * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
	     * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
	     * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
	     * @property {Number} [pie.expand.rate=0.98] Set expand rate.
	     * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
	     * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
	     * @property {Number} [pie.padAngle=0] Set padding between data.
	     * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
	    	 * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
	     * @example
	     *  pie: {
	     *      label: {
	     *          show: false,
	     *          format: function(value, ratio, id) {
	     *              return d3.format("$")(value);
	     *
	     *              // to multiline, return with '\n' character
	     *              // return value +"%\nLine1\n2Line2";
	     *          },
	     *          threshold: 0.1,
	     *
	     *          // set ratio callback. Should return ratio value
	     *          ratio: function(d, radius, h) {
	     *              ...
	     *              return ratio;
	     *          },
	     *          // or set ratio number
	     *          ratio: 0.5
	     *      },
	     *
	     *      // disable expand transition for interaction
	     *      expand: false,
	     *
	     *      expand: {
	     *      	// set duration of expand transition to 500ms.
	     *          duration: 500,
	     *
	     *      	// set expand area rate
	     *          rate: 1
	     *      },
	     *
	     *      innerRadius: 0,
	     *
	     *      // set different innerRadius for each data
	     *      innerRadius: {
	     *      	data1: 10,
	     *      	data2: 0
	     *      }
	     *
	     *      padAngle: 0.1,
	     *      padding: 0,
	     *      startingAngle: 1
	     *  }
	     */
	    pie_label_show: !0,
	    pie_label_format: undefined,
	    pie_label_threshold: .05,
	    pie_label_ratio: undefined,
	    pie_expand: {},
	    pie_expand_rate: .98,
	    pie_expand_duration: 50,
	    pie_innerRadius: 0,
	    pie_padAngle: 0,
	    pie_padding: 0,
	    pie_startingAngle: 0,

	    /**
	     * Set plugins
	     * @name plugins
	     * @memberof Options
	     * @type {Array}
	     * @example
	     *  plugins: [
	     *    new bb.plugin.stanford({ ... }),
	     *    new PluginA(),
	     *    ...
	     * ]
	     */
	    plugins: [],

	    /**
	     * Set gauge options
	     * @name gauge
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
	     * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
	     * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
	     * @property {Function} [gauge.label.extents] Set customized min/max label text.
	     * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
	    	 * @property {Number} [gauge.expand.rate=0.98] Set expand rate.
	     * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
	     * @property {Number} [gauge.min=0] Set min value of the gauge.
	     * @property {Number} [gauge.max=100] Set max value of the gauge.
	     * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
	     * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
	     * @property {String} [gauge.units] Set units of the gauge.
	     * @property {Number} [gauge.width] Set width of gauge chart.
	     * @property {String} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
	     * **Available Values:**
	     * - single
	     * - multi
	     * @property {String} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
	     * @example
	     *  gauge: {
	     *      fullCircle: false,
	     *      label: {
	     *          show: false,
	     *          format: function(value, ratio) {
	     *              return value;
	     *
	     *              // to multiline, return with '\n' character
	     *              // return value +"%\nLine1\n2Line2";
	     *          },
	     *          extents: function(value, isMax) {
	    	 *              return (isMax ? "Max:" : "Min:") + value;
	     *          }
	     *      },
	     *
	     *      // disable expand transition for interaction
	     *      expand: false,
	     *
	     *      expand: {
	     *      	// set duration of expand transition to 500ms.
	     *          duration: 500,
	     *
	     *      	// set expand area rate
	     *          rate: 1
	     *      },
	     *
	     *      min: -100,
	     *      max: 200,
	     *      type: "single"  // or 'multi'
	     *      title: "Title Text",
	     *      units: "%",
	     *      width: 10,
	     *      arcs: {
	     *          minWidth: 5
	     *      }
	     *  }
	     */
	    gauge_fullCircle: !1,
	    gauge_label_show: !0,
	    gauge_label_format: undefined,
	    gauge_min: 0,
	    gauge_max: 100,
	    gauge_type: "single",
	    gauge_startingAngle: -1 * Math.PI / 2,
	    gauge_label_extents: undefined,
	    gauge_title: "",
	    gauge_units: undefined,
	    gauge_width: undefined,
	    gauge_arcs_minWidth: 5,
	    gauge_expand: {},
	    gauge_expand_rate: .98,
	    gauge_expand_duration: 50,

	    /**
	     * Set donut options
	     * @name donut
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
	     * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
	     * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
	     * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
	     * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
	     * @property {Number} [donut.expand.rate=0.98] Set expand rate.
	     * @property {Number} [donut.expand.duration=50] Set expand transition time in ms.
	     * @property {Number} [donut.width] Set width of donut chart.
	     * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
	     * @property {Number} [donut.padAngle=0] Set padding between data.
	     * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
	     * @example
	     *  donut: {
	     *      label: {
	     *          show: false,
	     *          format: function(value, ratio, id) {
	     *              return d3.format("$")(value);
	     *
	     *              // to multiline, return with '\n' character
	     *              // return value +"%\nLine1\n2Line2";
	     *          },
	     *          threshold: 0.1,
	     *
	     *          // set ratio callback. Should return ratio value
	     *          ratio: function(d, radius, h) {
	     *          	...
	     *          	return ratio;
	     *          },
	     *          // or set ratio number
	     *          ratio: 0.5
	     *      },
	     *
	     *      // disable expand transition for interaction
	     *      expand: false,
	     *
	     *      expand: {
	     *      	// set duration of expand transition to 500ms.
	     *          duration: 500,
	     *
	     *      	// set expand area rate
	     *          rate: 1
	     *      },
	     *
	     *      width: 10,
	     *      padAngle: 0.2,
	     *      startingAngle: 1,
	     *      title: "Donut Title"
	     *
	     *      // title with line break
	     *      title: "Title1\nTitle2"
	     *  }
	     */
	    donut_label_show: !0,
	    donut_label_format: undefined,
	    donut_label_threshold: .05,
	    donut_label_ratio: undefined,
	    donut_width: undefined,
	    donut_title: "",
	    donut_expand: {},
	    donut_expand_rate: .98,
	    donut_expand_duration: 50,
	    donut_padAngle: 0,
	    donut_startingAngle: 0,

	    /**
	     * Set spline options
	     * - **Available interpolation type values:**
	     *  - basis (d3.curveBasis)
	     *  - basis-closed (d3.curveBasisClosed)
	     *  - basis-open (d3.curveBasisOpen)
	     *  - bundle (d3.curveBundle)
	     *  - cardinal (d3.curveCardinal)
	     *  - cardinal-closed (d3.curveCardinalClosed)
	     *  - cardinal-open (d3.curveCardinalOpen)
	     *  - catmull-rom (d3.curveCatmullRom)
	     *  - catmull-rom-closed (d3.curveCatmullRomClosed)
	     *  - catmull-rom-open (d3.curveCatmullRomOpen)
	     *  - monotone-x (d3.curveMonotoneX)
	     *  - monotone-y (d3.curveMonotoneY)
	     *  - natural (d3.curveNatural)
	     *  - linear-closed (d3.curveLinearClosed)
	     *  - linear (d3.curveLinear)
	     *  - step (d3.curveStep)
	     *  - step-after (d3.curveStepAfter)
	     *  - step-before (d3.curveStepBefore)
	     * @name spline
	     * @memberof Options
	     * @type {Object}
	     * @property {String} [spline.interpolation.type="cardinal"]
	     * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
	     * @example
	     *  spline: {
	     *      interpolation: {
	     *          type: "cardinal"
	     *      }
	     *  }
	     */
	    spline_interpolation_type: "cardinal",

	    /**
	     * Set radar options
	     * - **NOTE:**
	     *  > When x tick text contains `\n`, it's used as line break.
	     * @name radar
	     * @memberof Options
	     * @type {Object}
	     * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
	     * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
	     * @property {Number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
	     * @property {NUmber} [radar.axis.text.position.y=0] y coordinate position, relative the original.
	     * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
	     * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
	     * @property {Number} [radar.level.depth=3] Set the level depth.
	     * @property {Boolean} [radar.level.show=true] Show or hide level.
	     * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
	     * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
	     * @property {Number} [radar.size.ratio=0.87] Set size ratio.
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
	     * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
	     * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
	     * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
	     * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
	     * @example
	     *  radar: {
	     *      axis: {
	     *          max: 50,
	     *          line: {
	     *              show: false
	     *          },
	     *          text: {
	     *              position: {
	     *              	x: 0,
	     *              	y: 0
	     *              },
	     *              show: false
	     *          }
	     *      },
	     *      direction: {
	     *          clockwise: true
	     *      },
	     *      level: {
	     *          show: false,
	     *          text: {
	     *              format: function(x) {
	     *                  return x + "%";
	     *              },
	     *              show: true
	     *          }
	     *      },
	     *      size: {
	     *          ratio: 0.7
	     *      }
	     *  }
	     */
	    radar_axis_max: undefined,
	    radar_axis_line_show: !0,
	    radar_axis_text_show: !0,
	    radar_axis_text_position: {},
	    radar_level_depth: 3,
	    radar_level_show: !0,
	    radar_level_text_format: function radar_level_text_format(x) {
	      return x % 1 === 0 ? x : x.toFixed(2);
	    },
	    radar_level_text_show: !0,
	    radar_size_ratio: .87,
	    radar_direction_clockwise: !1,

	    /**
	     * Control the render timing
	     * @name render
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
	     * @property {Boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
	     * @example
	     *  render: {
	     *    lazy: true,
	     *    observe: true
	     * }
	     *
	     * @example
	     *	// <!-- render.lazy will detect visibility defined -->
	     *  // (a) <div id='chart' class='hide'></div>
	     *  // (b) <div id='chart' style='display:none'></div>
	     *
	     *  // render.lazy enabled by default when element is hidden
	     *  var chart = bb.generate({ ... });
	     *
	     *  // chart will be rendered automatically when element's visibility changes
	     *  // Note: works only for inlined css property or class attribute changes
	     *  document.getElementById('chart').classList.remove('hide')  // (a)
	     *  document.getElementById('chart').style.display = 'block';  // (b)
	     *
	     * @example
	     *	// chart won't be rendered and not observing bind element's visiblity changes
	     *  var chart = bb.generate({
	     *     render: {
	     *          lazy: true,
	     *          observe: false
	     *     }
	     *  });
	     *
	     *  // call at any point when you want to render
	     *  chart.flush();
	     */
	    render: {},

	    /**
	     * Show rectangles inside the chart.<br><br>
	     * This option accepts array including object that has axis, start, end and class.
	     * The keys start, end and class are optional.
	     * axis must be x, y or y2. start and end should be the value where regions start and end.
	     * If not specified, the edge values will be used.
	     * If timeseries x axis, date string, Date object and unixtime integer can be used.
	     * If class is set, the region element will have it as class.
	     * @name regions
	     * @memberof Options
	     * @type {Array}
	     * @default []
	     * @example
	     *  regions: [
	     *    {
	     *      axis: "x",
	     *      start: 1,
	     *      end: 4,
	     *      class: "region-1-4"
	     *    }
	     *  ]
	     */
	    regions: [],

	    /**
	     * Tooltip options
	     * @name tooltip
	     * @memberof Options
	     * @type {Object}
	     * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
	     * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
	     * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
	     *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
	     * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
	     * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
	     * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
	     *  Specified function receives x of the data point to show.
	     * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
	     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
	     * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
	     *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
	     *  If undefined returned, the row of that value will be skipped.
	     * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>
	     *  This option can be used to modify the tooltip position by returning object that has top and left.
	     * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
	     *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
	     * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
	     *  - **NOTE:** When is specified, will not be updating tooltip's position.
	     * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
	     *  Within template, below syntax will be replaced using template-like syntax string:
	     *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
	     *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
	     *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
	     *    - **{=TITLE}**: title value.
	     *    - **{=COLOR}**: data color.
	     *    - **{=VALUE}**: data value.
	     * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
	     *  - **NOTE:** It should contain `{ key: Array, ... }` value
	     *    - 'key' name is used as substitution within template as '{=KEY}'
	     *    - The value array length should match with the data length
	     * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
	     * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
	     * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
	     * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
	     * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
	     * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
	     * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
	     * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
	     *  **Available Values:**
	     *  - `desc`: In descending data value order
	     *  - `asc`: In ascending data value order
	     *  - `null`: It keeps the data display order<br>
	     *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
	     *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
	     *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
	     * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
	     * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
	     * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
	     * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
	     * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
	     * @example
	     *  tooltip: {
	     *      show: true,
	     *      doNotHide: true,
	     *      grouped: false,
	     *      format: {
	     *          title: function(x) { return "Data " + x; },
	     *          name: function(name, ratio, id, index) { return name; },
	     *          value: function(value, ratio, id, index) { return ratio; }
	     *      },
	     *      position: function(data, width, height, element) {
	     *      	// return with unit or without. If the value is number, is treated as 'px'.
	     *      	return {top: "10%", left: 20}  // top:10%; left: 20px;
	    		 *      },
	    		 *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
	    		 *          return ... // formatted html as you want
	     		 *      },
	     *
	     *       // specify tooltip contents using template
	     *       // - example of HTML returned:
	     *       // <ul class="bb-tooltip">
	     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
	     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
	     *       // </ul>
	     *       contents: {
	     *      	bindto: "#tooltip",
	     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
	     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
	     *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
	     *      		'}}</ul>'
	     *      }
	     *
	     *       // with additional text value
	     *       // - example of HTML returned:
	     *       // <ul class="bb-tooltip">
	     *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
	     *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
	     *       // </ul>
	     *       contents: {
	     *      	bindto: "#tooltip",
	     *      	text: {
	     *      		// a) 'key' name is used as substitution within template as '{=KEY}'
	     *      		// b) the length should match with the data length
	     *      		VAR1: ["text1", "text2"],
	     *      		VAR2: ["comment1", "comment2"],
	     *      	},
	     *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
	     *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
	     *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
	     *      		'}}</ul>'
	     *      }
	     		 *
	     		 *      // sort tooltip data value display in ascending order
	     		 *      order: "asc",
	     		 *
	     *      // specifying sort function
	     *      order: function(a, b) {
	     *         // param data passed format
	     *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
	     *           ...
	     *      },
	     *
	     *      // show at the initialization
	     *      init: {
	     *          show: true,
	     *          x: 2,
	     *          position: {
	     *              top: "150px",
	     *              left: "250px"
	     *          }
	     *      },
	     *
	     *      // fires prior tooltip is shown
	     *      onshow: function(ctx, selectedData) {
	     *      	ctx; // current chart instance
	     *
	     *      	// current dataset selected
	     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
	     *      	selectedData;
	     *      },
	     *
	     *      // fires prior tooltip is hidden
	     *      onhide: function(ctx, selectedData) {
	     *      	ctx; // current chart instance
	     *
	     *      	// current dataset selected
	     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
	     *      	selectedData;
	     *      },
	     *
	     *      // fires after tooltip is shown
	     *      onshown: function(ctx, selectedData) {
	     *      	ctx; // current chart instance
	     *
	     *      	// current dataset selected
	     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
	     *      	selectedData;
	     *      },
	     *
	     *      // fires after tooltip is hidden
	     *      onhidden: function(ctx, selectedData) {
	     *      	ctx; // current chart instance
	     *
	     *      	// current dataset selected
	     *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
	     *      	selectedData;
	     *      },
	     *
	     *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
	     *      // Useful for timeseries correlation
	     *      linked: true,
	     *
	     *      // Specify name to interact those with the same name only.
	     *      linked: {
	     *          name: "some-group"
	     *      }
	     *  }
	     */
	    tooltip_show: !0,
	    tooltip_doNotHide: !1,
	    tooltip_grouped: !0,
	    tooltip_format_title: undefined,
	    tooltip_format_name: undefined,
	    tooltip_format_value: undefined,
	    tooltip_position: undefined,
	    tooltip_contents: {},
	    tooltip_init_show: !1,
	    tooltip_init_x: 0,
	    tooltip_init_position: {
	      top: "0px",
	      left: "50px"
	    },
	    tooltip_linked: !1,
	    tooltip_linked_name: "",
	    tooltip_onshow: function tooltip_onshow() {},
	    tooltip_onhide: function tooltip_onhide() {},
	    tooltip_onshown: function tooltip_onshown() {},
	    tooltip_onhidden: function tooltip_onhidden() {},
	    tooltip_order: null,

	    /**
	     * Set title options
	     * @name title
	     * @memberof Options
	     * @type {Object}
	     * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
	     * @property {Number} [title.padding.top=0] Top padding value.
	     * @property {Number} [title.padding.right=0] Right padding value.
	     * @property {Number} [title.padding.bottom=0] Bottom padding value.
	     * @property {Number} [title.padding.left=0] Left padding value.
	     * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
	     * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
	     * @example
	     *  title: {
	     *      text: "Title Text",
	     *
	     *      // or Multiline title text
	     *      text: "Main title text\nSub title text",
	     *
	     *      padding: {
	     *          top: 10,
	     *          right: 10,
	     *          bottom: 10,
	     *          left: 10
	     *      },
	     *      position: "center"
	     *  }
	     */
	    title_text: undefined,
	    title_padding: {
	      top: 0,
	      right: 0,
	      bottom: 0,
	      left: 0
	    },
	    title_position: "center"
	  };
	};


	// CONCATENATED MODULE: ./src/config/config.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(ChartInternal_ChartInternal.prototype, {
	  getOptions: function getOptions() {
	    return new Options_Options();
	  },

	  /**
	   * Load configuration option
	   * @param {Object} config User's generation config value
	   * @private
	   */
	  loadConfig: function loadConfig(config) {
	    var target,
	        keys,
	        read,
	        thisConfig = this.config,
	        find = function () {
	      var key = keys.shift();
	      return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
	    };

	    Object.keys(thisConfig).forEach(function (key) {
	      target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
	    });
	  }
	});
	// CONCATENATED MODULE: ./src/internals/scale.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(ChartInternal_ChartInternal.prototype, {
	  getScale: function getScale(min, max, forTimeseries) {
	    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
	  },

	  /**
	   * Get x Axis scale function
	   * @param {Number} min
	   * @param {Number} max
	   * @param {Number} domain
	   * @param {Function} offset The offset getter to be sum
	   * @return {Function} scale
	   * @private
	   */
	  getX: function getX(min, max, domain, offset) {
	    var $$ = this,
	        scale = $$.zoomScale || $$.getScale(min, max, $$.isTimeSeries());
	    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
	  },

	  /**
	   * Get y Axis scale function
	   * @param {Number} min
	   * @param {Number} max
	   * @param {Number} domain
	   * @return {Function} scale
	   * @private
	   */
	  getY: function getY(min, max, domain) {
	    var scale = this.getScale(min, max, this.isTimeSeriesY());
	    return domain && scale.domain(domain), scale;
	  },

	  /**
	   * Get customized scale
	   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
	   * @param {Function} offsetValue Offset getter to be sum
	   * @return {} scale
	   * @private
	   */
	  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
	    var $$ = this,
	        offset = offsetValue || function () {
	      return $$.xAxis.tickOffset();
	    },
	        scale = function (d, raw) {
	      var v = scaleValue(d) + offset();
	      return raw ? v : Math.ceil(v);
	    };

	    // copy original scale methods
	    for (var key in scaleValue) scale[key] = scaleValue[key];

	    return scale.orgDomain = function () {
	      return scaleValue.domain();
	    }, scale.orgScale = function () {
	      return scaleValue;
	    }, $$.isCategorized() && (scale.domain = function (domainValue) {
	      var domain = domainValue;
	      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
	    }), scale;
	  },
	  getYScale: function getYScale(id) {
	    return this.axis.getId(id) === "y2" ? this.y2 : this.y;
	  },
	  getSubYScale: function getSubYScale(id) {
	    return this.axis.getId(id) === "y2" ? this.subY2 : this.subY;
	  },

	  /**
	   * Update scale
	   * @private
	   * @param {Boolean} isInit - param is given at the init rendering
	   */
	  updateScales: function updateScales(isInit) {
	    var updateXDomain = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated;
	    $$.xMin = isRotated ? 1 : 0, $$.xMax = isRotated ? $$.height : $$.width, $$.yMin = isRotated ? 0 : $$.height, $$.yMax = isRotated ? $$.width : 1, $$.subXMin = $$.xMin, $$.subXMax = $$.xMax, $$.subYMin = isRotated ? 0 : $$.height2, $$.subYMax = isRotated ? $$.width2 : 1;
	    // update scales
	    // x Axis
	    var xDomain = updateXDomain && $$.x && $$.x.orgDomain(),
	        xSubDomain = updateXDomain && $$.orgXDomain;
	    // y Axis
	    // update for arc
	    $$.x = $$.getX($$.xMin, $$.xMax, xDomain, function () {
	      return $$.xAxis.tickOffset();
	    }), $$.subX = $$.getX($$.xMin, $$.xMax, xSubDomain, function (d) {
	      return d % 1 ? 0 : $$.subXAxis.tickOffset();
	    }), $$.xAxisTickFormat = $$.axis.getXAxisTickFormat(), $$.xAxisTickValues = $$.axis.getTickValues("x"), $$.xAxis = $$.axis.getAxis("x", $$.x, config.axis_x_tick_outer, isInit), $$.subXAxis = $$.axis.getAxis("subX", $$.subX, config.axis_x_tick_outer, isInit), $$.y = $$.getY($$.yMin, $$.yMax, $$.y ? $$.y.domain() : config.axis_y_default), $$.subY = $$.getY($$.subYMin, $$.subYMax, $$.subY ? $$.subY.domain() : config.axis_y_default), $$.yAxisTickValues = $$.axis.getTickValues("y"), $$.yAxis = $$.axis.getAxis("y", $$.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && ($$.y2 = $$.getY($$.yMin, $$.yMax, $$.y2 ? $$.y2.domain() : config.axis_y2_default), $$.subY2 = $$.getY($$.subYMin, $$.subYMax, $$.subY2 ? $$.subY2.domain() : config.axis_y2_default), $$.y2AxisTickValues = $$.axis.getTickValues("y2"), $$.y2Axis = $$.axis.getAxis("y2", $$.y2, config.axis_y2_tick_outer, isInit)), $$.updateArc && $$.updateArc();
	  }
	});
	// CONCATENATED MODULE: ./src/internals/domain.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(ChartInternal_ChartInternal.prototype, {
	  getYDomainMinMax: function getYDomainMinMax(targets, type) {
	    var $$ = this,
	        config = $$.config,
	        isMin = type === "min",
	        dataGroups = config.data_groups,
	        ids = $$.mapToIds(targets),
	        ys = $$.getValuesAsIdKeyed(targets);
	    return dataGroups.length > 0 && function () {
	      for (var idsInGroup, _ret, hasValue = $$["has".concat(isMin ? "Negative" : "Positive", "ValueInTargets")](targets), _loop = function (j, _idsInGroup) {
	        if (_idsInGroup = _idsInGroup.filter(function (v) {
	          return ids.indexOf(v) >= 0;
	        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
	        var baseId = _idsInGroup[0],
	            baseAxisId = $$.axis.getId(baseId);
	        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
	          return (isMin ? v < 0 : v > 0) ? v : 0;
	        }));

	        for (var id, _ret2, _loop2 = function (k, id) {
	          if (!ys[id]) return "continue";
	          var axisId = $$.axis.getId(id);
	          ys[id].forEach(function (v, i) {
	            var val = +v,
	                meetCondition = isMin ? val > 0 : val < 0;
	            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
	          });
	        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

	        idsInGroup = _idsInGroup;
	      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
	    }(), getMinMax(type, Object.keys(ys).map(function (key) {
	      return getMinMax(type, ys[key]);
	    }));
	  },
	  getYDomainMin: function getYDomainMin(targets) {
	    return this.getYDomainMinMax(targets, "min");
	  },
	  getYDomainMax: function getYDomainMax(targets) {
	    return this.getYDomainMinMax(targets, "max");
	  },

	  /**
	   * Check if hidden targets bound to the given axis id
	   * @return {Boolean}
	   * @private
	   */
	  isHiddenTargetWithYDomain: function isHiddenTargetWithYDomain(id) {
	    var $$ = this;
	    return $$.hiddenTargetIds.some(function (v) {
	      return $$.axis.getId(v) === id;
	    });
	  },
	  getYDomain: function getYDomain(targets, axisId, xDomain) {
	    var $$ = this,
	        config = $$.config,
	        pfx = "axis_".concat(axisId);
	    if ($$.isStackNormalized()) return [0, 100];
	    var targetsByAxisId = targets.filter(function (t) {
	      return $$.axis.getId(t.id) === axisId;
	    }),
	        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
	    if (yTargets.length === 0) return $$.isHiddenTargetWithYDomain(axisId) ? $$[axisId].domain() : axisId === "y2" ? $$.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
	    // So, it needs to call to get y2 domain here
	    $$.getYDomain(targets, "y2", xDomain);
	    var yMin = config["".concat(pfx, "_min")],
	        yMax = config["".concat(pfx, "_max")],
	        yDomainMin = $$.getYDomainMin(yTargets),
	        yDomainMax = $$.getYDomainMax(yTargets),
	        center = config["".concat(pfx, "_center")],
	        isZeroBased = ["area", "bar", "bubble", "line", "scatter"].some(function (v) {
	      return $$.hasType(v, yTargets) && config["".concat(v, "_zerobased")];
	    }),
	        isInverted = config["".concat(pfx, "_inverted")],
	        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
	        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
	    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
	    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
	        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
	    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
	    var domainLength = Math.abs(yDomainMax - yDomainMin),
	        padding = {
	      top: domainLength * .1,
	      bottom: domainLength * .1
	    };

	    if (isDefined(center)) {
	      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
	      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
	    } // add padding for data label


	    if (showHorizontalDataLabel) {
	      var diff = diffDomain($$.y.range()),
	          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
	        return v / diff;
	      });
	      ["bottom", "top"].forEach(function (v, i) {
	        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
	      });
	    } else if (showVerticalDataLabel) {
	      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
	      ["bottom", "top"].forEach(function (v, i) {
	        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
	      });
	    } // if padding is set, the domain will be updated relative the current domain value
	    // ex) $$.height=300, padding.top=150, domainLength=4  --> domain=6


	    var p = config["".concat(pfx, "_padding")];
	    notEmpty(p) && ["bottom", "top"].forEach(function (v) {
	      padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
	    }), isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
	    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
	    return isInverted ? domain.reverse() : domain;
	  },
	  getXDomainMinMax: function getXDomainMinMax(targets, type) {
	    var $$ = this,
	        configValue = $$.config["axis_x_".concat(type)],
	        dataValue = getMinMax(type, targets.map(function (t) {
	      return getMinMax(type, t.values.map(function (v) {
	        return v.x;
	      }));
	    })),
	        value = isObject(configValue) ? configValue.value : configValue;
	    return value = isDefined(value) && $$.isTimeSeries() ? $$.parseDate(value) : value, isObject(configValue) && configValue.fit && (type === "min" && value < dataValue || type === "max" && value > dataValue) && (value = undefined), isDefined(value) ? value : dataValue;
	  },
	  getXDomainMin: function getXDomainMin(targets) {
	    return this.getXDomainMinMax(targets, "min");
	  },
	  getXDomainMax: function getXDomainMax(targets) {
	    return this.getXDomainMinMax(targets, "max");
	  },
	  getXDomainPadding: function getXDomainPadding(domain) {
	    var maxDataCount,
	        padding,
	        $$ = this,
	        config = $$.config,
	        diff = domain[1] - domain[0],
	        xPadding = config.axis_x_padding;
	    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
	    var left = padding,
	        right = padding;
	    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
	      left: left,
	      right: right
	    };
	  },
	  getXDomain: function getXDomain(targets) {
	    var $$ = this,
	        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
	        _xDomain2 = _slicedToArray(xDomain, 2),
	        firstX = _xDomain2[0],
	        lastX = _xDomain2[1],
	        padding = $$.getXDomainPadding(xDomain),
	        min = 0,
	        max = 0;

	    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
	  },
	  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
	    var $$ = this,
	        config = $$.config,
	        zoomEnabled = config.zoom_enabled;

	    if (withUpdateOrgXDomain && ($$.x.domain(domain || sortValue($$.getXDomain(targets))), $$.orgXDomain = $$.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), $$.subX.domain($$.x.domain()), $$.brush && $$.brush.scale($$.subX)), withUpdateXDomain) {
	      var domainValue = domain || !$$.brush || brushEmpty($$) ? $$.orgXDomain : getBrushSelection($$).map($$.subX.invert);
	      $$.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
	    } // Trim domain when too big by zoom mousemove event


	    return withTrim && $$.x.domain($$.trimXDomain($$.x.orgDomain())), $$.x.domain();
	  },
	  trimXDomain: function trimXDomain(domain) {
	    var zoomDomain = this.getZoomDomain(),
	        _zoomDomain = _slicedToArray(zoomDomain, 2),
	        min = _zoomDomain[0],
	        max = _zoomDomain[1];

	    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
	  }
	});
	// CONCATENATED MODULE: ./src/data/data.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(ChartInternal_ChartInternal.prototype, {
	  isX: function isX(key) {
	    var $$ = this,
	        config = $$.config,
	        dataKey = config.data_x && key === config.data_x,
	        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
	    return dataKey || existValue;
	  },
	  isNotX: function isNotX(key) {
	    return !this.isX(key);
	  },
	  isStackNormalized: function isStackNormalized() {
	    var config = this.config;
	    return config.data_stack_normalize && this.isGrouped();
	  },
	  isGrouped: function isGrouped(id) {
	    var groups = this.config.data_groups;
	    return id ? groups.some(function (v) {
	      return v.indexOf(id) >= 0 && v.length > 1;
	    }) : groups.length > 0;
	  },
	  getXKey: function getXKey(id) {
	    var $$ = this,
	        config = $$.config;
	    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
	  },
	  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
	    var xValues,
	        $$ = this,
	        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
	    return ids.forEach(function (id) {
	      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
	    }), xValues;
	  },

	  /**
	   * Get index number based on given x Axis value
	   * @param {Date|Number|String} x x Axis to be compared
	   * @param {Array} basedX x Axis list to be based on
	   * @return {Number} index number
	   * @private
	   */
	  getIndexByX: function getIndexByX(x, basedX) {
	    var $$ = this;
	    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
	      index: null
	    }).index;
	  },
	  getXValue: function getXValue(id, i) {
	    var $$ = this;
	    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
	  },
	  getOtherTargetXs: function getOtherTargetXs() {
	    var $$ = this,
	        idsForX = Object.keys($$.data.xs);
	    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
	  },
	  getOtherTargetX: function getOtherTargetX(index) {
	    var xs = this.getOtherTargetXs();
	    return xs && index < xs.length ? xs[index] : null;
	  },
	  addXs: function addXs(xs) {
	    var $$ = this;
	    Object.keys(xs).forEach(function (id) {
	      $$.config.data_xs[id] = xs[id];
	    });
	  },
	  isMultipleX: function isMultipleX() {
	    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
	  },
	  addName: function addName(data) {
	    var name,
	        $$ = this;
	    return data && (name = $$.config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
	  },
	  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
	    var $$ = this;
	    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
	      return $$.addName($$.getValueOnIndex(t.values, index));
	    });
	  },
	  getValueOnIndex: function getValueOnIndex(values, index) {
	    var valueOnIndex = values.filter(function (v) {
	      return v.index === index;
	    });
	    return valueOnIndex.length ? valueOnIndex[0] : null;
	  },
	  updateTargetX: function updateTargetX(targets, x) {
	    var $$ = this;
	    targets.forEach(function (t) {
	      t.values.forEach(function (v, i) {
	        v.x = $$.generateTargetX(x[i], t.id, i);
	      }), $$.data.xs[t.id] = x;
	    });
	  },
	  updateTargetXs: function updateTargetXs(targets, xs) {
	    var $$ = this;
	    targets.forEach(function (t) {
	      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
	    });
	  },
	  generateTargetX: function generateTargetX(rawX, id, index) {
	    var $$ = this,
	        x = $$.isCategorized() ? index : rawX || index;
	    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
	  },
	  cloneTarget: function cloneTarget(target) {
	    return {
	      id: target.id,
	      id_org: target.id_org,
	      values: target.values.map(function (d) {
	        return {
	          x: d.x,
	          value: d.value,
	          id: d.id
	        };
	      })
	    };
	  },
	  updateXs: function updateXs(values) {
	    values.length && (this.xs = values.map(function (v) {
	      return v.x;
	    }));
	  },
	  getPrevX: function getPrevX(i) {
	    var x = this.xs[i - 1];
	    return isDefined(x) ? x : null;
	  },
	  getNextX: function getNextX(i) {
	    var x = this.xs[i + 1];
	    return isDefined(x) ? x : null;
	  },

	  /**
	   * Get base value isAreaRangeType
	   * @param data Data object
	   * @return {Number}
	   * @private
	   */
	  getBaseValue: function getBaseValue(data) {
	    var $$ = this,
	        value = data.value;
	    return value && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
	  },

	  /**
	   * Get min/max value from the data
	   * @private
	   * @param {Array} data array data to be evaluated
	   * @return {{min: {Number}, max: {Number}}}
	   */
	  getMinMaxValue: function getMinMaxValue(data) {
	    var min,
	        max,
	        getBaseValue = this.getBaseValue.bind(this);
	    return (data || this.data.targets.map(function (t) {
	      return t.values;
	    })).forEach(function (v, i) {
	      var value = v.map(getBaseValue).filter(isNumber);
	      min = Math.min.apply(Math, [i ? min : Infinity].concat(_toConsumableArray(value))), max = Math.max.apply(Math, [i ? max : -Infinity].concat(_toConsumableArray(value)));
	    }), {
	      min: min,
	      max: max
	    };
	  },

	  /**
	   * Get the min/max data
	   * @private
	   * @return {{min: Array, max: Array}}
	   */
	  getMinMaxData: function getMinMaxData() {
	    var $$ = this,
	        cacheKey = "$minMaxData",
	        minMaxData = $$.getCache(cacheKey);

	    if (!minMaxData) {
	      var data = $$.data.targets.map(function (t) {
	        return t.values;
	      }),
	          minMax = $$.getMinMaxValue(data),
	          min = [],
	          max = [];
	      // update the cached data
	      data.forEach(function (v) {
	        var minData = $$.getFilteredDataByValue(v, minMax.min),
	            maxData = $$.getFilteredDataByValue(v, minMax.max);
	        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
	      }), $$.addCache(cacheKey, minMaxData = {
	        min: min,
	        max: max
	      });
	    }

	    return minMaxData;
	  },

	  /**
	   * Get sum of data per index
	   * @private
	   * @return {Array}
	   */
	  getTotalPerIndex: function getTotalPerIndex() {
	    var $$ = this,
	        sum = $$.getCache("$totalPerIndex");
	    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
	      row.values.forEach(function (v, i) {
	        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
	      });
	    })), sum;
	  },

	  /**
	   * Get total data sum
	   * @param {boolean} subtractHidden Subtract hidden data from total
	   * @return {Number}
	  	 * @private
	   */
	  getTotalDataSum: function getTotalDataSum(subtractHidden) {
	    var $$ = this,
	        cacheKey = "$totalDataSum",
	        total = $$.getCache(cacheKey);

	    if (!isNumber(total)) {
	      var sum = mergeArray($$.data.targets.map(function (t) {
	        return t.values;
	      })).map(function (v) {
	        return v.value;
	      }).reduce(function (p, c) {
	        return p + c;
	      });
	      $$.addCache(cacheKey, total = sum);
	    }

	    return subtractHidden && (total -= $$.getHiddenTotalDataSum()), total;
	  },

	  /**
	   * Get total hidden data sum
	   * @return {Number}
	  	 * @private
	   */
	  getHiddenTotalDataSum: function getHiddenTotalDataSum() {
	    var $$ = this,
	        api = $$.api,
	        hiddenTargetIds = $$.hiddenTargetIds,
	        total = 0;
	    return hiddenTargetIds.length && (total = api.data.values.bind(api)(hiddenTargetIds).reduce(function (p, c) {
	      return p + c;
	    })), total;
	  },

	  /**
	   * Get filtered data by value
	   * @param {Object} data
	   * @param {Number} value
	   * @return {Array} filtered array data
	   * @private
	   */
	  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
	    var _this = this;

	    return data.filter(function (t) {
	      return _this.getBaseValue(t) === value;
	    });
	  },

	  /**
	   * Return the max length of the data
	   * @return {Number} max data length
	   * @private
	   */
	  getMaxDataCount: function getMaxDataCount() {
	    return Math.max.apply(Math, _toConsumableArray(this.data.targets.map(function (t) {
	      return t.values.length;
	    })));
	  },
	  getMaxDataCountTarget: function getMaxDataCountTarget() {
	    var target = this.filterTargetsToShow() || [],
	        length = target.length;
	    return length > 1 ? (target = target.map(function (t) {
	      return t.values;
	    }).reduce(function (a, b) {
	      return a.concat(b);
	    }).map(function (v) {
	      return v.x;
	    }), target = sortValue(getUnique(target)).map(function (x, index) {
	      return {
	        x: x,
	        index: index
	      };
	    })) : length && (target = target[0].values), target;
	  },
	  mapToIds: function mapToIds(targets) {
	    return targets.map(function (d) {
	      return d.id;
	    });
	  },
	  mapToTargetIds: function mapToTargetIds(ids) {
	    var $$ = this;
	    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
	  },
	  hasTarget: function hasTarget(targets, id) {
	    var ids = this.mapToIds(targets);

	    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

	    return !1;
	  },
	  isTargetToShow: function isTargetToShow(targetId) {
	    return this.hiddenTargetIds.indexOf(targetId) < 0;
	  },
	  isLegendToShow: function isLegendToShow(targetId) {
	    return this.hiddenLegendIds.indexOf(targetId) < 0;
	  },
	  filterTargetsToShow: function filterTargetsToShow(targets) {
	    var $$ = this;
	    return (targets || $$.data.targets).filter(function (t) {
	      return $$.isTargetToShow(t.id);
	    });
	  },
	  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
	    var $$ = this,
	        xs = [];
	    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
	      return t.values.map(function (v) {
	        return +v.x;
	      });
	    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
	      return new Date(+x);
	    }) : xs.map(function (x) {
	      return +x;
	    })), sortValue(xs);
	  },
	  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
	    this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
	  },
	  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
	    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
	      return targetIds.indexOf(id) < 0;
	    });
	  },
	  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
	    this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
	  },
	  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
	    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
	      return targetIds.indexOf(id) < 0;
	    });
	  },
	  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
	    var $$ = this,
	        ys = {},
	        isMultipleX = $$.isMultipleX(),
	        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
	      return isString(v) ? v : +v;
	    }) : null;
	    return targets.forEach(function (t) {
	      var data = [];
	      t.values.forEach(function (v) {
	        var value = v.value;
	        isArray(value) ? data.push.apply(data, _toConsumableArray(value)) : isObject(value) && "high" in value ? data.push.apply(data, _toConsumableArray(Object.values(value))) : $$.isBubbleZType(v) ? data.push($$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
	      }), ys[t.id] = data;
	    }), ys;
	  },
	  checkValueInTargets: function checkValueInTargets(targets, checker) {
	    var values,
	        ids = Object.keys(targets);

	    for (var i = 0; i < ids.length; i++) {
	      values = targets[ids[i]].values;

	      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
	    }

	    return !1;
	  },
	  hasMultiTargets: function hasMultiTargets() {
	    return this.filterTargetsToShow().length > 1;
	  },
	  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
	    return this.checkValueInTargets(targets, function (v) {
	      return v < 0;
	    });
	  },
	  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
	    return this.checkValueInTargets(targets, function (v) {
	      return v > 0;
	    });
	  },
	  _checkOrder: function _checkOrder(type) {
	    var config = this.config,
	        order = config.data_order;
	    return isString(order) && order.toLowerCase() === type;
	  },
	  isOrderDesc: function isOrderDesc() {
	    return this._checkOrder("desc");
	  },
	  isOrderAsc: function isOrderAsc() {
	    return this._checkOrder("asc");
	  },

	  /**
	   * Sort targets data
	   * @param {Array} targetsValue
	   * @return {Array}
	   * @private
	   */
	  orderTargets: function orderTargets(targetsValue) {
	    var $$ = this,
	        config = $$.config,
	        targets = _toConsumableArray(targetsValue),
	        orderAsc = $$.isOrderAsc(),
	        orderDesc = $$.isOrderDesc();

	    // TODO: accept name array for order
	    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
	      var reducer = function (p, c) {
	        return p + Math.abs(c.value);
	      },
	          t1Sum = t1.values.reduce(reducer, 0),
	          t2Sum = t2.values.reduce(reducer, 0);

	      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
	    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
	  },
	  filterByX: function filterByX(targets, x) {
	    return mergeArray(targets.map(function (t) {
	      return t.values;
	    })).filter(function (v) {
	      return v.x - x === 0;
	    });
	  },
	  filterRemoveNull: function filterRemoveNull(data) {
	    var _this2 = this;

	    return data.filter(function (d) {
	      return isValue(_this2.getBaseValue(d));
	    });
	  },
	  filterByXDomain: function filterByXDomain(targets, xDomain) {
	    return targets.map(function (t) {
	      return {
	        id: t.id,
	        id_org: t.id_org,
	        values: t.values.filter(function (v) {
	          return xDomain[0] <= v.x && v.x <= xDomain[1];
	        })
	      };
	    });
	  },
	  hasDataLabel: function hasDataLabel() {
	    var dataLabels = this.config.data_labels;
	    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
	  },
	  getDataLabelLength: function getDataLabelLength(min, max, key) {
	    var $$ = this,
	        lengths = [0, 0];
	    return $$.selectChart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
	      return $$.dataLabelFormat(d.id)(d);
	    }).each(function (d, i) {
	      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
	    }).remove(), lengths;
	  },
	  isNoneArc: function isNoneArc(d) {
	    return this.hasTarget(this.data.targets, d.id);
	  },
	  isArc: function isArc(d) {
	    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
	  },
	  findSameXOfValues: function findSameXOfValues(values, index) {
	    var i,
	        targetX = values[index].x,
	        sames = [];

	    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

	    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

	    return sames;
	  },
	  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
	    var $$ = this,
	        candidates = targets.map(function (target) {
	      return $$.findClosest(target.values, pos);
	    });
	    // map to array of closest points of each target
	    // decide closest point and return
	    return $$.findClosest(candidates, pos);
	  },
	  findClosest: function findClosest(values, pos) {
	    var closest,
	        $$ = this,
	        data = values.filter(function (v) {
	      return v && isValue(v.value);
	    }),
	        minDist = $$.config.point_sensitivity;
	    return data.filter(function (v) {
	      return $$.isBarType(v.id);
	    }).forEach(function (v) {
	      var shape = $$.main.select(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(v.id), " .").concat(config_classes.bar, "-").concat(v.index)).node();
	      !closest && $$.isWithinBar(shape) && (closest = v);
	    }), data.filter(function (v) {
	      return !$$.isBarType(v.id);
	    }).forEach(function (v) {
	      var d = $$.dist(v, pos);
	      d < minDist && (minDist = d, closest = v);
	    }), closest;
	  },
	  dist: function dist(data, pos) {
	    var $$ = this,
	        isRotated = $$.config.axis_rotated,
	        xIndex = isRotated ? 1 : 0,
	        yIndex = isRotated ? 0 : 1,
	        y = $$.circleY(data, data.index),
	        x = ($$.zoomScale || $$.x)(data.x);
	    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
	  },

	  /**
	   * Convert data for step type
	   * @param {Array} values Object data values
	   * @return {Array}
	   * @private
	   */
	  convertValuesToStep: function convertValuesToStep(values) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        stepType = config.line_step_type,
	        isCategorized = $$.isCategorized(),
	        converted = isArray(values) ? values.concat() : [values];
	    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

	    var id = converted[0].id,
	        x = converted[0].x - 1,
	        value = converted[0].value; // insert

	    return isCategorized && converted.unshift({
	      x: x,
	      value: value,
	      id: id
	    }), stepType === "step-after" && converted.unshift({
	      x: x - 1,
	      value: value,
	      id: id
	    }), x = converted.length - 1, value = converted[x].value, isCategorized && converted.push({
	      x: x,
	      value: value,
	      id: id
	    }), stepType === "step-before" && converted.push({
	      x: x + 1,
	      value: value,
	      id: id
	    }), converted;
	  },
	  convertValuesToRange: function convertValuesToRange(values) {
	    var converted = isArray(values) ? values.concat() : [values],
	        ranges = [];
	    return converted.forEach(function (range) {
	      var x = range.x,
	          id = range.id;
	      ranges.push({
	        x: x,
	        id: id,
	        value: range.value[0]
	      }), ranges.push({
	        x: x,
	        id: id,
	        value: range.value[2]
	      });
	    }), ranges;
	  },
	  updateDataAttributes: function updateDataAttributes(name, attrs) {
	    var $$ = this,
	        config = $$.config,
	        current = config["data_".concat(name)];
	    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
	      current[id] = attrs[id];
	    }), $$.redraw({
	      withLegend: !0
	    }), current);
	  },
	  getAreaRangeData: function getAreaRangeData(d, type) {
	    var value = d.value;

	    if (isArray(value)) {
	      var index = ["high", "mid", "low"].indexOf(type);
	      return index === -1 ? null : value[index];
	    }

	    return value[type];
	  },

	  /**
	   * Get ratio value
	   * @param {String} type Ratio for given type
	   * @param {Object} d Data value object
	   * @param {Boolean} asPercent Convert the return as percent or not
	   * @return {Number} Ratio value
	   * @private
	   */
	  getRatio: function getRatio(type, d, asPercent) {
	    var $$ = this,
	        config = $$.config,
	        api = $$.api,
	        ratio = 0;
	    if (d && api.data.shown.call(api).length) if (ratio = d.ratio || d.value, type === "arc") ratio = $$.pie.padAngle()() ? d.value / $$.getTotalDataSum(!0) : (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));else if (type === "index") {
	      var dataValues = api.data.values.bind(api),
	          total = this.getTotalPerIndex();

	      if ($$.hiddenTargetIds.length) {
	        var hiddenSum = dataValues($$.hiddenTargetIds, !1);
	        hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
	          return acc.map(function (v, i) {
	            return (isNumber(v) ? v : 0) + curr[i];
	          });
	        }), total = total.map(function (v, i) {
	          return v - hiddenSum[i];
	        }));
	      }

	      d.ratio = isNumber(d.value) && total && total[d.index] > 0 ? d.value / total[d.index] : 0, ratio = d.ratio;
	    } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0)) / $$.maxValue * config.radar_size_ratio);
	    return asPercent && ratio ? ratio * 100 : ratio;
	  },

	  /**
	   * Sort data index to be aligned with x axis.
	   * @param {Array} tickValues Tick array values
	   * @private
	   */
	  updateDataIndexByX: function updateDataIndexByX(tickValues) {
	    var $$ = this,
	        tickValueMap = tickValues.reduce(function (out, tick, index) {
	      return out[+tick.x] = index, out;
	    }, {});
	    $$.data.targets.forEach(function (t) {
	      t.values.forEach(function (value, valueIndex) {
	        var index = tickValueMap[+value.x];
	        index === undefined && (index = valueIndex), value.index = index;
	      });
	    });
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
	var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(8);

	// CONCATENATED MODULE: ./src/data/data.convert.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	/**
	 * Convert CSV/TSV data
	 * @param {Object} parser Parser object
	 * @param {Object} xsv Data
	 * @private
	 * @return {Object}
	 */

	var convertCsvTsvToData = function (parser, xsv) {
	  var d,
	      rows = parser.rows(xsv);
	  return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
	    d[0][id] = null;
	  })) : d = parser.parse(xsv), d;
	};

	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Convert data according its type
	   * @param {Object} args data object
	   * @param {Function} [callback] callback for url(XHR) type loading
	   * @return {Object}
	   * @private
	   */
	  convertData: function convertData(args, callback) {
	    var data,
	        $$ = this;
	    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
	      var key = "data_".concat(v);
	      key in args && (data[v] = args[key]);
	    })) : data = args, data.url && callback) $$.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = $$.convertJsonToData(data.json, data.keys);else if (data.rows) data = $$.convertRowsToData(data.rows);else if (data.columns) data = $$.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
	    return isArray(data) && data;
	  },

	  /**
	   * Convert URL data
	   * @param {String} url Remote URL
	   * @param {String} mimeType MIME type string: json | csv | tsv
	   * @param {Object} headers Header object
	   * @param {Object} keys Key object
	   * @param {Function} done Callback function
	   * @private
	   */
	  convertUrlToData: function convertUrlToData(url) {
	    var _this = this,
	        mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "csv",
	        headers = arguments.length > 2 ? arguments[2] : undefined,
	        keys = arguments.length > 3 ? arguments[3] : undefined,
	        done = arguments.length > 4 ? arguments[4] : undefined,
	        req = new XMLHttpRequest();

	    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
	      req.setRequestHeader(key, headers[key]);
	    }), req.onreadystatechange = function () {
	      if (req.readyState === 4) if (req.status === 200) {
	        var response = req.responseText;
	        response && done.call(_this, _this["convert".concat(capitalize(mimeType), "ToData")](mimeType === "json" ? JSON.parse(response) : response, keys));
	      } else throw new Error("".concat(url, ": Something went wrong loading!"));
	    }, req.send();
	  },
	  convertCsvToData: function convertCsvToData(xsv) {
	    return convertCsvTsvToData({
	      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
	      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
	    }, xsv);
	  },
	  convertTsvToData: function convertTsvToData(tsv) {
	    return convertCsvTsvToData({
	      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
	      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
	    }, tsv);
	  },
	  convertJsonToData: function convertJsonToData(json, keysParam) {
	    var targetKeys,
	        data,
	        _this2 = this,
	        config = this.config,
	        newRows = [];

	    if (isArray(json)) {
	      var keys = keysParam || config.data_keys;
	      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
	        var newRow = targetKeys.map(function (key) {
	          // convert undefined to null because undefined data will be removed in convertDataToTargets()
	          var v = _this2.findValueInJson(o, key);

	          return isUndefined(v) && (v = null), v;
	        });
	        newRows.push(newRow);
	      }), data = this.convertRowsToData(newRows);
	    } else Object.keys(json).forEach(function (key) {
	      var tmp = json[key].concat();
	      tmp.unshift(key), newRows.push(tmp);
	    }), data = this.convertColumnsToData(newRows);

	    return data;
	  },
	  findValueInJson: function findValueInJson(object, path) {
	    if (object[path] !== undefined) return object[path];
	    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
	        pathArray = convertedPath.replace(/^\./, "").split("."),
	        target = object; // convert indexes to properties (replace [] with .)

	    return pathArray.some(function (k) {
	      return !(target = target && k in target ? target[k] : undefined);
	    }), target;
	  },
	  convertRowsToData: function convertRowsToData(rows) {
	    var keys = rows[0],
	        newRows = [];
	    return rows.forEach(function (row, i) {
	      if (i > 0) {
	        var newRow = {};
	        row.forEach(function (v, j) {
	          if (isUndefined(v)) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
	          newRow[keys[j]] = v;
	        }), newRows.push(newRow);
	      }
	    }), newRows;
	  },
	  convertColumnsToData: function convertColumnsToData(columns) {
	    var newRows = [];
	    return columns.forEach(function (col, i) {
	      var key = col[0];
	      col.forEach(function (v, j) {
	        if (j > 0) {
	          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (".concat(i, ", ").concat(j, ")!"));
	          newRows[j - 1][key] = v;
	        }
	      });
	    }), newRows;
	  },
	  convertDataToTargets: function convertDataToTargets(data, appendXs) {
	    var xsData,
	        _this3 = this,
	        $$ = this,
	        config = $$.config,
	        isTimeSeries = $$.isTimeSeries(),
	        dataKeys = Object.keys(data[0] || {}),
	        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
	        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

	    ids.forEach(function (id) {
	      var xKey = _this3.getXKey(id);

	      _this3.isCustomX() || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
	        return d[xKey];
	      }).filter(isValue).map(function (rawX, i) {
	        return $$.generateTargetX(rawX, id, i);
	      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
	        return i;
	      }), xsData && (_this3.data.xs[id] = xsData);
	    }), ids.forEach(function (id) {
	      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"".concat(id, "\"."));
	    });
	    // convert to target
	    var targets = ids.map(function (id, index) {
	      var convertedId = config.data_idConverter(id),
	          xKey = $$.getXKey(id),
	          isCategorized = $$.isCustomX() && $$.isCategorized(),
	          hasCategory = isCategorized && data.map(function (v) {
	        return v.x;
	      }).every(function (v) {
	        return config.axis_x_categories.indexOf(v) > -1;
	      });
	      return {
	        id: convertedId,
	        id_org: id,
	        values: data.map(function (d, i) {
	          var x,
	              rawX = d[xKey],
	              value = d[id];
	          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
	            x: x,
	            value: value,
	            id: convertedId
	          };
	        }).filter(function (v) {
	          return isDefined(v.x);
	        })
	      };
	    }); // finish targets

	    return targets.forEach(function (t) {
	      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
	        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
	            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
	        return x1 - x2;
	      })), t.values.forEach(function (v, i) {
	        return v.index = i;
	      }), $$.data.xs[t.id].sort(function (v1, v2) {
	        return v1 - v2;
	      });
	    }), $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets), $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
	      return !(id in config.data_types);
	    }), config.data_type), targets.forEach(function (d) {
	      return $$.addCache(d.id_org, d, !0);
	    }), targets;
	  }
	});
	// CONCATENATED MODULE: ./src/data/data.load.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(ChartInternal_ChartInternal.prototype, {
	  load: function load(rawTargets, args) {
	    var $$ = this,
	        targets = rawTargets;
	    // Set targets
	    // Redraw with new targets
	    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
	      var type = args.types && args.types[t.id] || args.type;
	      $$.setTargetType(t.id, type);
	    }), $$.data.targets.forEach(function (d) {
	      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
	        d.values = targets[i].values, targets.splice(i, 1);
	        break;
	      }
	    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
	      withUpdateOrgXDomain: !0,
	      withUpdateXDomain: !0,
	      withLegend: !0
	    }), args.done && args.done();
	  },
	  loadFromArgs: function loadFromArgs(args) {
	    var $$ = this; // prevent load when chart is already destroyed

	    if ($$.config) {
	      $$.resetCache();
	      var data = args.data || $$.convertData(args, function (d) {
	        return $$.load($$.convertDataToTargets(d), args);
	      });
	      data && $$.load($$.convertDataToTargets(data), args);
	    } // reset internally cached data

	  },
	  unload: function unload(rawTargetIds, customDoneCb) {
	    var $$ = this,
	        done = customDoneCb,
	        targetIds = rawTargetIds;
	    // If no target, call done and return
	    return $$.resetCache(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
	      return $$.hasTarget($$.data.targets, id);
	    }), targetIds && targetIds.length !== 0 ? void ($$.svg.selectAll(targetIds.map(function (id) {
	      return $$.selectorTarget(id);
	    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
	      $$.withoutFadeIn[id] = !1, $$.legend && $$.legend.selectAll(".".concat(config_classes.legendItem).concat($$.getTargetSelectorSuffix(id))).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
	        return t.id !== id;
	      });
	    })) : void done();
	  }
	});
	// CONCATENATED MODULE: ./src/internals/category.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Category Name
	   * @private
	   * @param {Number} index
	   * @returns {String} gategory Name
	   */
	  categoryName: function categoryName(i) {
	    var config = this.config;
	    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
	var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(9);

	// CONCATENATED MODULE: ./src/interactions/interaction.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */






	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initialize the area that detects the event.
	   * Add a container for the zone that detects the event.
	   * @private
	   */
	  initEventRect: function initEventRect() {
	    var $$ = this;
	    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
	  },

	  /**
	   * Redraws the area that detects the event.
	   * @private
	   */
	  redrawEventRect: function redrawEventRect() {
	    var eventRectUpdate,
	        $$ = this,
	        config = $$.config,
	        isMultipleX = $$.isMultipleX(),
	        zoomEnabled = config.zoom_enabled,
	        eventRects = $$.main.select(".".concat(config_classes.eventRects)).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
	    if (eventRects.selectAll(".".concat(config_classes.eventRect)).remove(), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), isMultipleX) eventRectUpdate = $$.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
	      // Set data and update $$.eventRect
	      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

	      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $$.eventRect = eventRects.selectAll(".".concat(config_classes.eventRect)), eventRectUpdate = $$.eventRect.data(function (d) {
	        return d;
	      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
	    }
	    $$.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.inputType !== "touch" || $$.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
	  },
	  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
	    var startPx,
	        $$ = this,
	        config = $$.config,
	        getEventRect = function () {
	      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
	      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
	    },
	        getIndex = function (eventRect) {
	      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(".concat(config_classes.eventRect, "-?|s)"), "g"), "") * 1;
	      return (isNaN(index) || index === null) && (index = -1), index;
	    },
	        selectRect = function (context) {
	      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
	        var eventRect = getEventRect(),
	            index = getIndex(eventRect);
	        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
	      }
	    },
	        preventDefault = config.interaction_inputType_touch.preventDefault,
	        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
	        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
	        preventEvent = function (event) {
	      var eventType = event.type,
	          touch = event.changedTouches[0],
	          currentXY = touch["client".concat(config.axis_rotated ? "Y" : "X")];
	      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
	    };

	    // bind touch events
	    $$.svg.on("touchstart.eventRect touchmove.eventRect", function () {
	      var eventRect = getEventRect(),
	          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

	      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
	        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
	        if ($$.dragging || $$.flowing || $$.hasArcType() || event.touches.length > 1) return;
	        preventEvent(event), selectRect(this);
	      } else $$.unselectRect(), $$.callOverOutForTouch();
	    }, !0).on("touchend.eventRect", function () {
	      var eventRect = getEventRect();
	      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) && $$.cancelClick && ($$.cancelClick = !1);
	    }, !0);
	  },

	  /**
	   * Updates the location and size of the eventRect.
	   * @private
	   * @param {Object} d3.select(CLASS.eventRects) object.
	   */
	  updateEventRect: function updateEventRect(eventRectUpdate) {
	    var x,
	        y,
	        w,
	        h,
	        $$ = this,
	        config = $$.config,
	        xScale = $$.zoomScale || $$.x,
	        eventRectData = eventRectUpdate || $$.eventRect.data(),
	        isRotated = config.axis_rotated;
	    if ($$.isMultipleX()) // TODO: rotated not supported yet
	    x = 0, y = 0, w = $$.width, h = $$.height;else {
	      var rectW, rectX;
	      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
	        return xScale(d.x) - rectW / 2;
	      };else {
	        var getPrevNextX = function (d) {
	          var index = d.index;
	          return {
	            prev: $$.getPrevX(index),
	            next: $$.getNextX(index)
	          };
	        };

	        rectW = function (d) {
	          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

	          return x.prev === null && x.next === null ? isRotated ? $$.height : $$.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
	        }, rectX = function (d) {
	          var x = getPrevNextX(d),
	              thisX = d.x;
	          // if there this is a single data point position the eventRect at 0
	          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
	        };
	      }
	      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? $$.width : rectW, h = isRotated ? rectW : $$.height;
	    }
	    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
	  },
	  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
	    var $$ = this,
	        config = $$.config,
	        isSelectionEnabled = config.data_selection_enabled,
	        isSelectionGrouped = config.data_selection_grouped,
	        isTooltipGrouped = config.tooltip_grouped,
	        selectedData = $$.getAllValuesOnIndex(index);
	    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function () {
	      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
	    }).filter(function (d) {
	      return $$.isWithinShape(this, d);
	    }).call(function (selected) {
	      var d = selected.data();
	      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
	        return $$.expandCirclesBars(index, d.id);
	      }));
	    });
	  },
	  expandCirclesBars: function expandCirclesBars(index, id, reset) {
	    var $$ = this,
	        config = $$.config;
	    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
	  },
	  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
	    var $$ = this,
	        config = $$.config,
	        targetsToShow = $$.filterTargetsToShow($$.data.targets);

	    // do nothing when dragging
	    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
	      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
	          closest = $$.findClosestFromTargets(targetsToShow, mouse);
	      if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id) && (config.data_onout.call($$.api, $$.mouseover), $$.mouseover = undefined), !closest) return void $$.unselectRect();
	      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
	          selectedData = sameXData.map(function (d) {
	        return $$.addName(d);
	      }); // show tooltip when cursor is close to some point

	      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.svg.select(".".concat(config_classes.eventRect)).style("cursor", "pointer"), !$$.mouseover && (config.data_onover.call($$.api, closest), $$.mouseover = closest));
	    }
	  },

	  /**
	   * Unselect EventRect.
	   * @private
	   */
	  unselectRect: function unselectRect() {
	    var $$ = this;
	    $$.svg.select(".".concat(config_classes.eventRect)).style("cursor", null), $$.hideGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
	  },

	  /**
	   * Handle data.onover/out callback options
	   * @param {Boolean} isOver
	   * @param {Number|Object} d
	   * @private
	   */
	  setOverOut: function setOverOut(isOver, d) {
	    var $$ = this,
	        config = $$.config,
	        isArc = isObject(d);

	    // Call event handler
	    if (isArc || d !== -1) {
	      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
	      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, $$.main.select(".".concat(config_classes.arc).concat($$.getTargetSelectorSuffix(d.id))).node());else if (!config.tooltip_grouped) {
	        var callee = $$.setOverOut,
	            last = callee.last || [],
	            shape = $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).filter(function (d) {
	          return $$.isWithinShape(this, d);
	        });
	        shape.each(function (d) {
	          var _this = this;

	          (last.length === 0 || last.every(function (v) {
	            return v !== _this;
	          })) && (callback(d, this), last.push(this));
	        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
	          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
	        }), last = []), callee.last = last;
	      } else isOver && $$.expandCirclesBars(d, null, !0), $$.isMultipleX() || $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).each(function (d) {
	        callback(d, this);
	      });
	    }
	  },

	  /**
	   * Call data.onover/out callback for touch event
	   * @param {Number|Object} d target index or data object for Arc type
	   * @private
	   */
	  callOverOutForTouch: function callOverOutForTouch(d) {
	    var $$ = this,
	        callee = $$.callOverOutForTouch,
	        last = callee.last;
	    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
	  },

	  /**
	   * Return draggable selection function
	   * @return {Function}
	   * @private
	   */
	  getDraggableSelection: function getDraggableSelection() {
	    var $$ = this,
	        config = $$.config;
	    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
	      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
	    }).on("start", function () {
	      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
	    }).on("end", function () {
	      $$.dragend();
	    }) : function () {};
	  },

	  /**
	   * Create eventRect for each data on the x-axis.
	   * Register touch and drag events.
	   * @private
	   * @param {Object} d3.select(CLASS.eventRects) object.
	   * @returns {Object} d3.select(CLASS.eventRects) object.
	   */
	  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
	    var $$ = this,
	        config = $$.config,
	        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
	      $$.clickHandlerForSingleX.bind(this)(d, $$);
	    }).call($$.getDraggableSelection());
	    return $$.inputType === "mouse" && rect.on("mouseover", function (d) {
	      $$.dragging || $$.flowing || $$.hasArcType() || $$.config.tooltip_grouped && $$.setOverOut(!0, d.index);
	    }).on("mousemove", function (d) {
	      // do nothing while dragging/flowing
	      if (!($$.dragging || $$.flowing || $$.hasArcType())) {
	        var index = d.index,
	            eventRect = $$.svg.select(".".concat(config_classes.eventRect, "-").concat(index));
	        $$.isStepType(d) && $$.config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), $$.config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
	      }
	    }).on("mouseout", function (d) {
	      !$$.config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
	    }), rect;
	  },
	  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
	    var $$ = ctx,
	        config = $$.config;
	    if ($$.hasArcType() || !$$.toggleShape || $$.cancelClick) return void ($$.cancelClick && ($$.cancelClick = !1));
	    var index = d.index;
	    $$.main.selectAll(".".concat(config_classes.shape, "-").concat(index)).each(function (d2) {
	      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
	    });
	  },

	  /**
	   * Create an eventRect,
	   * Register touch and drag events.
	   * @private
	   * @param {Object} d3.select(CLASS.eventRects) object.
	   * @returns {Object} d3.select(CLASS.eventRects) object.
	   */
	  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
	    var $$ = this,
	        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", $$.width).attr("height", $$.height).attr("class", config_classes.eventRect).on("click", function () {
	      $$.clickHandlerForMultipleXS.bind(this)($$);
	    }).call($$.getDraggableSelection());
	    return $$.inputType === "mouse" && rect.on("mouseover mousemove", function () {
	      $$.selectRectForMultipleXs(this);
	    }).on("mouseout", function () {
	      !$$.config || $$.hasArcType() || $$.unselectRect();
	    }), rect;
	  },
	  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
	    var $$ = ctx,
	        config = $$.config,
	        targetsToShow = $$.filterTargetsToShow($$.data.targets);

	    if (!$$.hasArcType(targetsToShow)) {
	      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
	          closest = $$.findClosestFromTargets(targetsToShow, mouse);
	      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.main.selectAll(".".concat(config_classes.shapes).concat($$.getTargetSelectorSuffix(closest.id))).selectAll(".".concat(config_classes.shape, "-").concat(closest.index)).each(function () {
	        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
	      });
	    } // select if selection enabled

	  },

	  /**
	   * Dispatch a mouse event.
	   * @private
	   * @param {String} type event type
	   * @param {Number} index Index of eventRect
	   * @param {Array} mouse x and y coordinate value
	   */
	  dispatchEvent: function dispatchEvent(type, index, mouse) {
	    var $$ = this,
	        isMultipleX = $$.isMultipleX(),
	        selector = ".".concat(isMultipleX ? config_classes.eventRect : "".concat(config_classes.eventRect, "-").concat(index)),
	        eventRect = $$.main.select(selector).node(),
	        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
	        width = _eventRect$getBoundin.width,
	        left = _eventRect$getBoundin.left,
	        top = _eventRect$getBoundin.top,
	        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
	        y = top + (mouse ? mouse[1] : 0);

	    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
	      screenX: x,
	      screenY: y,
	      clientX: x,
	      clientY: y
	    });
	  }
	});
	// CONCATENATED MODULE: ./src/internals/size.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Update container size
	   * @private
	   */
	  setContainerSize: function setContainerSize() {
	    var $$ = this;
	    $$.currentWidth = $$.getCurrentWidth(), $$.currentHeight = $$.getCurrentHeight();
	  },
	  getCurrentWidth: function getCurrentWidth() {
	    var $$ = this;
	    return $$.config.size_width || $$.getParentWidth();
	  },
	  getCurrentHeight: function getCurrentHeight() {
	    var $$ = this,
	        config = $$.config,
	        h = config.size_height || $$.getParentHeight();
	    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
	  },

	  /**
	   * Get Axis size according its position
	   * @param {String} id Axis id value - x, y or y2
	   * @return {number} size Axis size value
	   * @private
	   */
	  getAxisSize: function getAxisSize(id) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated;
	    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
	  },
	  getCurrentPaddingTop: function getCurrentPaddingTop() {
	    var $$ = this,
	        config = $$.config,
	        axesLen = config.axis_y2_axes.length,
	        padding = isValue(config.padding_top) ? config.padding_top : 0;
	    return $$.title && $$.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
	  },
	  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
	    var $$ = this,
	        config = $$.config,
	        axisId = config.axis_rotated ? "y" : "x",
	        axesLen = config["axis_".concat(axisId, "_axes")].length,
	        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
	    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
	  },
	  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
	    var padding,
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        axisId = isRotated ? "x" : "y",
	        axesLen = config["axis_".concat(axisId, "_axes")].length,
	        axisWidth = $$.getAxisWidthByAxisId(axisId, withoutRecompute);
	    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getAxisLabelPosition("y").isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
	  },
	  getCurrentPaddingRight: function getCurrentPaddingRight() {
	    var padding,
	        withoutTickTextOverflow = !!(arguments.length > 0 && arguments[0] !== undefined) && arguments[0],
	        $$ = this,
	        config = $$.config,
	        defaultPadding = 10,
	        legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0,
	        axesLen = config.axis_y2_axes.length,
	        axisWidth = $$.getAxisWidthByAxisId("y2"),
	        xAxisTickTextOverflow = withoutTickTextOverflow ? 0 : $$.axis.getXAxisTickTextY2Overflow(defaultPadding);
	    return padding = isValue(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? defaultPadding + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? Math.max(2 + legendWidthOnRight + ($$.axis.getAxisLabelPosition("y2").isOuter ? 20 : 0), xAxisTickTextOverflow) : Math.max(ceil10(axisWidth) + legendWidthOnRight, xAxisTickTextOverflow), padding + axisWidth * axesLen;
	  },

	  /**
	   * Get the parent rect element's size
	   * @param {String} key property/attribute name
	   * @private
	   */
	  getParentRectValue: function getParentRectValue(key) {
	    for (var v, offsetName = "offset".concat(capitalize(key)), parent = this.selectChart.node(); !v && parent && parent.tagName !== "BODY";) {
	      try {
	        v = parent.getBoundingClientRect()[key];
	      } catch (e) {
	        offsetName in parent && (v = parent[offsetName]);
	      }

	      parent = parent.parentNode;
	    }

	    if (key === "width") {
	      // Sometimes element's width value is incorrect(ex. flex container)
	      // In this case, use body's offsetWidth instead.
	      var bodyWidth = browser_doc.body.offsetWidth;
	      v > bodyWidth && (v = bodyWidth);
	    }

	    return v;
	  },
	  getParentWidth: function getParentWidth() {
	    return this.getParentRectValue("width");
	  },
	  getParentHeight: function getParentHeight() {
	    var h = this.selectChart.style("height");
	    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
	  },
	  getSvgLeft: function getSvgLeft(withoutRecompute) {
	    var $$ = this,
	        config = $$.config,
	        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
	        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
	        leftAxis = $$.main.select(".".concat(leftAxisClass)).node(),
	        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
	      right: 0
	    },
	        chartRect = $$.selectChart.node().getBoundingClientRect(),
	        hasArc = $$.hasArcType(),
	        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
	    return svgLeft > 0 ? svgLeft : 0;
	  },
	  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
	    var $$ = this,
	        position = $$.axis.getLabelPositionById(id);
	    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
	  },
	  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        h = 30;
	    if (id === "x" && !config.axis_x_show) return 8;
	    if (id === "x" && config.axis_x_height) return config.axis_x_height;
	    if (id === "y" && !config.axis_y_show) return !config.legend_show || $$.isLegendRight || $$.isLegendInset ? 1 : 10;
	    if (id === "y2" && !config.axis_y2_show) return $$.rotated_padding_top; // const rotate = config[`axis_${id}_tick_rotate`];

	    var rotate = $$.getAxisTickRotate(id); // Calculate x/y axis height when tick rotated

	    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180), !config.axis_x_tick_multiline && $$.currentHeight && h > $$.currentHeight / 2 && (h = $$.currentHeight / 2)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
	  },
	  getEventRectWidth: function getEventRectWidth() {
	    return Math.max(0, this.xAxis.tickInterval());
	  },

	  /**
	   * Get axis tick test rotate value
	   * @param {String} id
	   * @return {Number} rotate value
	   * @private
	   */
	  getAxisTickRotate: function getAxisTickRotate(id) {
	    var $$ = this,
	        config = $$.config,
	        rotate = config["axis_".concat(id, "_tick_rotate")];

	    if (id === "x") {
	      var isCategorized = $$.isCategorized(),
	          isTimeSeries = $$.isTimeSeries(),
	          allowedXAxisTypes = isCategorized || isTimeSeries,
	          tickCount = 0;
	      config.axis_x_tick_fit && allowedXAxisTypes && ($$.axis.x = {
	        padding: {
	          left: 0,
	          right: 0
	        },
	        tickCount: 0
	      }, tickCount = $$.currentMaxTickWidths.x.ticks.length + (isTimeSeries ? -1 : 1), tickCount !== $$.axis.x.tickCount && ($$.axis.x.padding = $$.axis.getXAxisPadding(tickCount)), $$.axis.x.tickCount = tickCount), $$.svg && config.axis_x_tick_fit && !config.axis_x_tick_multiline && !config.axis_x_tick_culling && config.axis_x_tick_autorotate && allowedXAxisTypes && (rotate = $$.needToRotateXAxisTickTexts() ? config.axis_x_tick_rotate : 0);
	    }

	    return rotate;
	  },

	  /**
	   * Check weather axis tick text needs to be rotated
	   * @private
	   */
	  needToRotateXAxisTickTexts: function needToRotateXAxisTickTexts() {
	    var $$ = this,
	        xAxisLength = $$.currentWidth - $$.getCurrentPaddingLeft(!1) - $$.getCurrentPaddingRight(!0),
	        tickCountWithPadding = $$.axis.x.tickCount + $$.axis.x.padding.left + $$.axis.x.padding.right,
	        maxTickWidth = $$.axis.getMaxTickWidth("x");
	    return maxTickWidth > (xAxisLength / tickCountWithPadding || 0);
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
	var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(10);

	// CONCATENATED MODULE: ./src/shape/shape.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  getShapeIndices: function getShapeIndices(typeFilter) {
	    var $$ = this,
	        config = $$.config,
	        xs = config.data_xs,
	        hasXs = notEmpty(xs),
	        indices = {},
	        i = hasXs ? {} : 0;
	    return hasXs && getUnique(Object.keys(xs).map(function (v) {
	      return xs[v];
	    })).forEach(function (v) {
	      i[v] = 0, indices[v] = {};
	    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
	      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
	        ind[d.id] = ind[_row4];
	        break;
	      }

	      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
	    }), indices;
	  },

	  /**
	   * Get indices value based on data ID value
	   * @param {Object} indices Indices object
	   * @param {String} id Data id value
	   * @return {Object} Indices object
	   * @private
	   */
	  getIndices: function getIndices(indices, id) {
	    var xs = this.config.data_xs;
	    return notEmpty(xs) ? indices[xs[id]] : indices;
	  },

	  /**
	   * Get indices max number
	   * @param {Object} indices Indices object
	   * @return {Number} Max number
	   * @private
	   */
	  getIndicesMax: function getIndicesMax(indices) {
	    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
	    Object.keys(indices).map(function (v) {
	      return indices[v].__max__ || 0;
	    }).reduce(function (acc, curr) {
	      return acc + curr;
	    }) : indices.__max__;
	  },
	  getShapeX: function getShapeX(offset, indices, isSub) {
	    var $$ = this,
	        scale = isSub ? $$.subX : $$.zoomScale || $$.x,
	        barPadding = $$.config.bar_padding,
	        sum = function (p, c) {
	      return p + c;
	    },
	        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

	    return function (d) {
	      var ind = $$.getIndices(indices, d.id),
	          index = d.id in ind ? ind[d.id] : 0,
	          targetsNum = (ind.__max__ || 0) + 1,
	          x = 0;

	      if (notEmpty(d.x)) {
	        var xPos = scale(d.x);
	        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
	      } // adjust x position for bar.padding optionq


	      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
	    };
	  },
	  getShapeY: function getShapeY(isSub) {
	    var $$ = this,
	        isStackNormalized = $$.isStackNormalized();
	    return function (d) {
	      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
	      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(value);
	    };
	  },

	  /**
	   * Get shape based y Axis min value
	   * @param {String} id Data id
	   * @return {Number}
	   * @private
	   */
	  getShapeYMin: function getShapeYMin(id) {
	    var $$ = this,
	        _$$$$$$axis$getId$dom = $$[$$.axis.getId(id)].domain(),
	        _$$$$$$axis$getId$dom2 = _slicedToArray(_$$$$$$axis$getId$dom, 1),
	        yMin = _$$$$$$axis$getId$dom2[0];

	    return !$$.isGrouped(id) && yMin > 0 ? yMin : 0;
	  },

	  /**
	   * Get Shape's offset data
	   * @param {function(Object): boolean} typeFilter
	   * @return {{shapeOffsetTargets: ShapeOffsetTarget[], indexMapByTargetId: object}}
	   * @private
	   */
	  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
	    var $$ = this,
	        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
	        isStackNormalized = $$.isStackNormalized(),
	        shapeOffsetTargets = targets.map(function (target) {
	      var rowValues = target.values,
	          values = {};
	      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
	      var rowValueMapByXValue = rowValues.reduce(function (out, d) {
	        var key = +d.x;
	        return out[key] = d, values[key] = isStackNormalized ? $$.getRatio("index", d, !0) : d.value, out;
	      }, {});
	      return {
	        id: target.id,
	        rowValues: rowValues,
	        rowValueMapByXValue: rowValueMapByXValue,
	        values: values
	      };
	    }),
	        indexMapByTargetId = targets.reduce(function (out, _ref, index) {
	      var id = _ref.id;
	      return out[id] = index, out;
	    }, {});
	    return {
	      indexMapByTargetId: indexMapByTargetId,
	      shapeOffsetTargets: shapeOffsetTargets
	    };
	  },
	  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
	    var $$ = this,
	        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
	        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
	        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

	    return function (d, idx) {
	      var ind = $$.getIndices(indices, d.id),
	          scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
	          y0 = scale($$.getShapeYMin(d.id)),
	          dataXAsNumber = +d.x,
	          offset = y0;
	      return shapeOffsetTargets.filter(function (t) {
	        return t.id !== d.id;
	      }).forEach(function (t) {
	        if (ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
	          var row = t.rowValues[idx]; // check if the x values line up

	          row && +row.x === dataXAsNumber || (row = t.rowValueMapByXValue[dataXAsNumber]), row && row.value * d.value >= 0 && (offset += scale(t.values[dataXAsNumber]) - y0);
	        }
	      }), offset;
	    };
	  },
	  isWithinShape: function isWithinShape(that, d) {
	    var isWithin,
	        $$ = this,
	        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
	    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
	  },
	  getInterpolate: function getInterpolate(d) {
	    var $$ = this,
	        interpolation = $$.getInterpolateType(d);
	    return {
	      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
	      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
	      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
	      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
	      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
	      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
	      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
	      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
	      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
	      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
	      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
	      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
	      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
	      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
	      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
	      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
	      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
	      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
	    }[interpolation];
	  },
	  getInterpolateType: function getInterpolateType(d) {
	    var $$ = this,
	        type = $$.config.spline_interpolation_type,
	        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
	    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
	var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(11);

	// CONCATENATED MODULE: ./src/shape/arc.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */







	extend(ChartInternal_ChartInternal.prototype, {
	  initPie: function initPie() {
	    var $$ = this,
	        config = $$.config,
	        dataType = config.data_type,
	        padding = config.pie_padding,
	        startingAngle = config["".concat(dataType, "_startingAngle")] || 0,
	        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config["".concat(dataType, "_padAngle")]) || 0;
	    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues($$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
	      return $$.isOrderAsc() ? a - b : b - a;
	    } : null).value(function (d) {
	      return d.values.reduce(function (a, b) {
	        return a + b.value;
	      }, 0);
	    });
	  },
	  updateRadius: function updateRadius() {
	    var $$ = this,
	        config = $$.config,
	        radius = config.pie_innerRadius,
	        padding = config.pie_padding,
	        w = config.gauge_width || config.donut_width,
	        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
	    $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), $$.radius = $$.radiusExpanded * .95, $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : .6, $$.gaugeArcWidth = w || (gaugeArcWidth <= $$.radius - $$.innerRadius ? $$.radius - $$.innerRadius : gaugeArcWidth <= $$.radius ? gaugeArcWidth : $$.radius);
	    var innerRadius = radius || (padding ? padding * ($$.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

	    $$.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? $$.radius * $$.innerRadiusRatio : innerRadius;
	  },
	  getInnerRadius: function getInnerRadius(d) {
	    var $$ = this,
	        radius = $$.innerRadius;
	    return !isNumber(radius) && d && (radius = radius[d.data.id] || 0), radius;
	  },
	  updateArc: function updateArc() {
	    var $$ = this;
	    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
	  },
	  updateAngle: function updateAngle(dValue) {
	    var $$ = this,
	        config = $$.config,
	        pie = $$.pie,
	        d = dValue,
	        found = !1;
	    if (!config) return null;
	    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
	        gStart = config.gauge_startingAngle;

	    if (d.data && $$.isGaugeType(d.data) && !$$.hasMultiArcGauge()) {
	      // to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value
	      var totalSum = $$.getTotalDataSum($$.rendered); // if gauge_max less than totalSum, make totalSum to max value

	      totalSum > config.gauge_max && (config.gauge_max = totalSum);
	      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
	      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
	    }

	    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
	      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
	    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
	      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

	      maxValue > config.gauge_max && (config.gauge_max = maxValue);
	      var gMin = config.gauge_min,
	          gMax = config.gauge_max,
	          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
	      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
	    }

	    return found ? d : null;
	  },
	  getSvgArc: function getSvgArc() {
	    var $$ = this,
	        ir = $$.getInnerRadius(),
	        singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
	        hasMultiArcGauge = $$.hasMultiArcGauge(),
	        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
	      return hasMultiArcGauge ? $$.radius - singleArcWidth * d.index : $$.radius;
	    }).innerRadius(function (d) {
	      return hasMultiArcGauge ? $$.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
	    }),
	        newArc = function (d, withoutUpdate) {
	      var path = "M 0 0";

	      if (d.value || d.data) {
	        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
	        var updated = !withoutUpdate && $$.updateAngle(d);
	        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
	      }

	      return path;
	    };

	    return newArc.centroid = arc.centroid, newArc;
	  },
	  getSvgArcExpanded: function getSvgArcExpanded(rate) {
	    var $$ = this,
	        newRate = rate || 1,
	        singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
	        hasMultiArcGauge = $$.hasMultiArcGauge(),
	        expandWidth = Math.min($$.radiusExpanded * newRate - $$.radius, singleArcWidth * .8 - (1 - newRate) * 100),
	        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
	      return hasMultiArcGauge ? $$.radius - singleArcWidth * d.index + expandWidth : $$.radiusExpanded * newRate;
	    }).innerRadius(function (d) {
	      return hasMultiArcGauge ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius;
	    });
	    return function (d) {
	      var updated = $$.updateAngle(d);
	      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
	    };
	  },
	  getArc: function getArc(d, withoutUpdate, force) {
	    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
	  },
	  transformForArcLabel: function transformForArcLabel(d) {
	    var $$ = this,
	        config = $$.config,
	        updated = $$.updateAngle(d),
	        translate = "";
	    if (updated) if ($$.hasMultiArcGauge()) {
	      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
	          x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25),
	          y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
	      translate = "translate(".concat(x, ",").concat(y, ")");
	    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
	      var c = this.svgArc.centroid(updated),
	          x = isNaN(c[0]) ? 0 : c[0],
	          y = isNaN(c[1]) ? 0 : c[1],
	          h = Math.sqrt(x * x + y * y),
	          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
	      ratio = ratio ? isFunction(ratio) ? ratio(d, $$.radius, h) : ratio : $$.radius && (h ? (36 / $$.radius > .375 ? 1.175 - 36 / $$.radius : .8) * $$.radius / h : 0), translate = "translate(".concat(x * ratio, ",").concat(y * ratio, ")");
	    }
	    return translate;
	  },
	  convertToArcData: function convertToArcData(d) {
	    return this.addName({
	      id: d.data.id,
	      value: d.value,
	      ratio: this.getRatio("arc", d),
	      index: d.index
	    });
	  },
	  textForArcLabel: function textForArcLabel(selection) {
	    var $$ = this,
	        hasGauge = $$.hasType("gauge");
	    $$.shouldShowArcLabel() && selection.each(function (d) {
	      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	          updated = $$.updateAngle(d),
	          ratio = $$.getRatio("arc", updated),
	          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

	      if (isUnderThreshold) {
	        var value = (updated || d).value,
	            text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, d.data.id).toString();
	        setTextValue(node, text, [-1, 1], hasGauge);
	      } else node.text("");
	    });
	  },
	  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
	    var format = this.getGaugeLabelExtents();
	    return format ? format(value, isMax) : value;
	  },
	  expandArc: function expandArc(targetIds) {
	    var $$ = this; // MEMO: avoid to cancel transition

	    if ($$.transiting) {
	      var interval = setInterval(function () {
	        $$.transiting || (clearInterval(interval), $$.legend.selectAll(".".concat(config_classes.legendItemFocused)).size() > 0 && $$.expandArc(targetIds));
	      }, 10);
	      return;
	    }

	    var newTargetIds = $$.mapToTargetIds(targetIds);
	    $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).each(function (d) {
	      if ($$.shouldExpand(d.data.id)) {
	        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
	            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
	        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
	      }
	    });
	  },
	  unexpandArc: function unexpandArc(targetIds) {
	    var $$ = this;

	    if (!$$.transiting) {
	      var newTargetIds = $$.mapToTargetIds(targetIds);
	      $$.svg.selectAll($$.selectorTargets(newTargetIds, ".".concat(config_classes.chartArc))).selectAll("path").transition().duration(function (d) {
	        return $$.getExpandConfig(d.data.id, "duration");
	      }).attr("d", $$.svgArc), $$.svg.selectAll("".concat(config_classes.arc)).style("opacity", "1");
	    }
	  },

	  /**
	   * Get expand config value
	   * @param {String} id data ID
	   * @param {String} key config key: 'duration | rate'
	   * @return {Number}
	   * @private
	   */
	  getExpandConfig: function getExpandConfig(id, key) {
	    var type,
	        $$ = this,
	        config = $$.config;
	    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config["".concat(type, "_expand_").concat(key)] : {
	      duration: 50,
	      rate: .98
	    }[key];
	  },
	  shouldExpand: function shouldExpand(id) {
	    var $$ = this,
	        config = $$.config;
	    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
	  },
	  shouldShowArcLabel: function shouldShowArcLabel() {
	    var $$ = this,
	        config = $$.config;
	    return ["pie", "donut", "gauge"].some(function (v) {
	      return $$.hasType(v) && config["".concat(v, "_label_show")];
	    });
	  },
	  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
	    var $$ = this,
	        config = $$.config,
	        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
	    return ratio >= threshold;
	  },
	  getArcLabelFormat: function getArcLabelFormat() {
	    var $$ = this,
	        config = $$.config,
	        format = config.pie_label_format;
	    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
	  },
	  getGaugeLabelExtents: function getGaugeLabelExtents() {
	    var config = this.config;
	    return config.gauge_label_extents;
	  },
	  getArcTitle: function getArcTitle() {
	    var $$ = this,
	        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
	    return type ? $$.config["".concat(type, "_title")] : "";
	  },
	  updateTargetsForArc: function updateTargetsForArc(targets) {
	    var $$ = this,
	        main = $$.main,
	        hasGauge = $$.hasType("gauge"),
	        classChartArc = $$.classChartArc.bind($$),
	        classArcs = $$.classArcs.bind($$),
	        classFocus = $$.classFocus.bind($$),
	        mainPieUpdate = main.select(".".concat(config_classes.chartArcs)).selectAll(".".concat(config_classes.chartArc)).data($$.pie(targets)).attr("class", function (d) {
	      return classChartArc(d) + classFocus(d.data);
	    }),
	        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
	    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
	  },
	  initArc: function initArc() {
	    var $$ = this;
	    $$.arcs = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
	  },

	  /**
	   * Set arc title text
	   * @private
	   */
	  setArcTitle: function setArcTitle() {
	    var $$ = this,
	        title = $$.getArcTitle(),
	        hasGauge = $$.hasType("gauge");

	    if (title) {
	      var text = $$.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
	      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
	    }
	  },
	  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
	    var $$ = this,
	        config = $$.config,
	        main = $$.main,
	        hasInteraction = config.interaction_enabled,
	        mainArc = main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arc)).data($$.arcData.bind($$));
	    // bind arc events
	    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
	      return $$.color(d.data);
	    }).style("cursor", function (d) {
	      return hasInteraction && config.data_selection_isselectable(d) ? "pointer" : null;
	    }).style("opacity", "0").each(function (d) {
	      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
	    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
	      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
	    }).style("opacity", function (d) {
	      return d === this._current ? "0" : "1";
	    }).each(function () {
	      $$.transiting = !0;
	    }).transition().duration(duration).attrTween("d", function (d) {
	      var updated = $$.updateAngle(d);
	      if (!updated) return function () {
	        return "M 0 0";
	      };
	      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
	      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
	      return this._current = interpolate(0), function (t) {
	        var interpolated = interpolate(t);
	        // data.id will be updated by interporator
	        return interpolated.data = d.data, $$.getArc(interpolated, !0);
	      };
	    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
	      var color;
	      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
	    }) // Where gauge reading color would receive customization.
	    .style("opacity", "1").call($$.endall, function () {
	      if ($$.levelColor) {
	        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	            d = path.datum();
	        $$.updateLegendItemColor(d.data.id, path.style("fill"));
	      }

	      $$.transiting = !1, callFn(config.onrendered, $$, $$.api);
	    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
	  },
	  redrawMultiArcGauge: function redrawMultiArcGauge() {
	    var $$ = this,
	        config = $$.config,
	        arcLabelLines = $$.main.selectAll(".".concat(config_classes.arcs)).selectAll(".".concat(config_classes.arcLabelLine)).data($$.arcData.bind($$)),
	        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
	      return "".concat(config_classes.arcLabelLine, " ").concat(config_classes.target, " ").concat(config_classes.target, "-").concat(d.data.id);
	    }).merge(arcLabelLines);
	    mainArcLabelLine.style("fill", function (d) {
	      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
	    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
	      var lineLength = 0,
	          lineThickness = 2,
	          x = 0,
	          y = 0,
	          transform = "";

	      if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {
	        var updated = $$.updateAngle(d),
	            innerLineLength = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
	            lineAngle = updated.endAngle - Math.PI / 2,
	            arcInnerRadius = $$.radius - innerLineLength,
	            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
	        lineLength = $$.radiusExpanded - $$.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(".concat(lineAngle * 180 / Math.PI, ", ").concat(x, ", ").concat(y, ")");
	      }

	      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, ".concat(lineLength + lineThickness, ", 0"));
	    });
	  },
	  bindArcEvent: function bindArcEvent(arc) {
	    function selectArc(_this, arcData, id) {
	      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
	    }

	    function unselectArc(arcData) {
	      var id = arcData && arcData.id || undefined;
	      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
	    }

	    var $$ = this,
	        isTouch = $$.inputType === "touch",
	        isMouse = $$.inputType === "mouse";

	    // touch events
	    if (arc.on("click", function (d, i) {
	      var arcData,
	          updated = $$.updateAngle(d);
	      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), $$.config.data_onclick.call($$.api, arcData, this));
	    }), isMouse && arc.on("mouseover", function (d) {
	      if (!$$.transiting) // skip while transiting
	        {
	          var updated = $$.updateAngle(d),
	              arcData = updated ? $$.convertToArcData(updated) : null,
	              id = arcData && arcData.id || undefined;
	          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
	        }
	    }).on("mouseout", function (d) {
	      if (!$$.transiting) // skip while transiting
	        {
	          var updated = $$.updateAngle(d),
	              arcData = updated ? $$.convertToArcData(updated) : null;
	          unselectArc(), $$.setOverOut(!1, arcData);
	        }
	    }).on("mousemove", function (d) {
	      var updated = $$.updateAngle(d),
	          arcData = updated ? $$.convertToArcData(updated) : null;
	      $$.showTooltip([arcData], this);
	    }), isTouch && $$.hasArcType() && !$$.radars) {
	      var getEventArc = function () {
	        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
	            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
	        return eventArc;
	      },
	          handler = function () {
	        if (!$$.transiting) // skip while transiting
	          {
	            var eventArc = getEventArc(),
	                datum = eventArc.datum(),
	                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
	                arcData = updated ? $$.convertToArcData(updated) : null,
	                id = arcData && arcData.id || undefined;
	            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
	          }
	      };

	      $$.svg.on("touchstart", handler).on("touchmove", handler);
	    }
	  },
	  redrawArcText: function redrawArcText(duration) {
	    var text,
	        $$ = this,
	        config = $$.config,
	        main = $$.main,
	        hasGauge = $$.hasType("gauge"),
	        hasMultiArcGauge = $$.hasMultiArcGauge();

	    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll(".".concat(config_classes.chartArc)).select("text").style("opacity", "0").attr("class", function (d) {
	      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
	    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
	      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? "".concat(Math.round($$.radius / 5), "px") : null;
	    }).transition().duration(duration).style("opacity", function (d) {
	      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
	    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select(".".concat(config_classes.chartArcsTitle)).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
	      var isFullCircle = config.gauge_fullCircle,
	          startAngle = -1 * Math.PI / 2,
	          endAngle = (isFullCircle ? -4 : -1) * startAngle;
	      isFullCircle && text && text.attr("dy", "".concat(Math.round($$.radius / 14)));
	      var backgroundArc = $$.arcs.select("".concat(hasMultiArcGauge ? "g" : "", ".").concat(config_classes.chartArcsBackground));

	      if (hasMultiArcGauge) {
	        var index = 0;
	        backgroundArc = backgroundArc.selectAll("path.".concat(config_classes.chartArcsBackground)).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
	          return "".concat(config_classes.chartArcsBackground, " ").concat(config_classes.chartArcsBackground, "-").concat(i);
	        }).merge(backgroundArc).attr("d", function (d1) {
	          if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
	          var d = {
	            data: [{
	              value: config.gauge_max
	            }],
	            startAngle: startAngle,
	            endAngle: endAngle,
	            index: index++
	          };
	          return $$.getArc(d, !0, !0);
	        }), backgroundArc.exit().remove();
	      } else backgroundArc.attr("d", function () {
	        var d = {
	          data: [{
	            value: config.gauge_max
	          }],
	          startAngle: startAngle,
	          endAngle: endAngle
	        };
	        return $$.getArc(d, !0, !0);
	      });

	      $$.arcs.select(".".concat(config_classes.chartArcsGaugeUnit)).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && ($$.arcs.select(".".concat(config_classes.chartArcsGaugeMin)).attr("dx", "".concat(-1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (isFullCircle ? 1 : 2)), "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && $$.arcs.select(".".concat(config_classes.chartArcsGaugeMax)).attr("dx", "".concat($$.innerRadius + ($$.radius - $$.innerRadius) / 2, "px")).attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
	    }
	  },
	  initGauge: function initGauge() {
	    var $$ = this,
	        config = $$.config,
	        arcs = $$.arcs,
	        appendText = function (className) {
	      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
	    };

	    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
	  },
	  getGaugeLabelHeight: function getGaugeLabelHeight() {
	    return this.config.gauge_label_show ? 20 : 0;
	  }
	});
	// CONCATENATED MODULE: ./src/shape/bar.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	extend(ChartInternal_ChartInternal.prototype, {
	  initBar: function initBar() {
	    var $$ = this;
	    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars);
	  },
	  updateTargetsForBar: function updateTargetsForBar(targets) {
	    var $$ = this,
	        config = $$.config,
	        classChartBar = $$.classChartBar.bind($$),
	        classBars = $$.classBars.bind($$),
	        classFocus = $$.classFocus.bind($$),
	        mainBarUpdate = $$.main.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", function (d) {
	      return classChartBar(d) + classFocus(d);
	    }),
	        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
	    // Bars for each data
	    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
	      return config.data_selection_isselectable(d) ? "pointer" : null;
	    });
	  },
	  updateBar: function updateBar(durationForExit) {
	    var $$ = this,
	        barData = $$.barData.bind($$),
	        classBar = $$.classBar.bind($$),
	        initialOpacity = $$.initialOpacity.bind($$);
	    $$.mainBar = $$.main.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data(barData), $$.mainBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainBar = $$.mainBar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($$.mainBar).style("opacity", initialOpacity);
	  },
	  redrawBar: function redrawBar(drawBar, withTransition) {
	    return [(withTransition ? this.mainBar.transition(getRandom()) : this.mainBar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
	  },
	  getBarW: function getBarW(axis, barTargetsNum) {
	    var result,
	        $$ = this,
	        config = $$.config,
	        maxDataCount = $$.getMaxDataCount(),
	        isGrouped = $$.isGrouped(),
	        tickInterval = ($$.zoomScale || $$) && !$$.isCategorized() ? $$.xx($$.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
	        getWidth = function (id) {
	      var width = id ? config.bar_width[id] : config.bar_width,
	          ratio = id ? width.ratio : config.bar_width_ratio,
	          max = id ? width.max : config.bar_width_max,
	          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
	      return max && w > max ? max : w;
	    };

	    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
	      width: result,
	      total: []
	    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
	      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
	    })), result;
	  },
	  getBars: function getBars(i, id) {
	    var $$ = this,
	        suffix = isValue(i) ? "-".concat(i) : "";
	    return (id ? $$.main.selectAll(".".concat(config_classes.bars).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.bar).concat(suffix));
	  },
	  expandBars: function expandBars(i, id, reset) {
	    var $$ = this;
	    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
	  },
	  unexpandBars: function unexpandBars(i) {
	    this.getBars(i).classed(config_classes.EXPANDED, !1);
	  },
	  generateDrawBar: function generateDrawBar(barIndices, isSub) {
	    var $$ = this,
	        config = $$.config,
	        getPoints = $$.generateGetBarPoints(barIndices, isSub),
	        isRotated = config.axis_rotated,
	        isGrouped = $$.isGrouped(),
	        barRadius = config.bar_radius,
	        barRadiusRatio = config.bar_radius_ratio,
	        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
	      return barRadius;
	    } : isNumber(barRadiusRatio) ? function (w) {
	      return w * barRadiusRatio;
	    } : null;
	    return function (d, i) {
	      // 4 points that make a bar
	      var points = getPoints(d, i),
	          indexX = +isRotated,
	          indexY = +!indexX,
	          isNegative = d.value < 0,
	          pathRadius = ["", ""],
	          radius = 0; // switch points if axis is rotated, not applicable for sub chart

	      if (getRadius && !isGrouped) {
	        var index = isRotated ? indexY : indexX,
	            barW = points[2][index] - points[0][index];
	        radius = getRadius(barW);
	        var arc = "a".concat(radius, ",").concat(radius, " ").concat(isNegative ? "1 0 0" : "0 0 1", " ");
	        pathRadius[+!isRotated] = "".concat(arc).concat(radius, ",").concat(radius), pathRadius[+isRotated] = "".concat(arc).concat([-radius, radius][isRotated ? "sort" : "reverse"]()), isNegative && pathRadius.reverse();
	      } // path string data shouldn't be containing new line chars
	      // https://github.com/naver/billboard.js/issues/530


	      var path = isRotated ? "H".concat(points[1][indexX] - radius, " ").concat(pathRadius[0], "V").concat(points[2][indexY] - radius, " ").concat(pathRadius[1], "H").concat(points[3][indexX]) : "V".concat(points[1][indexY] + (isNegative ? -radius : radius), " ").concat(pathRadius[0], "H").concat(points[2][indexX] - radius, " ").concat(pathRadius[1], "V").concat(points[3][indexY]);
	      return "M".concat(points[0][indexX], ",").concat(points[0][indexY]).concat(path, "z");
	    };
	  },
	  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
	    var $$ = this,
	        axis = isSub ? $$.subXAxis : $$.xAxis,
	        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
	        barW = $$.getBarW(axis, barTargetsNum),
	        barX = $$.getShapeX(barW, barIndices, !!isSub),
	        barY = $$.getShapeY(!!isSub),
	        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
	        yScale = isSub ? $$.getSubYScale : $$.getYScale;
	    return function (d, i) {
	      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
	          offset = barOffset(d, i) || y0,
	          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
	          posX = barX(d),
	          posY = barY(d);
	      // 4 points that make a bar
	      return $$.config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
	    };
	  },
	  isWithinBar: function isWithinBar(that) {
	    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
	        list = getRectSegList(that),
	        _list2 = _slicedToArray(list, 2),
	        seg0 = _list2[0],
	        seg1 = _list2[1],
	        x = Math.min(seg0.x, seg1.x),
	        y = Math.min(seg0.y, seg1.y),
	        offset = this.config.bar_sensitivity,
	        _that$getBBox = that.getBBox(),
	        width = _that$getBBox.width,
	        height = _that$getBBox.height;

	    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
	  }
	});
	// CONCATENATED MODULE: ./src/shape/bubble.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initializer
	   * @private
	   */
	  initBubble: function initBubble() {
	    var $$ = this,
	        config = $$.config;
	    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
	  },

	  /**
	   * Get user agent's computed value for the total length of the path in user units
	   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
	   * @return {Number}
	   * @private
	   */
	  getBaseLength: function getBaseLength() {
	    var $$ = this,
	        cacheKey = "$baseLength",
	        baseLength = $$.getCache(cacheKey);
	    return baseLength || $$.addCache(cacheKey, baseLength = getMinMax("min", [$$.axes.x.select("path").node().getTotalLength(), $$.axes.y.select("path").node().getTotalLength()])), baseLength;
	  },

	  /**
	   * Get the radius value for bubble circle
	   * @param {Object} d
	   * @return {Number}
	   * @private
	  	 */
	  getBubbleR: function getBubbleR(d) {
	    var $$ = this,
	        maxR = $$.config.bubble_maxR;
	    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
	    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
	      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
	    })),
	        maxArea = maxR * maxR * Math.PI,
	        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
	    return Math.sqrt(area / Math.PI);
	  },

	  /**
	   * Get bubble dimension data
	   * @param {Object|Array} d data value
	   * @param {String} type - y or z
	   * @return {Number}
	   * @private
	   */
	  getBubbleZData: function getBubbleZData(d, type) {
	    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
	  },

	  /**
	   * Determine if bubble has dimension data
	   * @param {Object|array} d data value
	   * @return {Boolean}
	   * @private
	   */
	  isBubbleZType: function isBubbleZType(d) {
	    var $$ = this;
	    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
	  }
	});
	// CONCATENATED MODULE: ./src/shape/line.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  initLine: function initLine() {
	    var $$ = this;
	    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines);
	  },
	  updateTargetsForLine: function updateTargetsForLine(targets) {
	    var $$ = this,
	        config = $$.config,
	        classChartLine = $$.classChartLine.bind($$),
	        classLines = $$.classLines.bind($$),
	        classAreas = $$.classAreas.bind($$),
	        classCircles = $$.classCircles.bind($$),
	        classFocus = $$.classFocus.bind($$),
	        mainLineUpdate = $$.main.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", function (d) {
	      return classChartLine(d) + classFocus(d);
	    }),
	        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
	    // Lines for each data
	    // Areas
	    // Update date for selected circles
	    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
	      return $$.generateClass(config_classes.selectedCircles, d.id);
	    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
	      return config.data_selection_isselectable(d) ? "pointer" : null;
	    })), targets.forEach(function (t) {
	      $$.main.selectAll(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(t.id))).selectAll("".concat(config_classes.selectedCircle)).each(function (d) {
	        d.value = t.values[d.index].value;
	      });
	    });
	  },
	  updateLine: function updateLine(durationForExit) {
	    var $$ = this;
	    $$.mainLine = $$.main.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.mainLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainLine = $$.mainLine.enter().append("path").attr("class", function (d) {
	      return "".concat($$.classLine.bind($$)(d), " ").concat($$.extraLineClasses(d) || "");
	    }).style("stroke", $$.color).merge($$.mainLine).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
	      return $$.isStepType(d) ? "crispEdges" : "";
	    }).attr("transform", null);
	  },
	  redrawLine: function redrawLine(drawLine, withTransition) {
	    return [(withTransition ? this.mainLine.transition(getRandom()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
	  },

	  /**
	   * Get the curve interpolate
	   * @param {Array} d Data object
	   * @return {Function}
	   * @private
	   */
	  getCurve: function getCurve(d) {
	    var $$ = this,
	        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
	    // when is step & rotated, should be computed in different way
	    // https://github.com/naver/billboard.js/issues/471
	    return isRotatedStepType ? function (context) {
	      var step = $$.getInterpolate(d)(context); // keep the original method

	      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
	        this._point === 1 && (this._point = 2);
	        var y1 = this._y * (1 - this._t) + y * this._t;
	        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
	      }, step.point = function (x, y) {
	        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
	      }, step;
	    } : $$.getInterpolate(d);
	  },
	  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
	    var $$ = this,
	        config = $$.config,
	        lineConnectNull = config.line_connectNull,
	        isRotated = config.axis_rotated,
	        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
	        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
	        xValue = function (d) {
	      return (isSub ? $$.subxx : $$.xx).call($$, d);
	    },
	        yValue = function (d, i) {
	      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
	    },
	        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

	    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
	      return $$.getBaseValue(d) !== null;
	    }));
	    var x = isSub ? $$.subX : $$.x;
	    return function (d) {
	      var path,
	          y = yScaleGetter.call($$, d.id),
	          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
	          x0 = 0,
	          y0 = 0;

	      if ($$.isLineType(d)) {
	        var regions = config.data_regions[d.id];
	        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
	      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

	      return path || "M 0 0";
	    };
	  },
	  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
	    // partial duplication of generateGetBarPoints
	    var $$ = this,
	        config = $$.config,
	        isSub = !!isSubValue,
	        x = $$.getShapeX(0, lineIndices, isSub),
	        y = $$.getShapeY(isSub),
	        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
	        yScale = isSub ? $$.getSubYScale : $$.getYScale;
	    return function (d, i) {
	      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
	          offset = lineOffset(d, i) || y0,
	          posX = x(d),
	          posY = y(d);
	      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
	      // 1 point that marks the line position
	      var point = [posX, posY - (y0 - offset)];
	      return [point, point, // from here and below, needed for compatibility
	      point, point];
	    };
	  },
	  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
	    var xp,
	        yp,
	        diff,
	        diffx2,
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        isTimeSeries = $$.isTimeSeries(),
	        xOffset = $$.isCategorized() ? .5 : 0,
	        regions = [],
	        dasharray = "2 2",
	        isWithinRegions = function (withinX, withinRegions) {
	      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

	      return !1;
	    };

	    // Check start/end of regions
	    if (isDefined(_regions)) {
	      var getValue = function (v, def) {
	        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
	      };

	      for (var reg, i = 0; reg = _regions[i]; i++) {
	        var start = getValue(reg.start, d[0].x),
	            end = getValue(reg.end, d[d.length - 1].x),
	            style = reg.style || {
	          dasharray: dasharray
	        };
	        regions[i] = {
	          start: start,
	          end: end,
	          style: style
	        };
	      }
	    } // Set scales


	    var xValue = isRotated ? function (dt) {
	      return y(dt.value);
	    } : function (dt) {
	      return x(dt.x);
	    },
	        yValue = isRotated ? function (dt) {
	      return x(dt.x);
	    } : function (dt) {
	      return y(dt.value);
	    },
	        generateM = function (points) {
	      return "M".concat(points[0][0], ",").concat(points[0][1], "L").concat(points[1][0], ",").concat(points[1][1]);
	    },
	        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
	      var x0 = d0.x.getTime(),
	          xDiff = d1.x - d0.x,
	          xv0 = new Date(x0 + xDiff * k),
	          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
	          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
	      return generateM(points);
	    } : function (d0, d1, k, otherDiff) {
	      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
	      return generateM(points);
	    },
	        path = "";

	    for (var data, _i = 0; data = d[_i]; _i++) {
	      var prevData = d[_i - 1],
	          hasPrevData = prevData && isValue(prevData.value),
	          style = isWithinRegions(data.x, regions);
	      // https://github.com/naver/billboard.js/issues/1172
	      if (isValue(data.value)) // Draw as normal
	        if (isUndefined(regions) || !style || !hasPrevData) path += "".concat(_i && hasPrevData ? "L" : "M").concat(xValue(data), ",").concat(yValue(data));else if (hasPrevData) {
	          try {
	            style = style.dasharray.split(" ");
	          } catch (e) {
	            style = dasharray.split(" ");
	          } // Draw with region // TODO: Fix for horizotal charts


	          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
	          var dx = x(data.x) - x(prevData.x),
	              dy = y(data.value) - y(prevData.value),
	              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
	          diff = style[0] / dd, diffx2 = diff * style[1];

	          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
	        }
	    }

	    return path;
	  },
	  updateAreaGradient: function updateAreaGradient() {
	    var $$ = this;
	    $$.data.targets.forEach(function (d) {
	      var id = "".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id));

	      if ($$.isAreaType(d) && $$.defs.select("#".concat(id)).empty()) {
	        var color = $$.color(d),
	            _$$$config$area_linea = $$.config.area_linearGradient,
	            _$$$config$area_linea2 = _$$$config$area_linea.x,
	            x = _$$$config$area_linea2 === void 0 ? [0, 0] : _$$$config$area_linea2,
	            _$$$config$area_linea3 = _$$$config$area_linea.y,
	            y = _$$$config$area_linea3 === void 0 ? [0, 1] : _$$$config$area_linea3,
	            _$$$config$area_linea4 = _$$$config$area_linea.stops,
	            stops = _$$$config$area_linea4 === void 0 ? [[0, color, 1], [1, color, 0]] : _$$$config$area_linea4,
	            linearGradient = $$.defs.append("linearGradient").attr("id", "".concat(id)).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
	        stops.forEach(function (v) {
	          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
	          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
	        });
	      }
	    });
	  },
	  updateAreaColor: function updateAreaColor(d) {
	    var $$ = this;
	    return $$.config.area_linearGradient ? "url(#".concat($$.datetimeId, "-areaGradient").concat($$.getTargetSelectorSuffix(d.id), ")") : $$.color(d);
	  },
	  updateArea: function updateArea(durationForExit) {
	    var $$ = this;
	    $$.config.area_linearGradient && $$.updateAreaGradient(), $$.mainArea = $$.main.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.mainArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.mainArea = $$.mainArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
	      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
	    }).merge($$.mainArea), $$.mainArea.style("opacity", $$.orgAreaOpacity);
	  },
	  redrawArea: function redrawArea(drawArea, withTransition) {
	    var $$ = this;
	    return [(withTransition ? $$.mainArea.transition(getRandom()) : $$.mainArea).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
	      return ($$.isAreaRangeType(d) ? $$.orgAreaOpacity / 1.75 : $$.orgAreaOpacity) + "";
	    })];
	  },

	  /**
	   * Generate area path data
	   * @param areaIndices
	   * @param isSub
	   * @return {function(*=): (*|string)}
	   * @private
	   */
	  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
	    var $$ = this,
	        config = $$.config,
	        lineConnectNull = config.line_connectNull,
	        isRotated = config.axis_rotated,
	        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
	        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
	        xValue = function (d) {
	      return (isSub ? $$.subxx : $$.xx).call($$, d);
	    },
	        value0 = function (d, i) {
	      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : $$.getShapeYMin(d.id));
	    },
	        value1 = function (d, i) {
	      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
	    };

	    return function (d) {
	      var path,
	          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
	          x0 = 0,
	          y0 = 0;

	      if ($$.isAreaType(d)) {
	        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
	        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
	          return $$.getBaseValue(d) !== null;
	        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
	      } else values[0] && (x0 = $$.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M ".concat(y0, " ").concat(x0) : "M ".concat(x0, " ").concat(y0);

	      return path || "M 0 0";
	    };
	  },
	  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
	    // partial duplication of generateGetBarPoints
	    var $$ = this,
	        config = $$.config,
	        x = $$.getShapeX(0, areaIndices, !!isSub),
	        y = $$.getShapeY(!!isSub),
	        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
	        yScale = isSub ? $$.getSubYScale : $$.getYScale;
	    return function (d, i) {
	      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
	          offset = areaOffset(d, i) || y0,
	          posX = x(d),
	          posY = y(d);
	      // 1 point that marks the area position
	      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
	      [posX, offset] // needed for compatibility
	      ];
	    };
	  },
	  updateCircle: function updateCircle() {
	    var $$ = this;

	    if ($$.config.point_show) {
	      $$.mainCircle = $$.main.selectAll(".".concat(config_classes.circles)).selectAll(".".concat(config_classes.circle)).data(function (d) {
	        return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
	      }), $$.mainCircle.exit().remove();
	      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
	      $$.mainCircle = $$.mainCircle.enter().append(fn).merge($$.mainCircle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$));
	    }
	  },
	  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
	    var $$ = this,
	        selectedCircles = $$.main.selectAll(".".concat(config_classes.selectedCircle));
	    if (!$$.config.point_show) return [];
	    var mainCircles = [];
	    $$.mainCircle.each(function (d) {
	      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
	          result = fn(d);
	      mainCircles.push(result);
	    });
	    var posAttr = $$.isCirclePoint() ? "c" : "";
	    return [mainCircles, selectedCircles.attr("".concat(posAttr, "x"), cx).attr("".concat(posAttr, "y"), cy)];
	  },
	  circleX: function circleX(d) {
	    var $$ = this,
	        hasValue = isValue(d.x);
	    return $$.config.zoom_enabled && $$.zoomScale ? hasValue ? $$.zoomScale(d.x) : null : hasValue ? $$.x(d.x) : null;
	  },
	  updateCircleY: function updateCircleY() {
	    var $$ = this,
	        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

	    $$.circleY = function (d, i) {
	      var id = d.id;
	      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
	    };
	  },
	  getCircles: function getCircles(i, id) {
	    var $$ = this,
	        suffix = isValue(i) ? "-".concat(i) : "";
	    return (id ? $$.main.selectAll(".".concat(config_classes.circles).concat($$.getTargetSelectorSuffix(id))) : $$.main).selectAll(".".concat(config_classes.circle).concat(suffix));
	  },
	  expandCircles: function expandCircles(i, id, reset) {
	    var $$ = this,
	        r = $$.pointExpandedR.bind($$);
	    reset && $$.unexpandCircles();
	    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
	        scale = r(circles) / $$.config.point_r,
	        ratio = 1 - scale;
	    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
	      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
	      if (this.tagName === "circle") point.attr("r", r);else {
	        var _this$getBBox = this.getBBox(),
	            width = _this$getBBox.width,
	            height = _this$getBBox.height,
	            x = ratio * (+point.attr("x") + width / 2),
	            y = ratio * (+point.attr("y") + height / 2);

	        point.attr("transform", "translate(".concat(x, " ").concat(y, ") scale(").concat(scale, ")"));
	      }
	    });
	  },
	  unexpandCircles: function unexpandCircles(i) {
	    var $$ = this,
	        r = $$.pointR.bind($$),
	        circles = $$.getCircles(i).filter(function () {
	      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
	    }).classed(config_classes.EXPANDED, !1);
	    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(".concat(r(circles) / $$.config.point_r, ")"));
	  },
	  pointR: function (d) {
	    var $$ = this,
	        config = $$.config,
	        pointR = config.point_r,
	        r = pointR;
	    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
	  },
	  pointExpandedR: function pointExpandedR(d) {
	    var $$ = this,
	        config = $$.config,
	        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
	    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
	  },
	  pointSelectR: function pointSelectR(d) {
	    var $$ = this,
	        selectR = $$.config.point_select_r;
	    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
	  },
	  isWithinCircle: function isWithinCircle(node, r) {
	    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
	        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
	        prefix = this.isCirclePoint() ? "c" : "",
	        cx = +element.attr("".concat(prefix, "x")),
	        cy = +element.attr("".concat(prefix, "y"));

	    // if node don't have cx/y or x/y attribute value
	    if (!(cx || cy) && node.nodeType === 1) {
	      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
	          x = _ref.x,
	          y = _ref.y;

	      cx = x, cy = y;
	    }

	    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
	  },
	  isWithinStep: function isWithinStep(that, y) {
	    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
	  },
	  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
	    var linePoint = this.config.line_point;
	    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
	  }
	});
	// CONCATENATED MODULE: ./src/shape/point.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  hasValidPointType: function hasValidPointType(type) {
	    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
	  },
	  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
	    var pointType = type || this.config.point_type;
	    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
	  },
	  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
	    var $$ = this,
	        copyAttr = function (from, target) {
	      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
	    },
	        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
	        node = doc.documentElement,
	        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

	    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
	      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
	      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
	        copyAttr(v, parent.append(v.tagName).node());
	      });
	    }

	    $$.defs.node().appendChild(clone);
	  },
	  pointFromDefs: function pointFromDefs(id) {
	    return this.defs.select("#".concat(id));
	  },
	  updatePointClass: function updatePointClass(d) {
	    var $$ = this,
	        pointClass = !1;
	    return (isObject(d) || $$.mainCircle) && (pointClass = d === !0 ? $$.mainCircle.each(function (d) {
	      var className = $$.classCircle.bind($$)(d);
	      this.getAttribute("class").indexOf(config_classes.EXPANDED) > -1 && (className += " ".concat(config_classes.EXPANDED)), this.setAttribute("class", className);
	    }) : $$.classCircle(d)), pointClass;
	  },
	  generatePoint: function generatePoint() {
	    var $$ = this,
	        config = $$.config,
	        ids = [],
	        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
	    return function (method, context) {
	      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

	      return function (d) {
	        var id = d.id || d.data && d.data.id || d,
	            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
	        ids.indexOf(id) < 0 && ids.push(id);
	        var point = pattern[ids.indexOf(id) % pattern.length];
	        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
	          var pointId = "".concat($$.datetimeId, "-point-").concat(id),
	              pointFromDefs = $$.pointFromDefs(pointId);
	          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
	          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
	        }
	        return point[method].bind(context).apply(void 0, [element].concat(args));
	      };
	    };
	  },
	  getTransitionName: function getTransitionName() {
	    return getRandom();
	  },
	  custom: {
	    create: function create(element, id, sizeFn, fillStyleFn) {
	      return element.append("use").attr("xlink:href", "#".concat(id)).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
	    },
	    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
	      var $$ = this,
	          _element$node$getBBox = element.node().getBBox(),
	          width = _element$node$getBBox.width,
	          height = _element$node$getBBox.height,
	          xPosFn2 = function (d) {
	        return xPosFn(d) - width / 2;
	      },
	          mainCircles = element;

	      if (withTransition) {
	        var transitionName = $$.getTransitionName();
	        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
	      }

	      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
	        return yPosFn(d) - height / 2;
	      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
	    }
	  },
	  // 'circle' data point
	  circle: {
	    create: function create(element, sizeFn, fillStyleFn) {
	      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
	    },
	    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
	      var $$ = this,
	          mainCircles = element;

	      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
	        var transitionName = $$.getTransitionName();
	        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition($$.getTransitionName());
	      }

	      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
	    }
	  },
	  // 'rectangle' data point
	  rectangle: {
	    create: function create(element, sizeFn, fillStyleFn) {
	      var rectSizeFn = function (d) {
	        return sizeFn(d) * 2;
	      };

	      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
	    },
	    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
	      var $$ = this,
	          r = $$.config.point_r,
	          rectXPosFn = function (d) {
	        return xPosFn(d) - r;
	      },
	          mainCircles = element;

	      if (withTransition) {
	        var transitionName = $$.getTransitionName();
	        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
	      }

	      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
	        return yPosFn(d) - r;
	      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
	    }
	  }
	});
	// CONCATENATED MODULE: ./src/shape/radar.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	/**
	 * Get the position value
	 * @param {Boolean} isClockwise If the direction is clockwise
	 * @param {String} type Coordinate type 'x' or 'y'
	 * @param {Number} edge Number of edge
	 * @param {Number} pos The indexed position
	 * @param {Number} range
	 * @param {Number} ratio
	 * @return {number}
	 * @private
	 */

	function getPosition(isClockwise, type, edge, pos, range, ratio) {
	  var index = isClockwise && pos > 0 ? edge - pos : pos,
	      r = 2 * Math.PI,
	      func = type === "x" ? Math.sin : Math.cos;
	  return range * (1 - ratio * func(index * r / edge));
	} // cache key


	var radar_cacheKey = "$radarPoints";
	extend(ChartInternal_ChartInternal.prototype, {
	  initRadar: function initRadar() {
	    var $$ = this,
	        config = $$.config;
	    $$.hasType("radar") && ($$.radars = $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
	  },
	  getRadarSize: function getRadarSize() {
	    var $$ = this,
	        config = $$.config,
	        padding = config.axis_x_categories.length < 4 ? -20 : 10,
	        size = (Math.min($$.arcWidth, $$.arcHeight) - padding) / 2;
	    return [size, size];
	  },
	  updateTargetsForRadar: function updateTargetsForRadar(targets) {
	    var $$ = this,
	        config = $$.config;
	    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
	      return v.values.length;
	    })))), $$.generateRadarPoints();
	  },
	  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
	    var $$ = this,
	        config = $$.config,
	        _$$$getRadarSize = $$.getRadarSize(),
	        _$$$getRadarSize2 = _slicedToArray(_$$$getRadarSize, 2),
	        width = _$$$getRadarSize2[0],
	        height = _$$$getRadarSize2[1],
	        edge = config.axis_x_categories.length,
	        isClockwise = config.radar_direction_clockwise,
	        pos = toArray(type).map(function (v) {
	      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
	    });

	    return pos.length === 1 ? pos[0] : pos;
	  },

	  /**
	   * Generate data points
	   * @private
	   */
	  generateRadarPoints: function generateRadarPoints() {
	    var $$ = this,
	        targets = $$.data.targets,
	        _$$$getRadarSize3 = $$.getRadarSize(),
	        _$$$getRadarSize4 = _slicedToArray(_$$$getRadarSize3, 2),
	        width = _$$$getRadarSize4[0],
	        height = _$$$getRadarSize4[1],
	        points = $$.getCache(radar_cacheKey) || {},
	        size = points._size;

	    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
	      points[d.id] = d.values.map(function (v, i) {
	        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
	      });
	    }), points._size = {
	      width: width,
	      height: height
	    }, $$.addCache(radar_cacheKey, points));
	  },
	  redrawRadar: function redrawRadar(durationForExit) {
	    var $$ = this,
	        translate = $$.getTranslate("radar");
	    translate && ($$.radars.attr("transform", translate), $$.main.selectAll(".".concat(config_classes.circles)).attr("transform", translate), $$.main.select(".".concat(config_classes.chartTexts)).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(durationForExit));
	  },
	  generateGetRadarPoints: function generateGetRadarPoints() {
	    var $$ = this,
	        points = $$.getCache(radar_cacheKey);
	    return function (d, i) {
	      var point = points[d.id][i];
	      return [point, point, point, point];
	    };
	  },
	  updateRadarLevel: function updateRadarLevel() {
	    var $$ = this,
	        config = $$.config,
	        _$$$getRadarSize5 = $$.getRadarSize(),
	        _$$$getRadarSize6 = _slicedToArray(_$$$getRadarSize5, 2),
	        width = _$$$getRadarSize6[0],
	        height = _$$$getRadarSize6[1],
	        depth = config.radar_level_depth,
	        edge = config.axis_x_categories.length,
	        showText = config.radar_level_text_show,
	        radarLevels = $$.radars.levels,
	        levelData = getRange(0, depth),
	        radius = config.radar_size_ratio * Math.min(width, height),
	        levelRatio = levelData.map(function (l) {
	      return radius * ((l + 1) / depth);
	    }),
	        levelTextFormat = config.radar_level_text_format,
	        points = levelData.map(function (v) {
	      var range = levelRatio[v],
	          pos = getRange(0, edge).map(function (i) {
	        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
	      });
	      return pos.join(" ");
	    }),
	        level = radarLevels.selectAll(".".concat(config_classes.level)).data(levelData);

	    level.exit().remove();
	    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
	      return "".concat(config_classes.level, " ").concat(config_classes.level, "-").concat(i);
	    });
	    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
	      return levelTextFormat(0);
	    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
	      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
	    })), levelEnter.merge(level).attr("transform", function (d) {
	      return "translate(".concat(width - levelRatio[d], ", ").concat(height - levelRatio[d], ")");
	    }).selectAll("polygon").attr("points", function (d) {
	      return points[d];
	    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
	      return isUndefined(d) ? width : points[d].split(",")[0];
	    }).attr("y", function (d) {
	      return isUndefined(d) ? height : 0;
	    });
	  },
	  updateRadarAxes: function updateRadarAxes() {
	    var $$ = this,
	        config = $$.config,
	        _$$$getRadarSize7 = $$.getRadarSize(),
	        _$$$getRadarSize8 = _slicedToArray(_$$$getRadarSize7, 2),
	        width = _$$$getRadarSize8[0],
	        height = _$$$getRadarSize8[1],
	        categories = config.axis_x_categories,
	        axis = $$.radars.axes.selectAll("g").data(categories);

	    axis.exit().remove();
	    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
	      return "".concat(config_classes.axis, "-").concat(i);
	    });

	    // axis text
	    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
	      return $$.getRadarPosition("x", i);
	    }).attr("y2", function (d, i) {
	      return $$.getRadarPosition("y", i);
	    }), config.radar_axis_text_show) {
	      var _config$radar_axis_te = config.radar_axis_text_position,
	          _config$radar_axis_te2 = _config$radar_axis_te.x,
	          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
	          _config$radar_axis_te3 = _config$radar_axis_te.y,
	          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
	      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
	        selection.each(function (d) {
	          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
	        });
	      }).datum(function (d, i) {
	        return {
	          index: i
	        };
	      }).attr("transform", function (d) {
	        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
	        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
	            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
	        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(".concat(posX, " ").concat(posY, ")");
	      });
	    }

	    $$.bindEvent();
	  },
	  bindEvent: function bindEvent() {
	    var _this = this,
	        $$ = this,
	        config = $$.config;

	    if (config.interaction_enabled) {
	      var isMouse = $$.inputType === "mouse",
	          getIndex = function () {
	        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

	        /tspan/i.test(target.tagName) && (target = target.parentNode);
	        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
	        return d && Object.keys(d).length === 1 ? d.index : undefined;
	      },
	          hide = function () {
	        var index = getIndex(),
	            noIndex = isUndefined(index);
	        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
	      };

	      $$.radars.select(".".concat(config_classes.axis)).on(isMouse ? "mouseover " : "touchstart", function () {
	        if (!$$.transiting) // skip while transiting
	          {
	            var index = getIndex();
	            $$.selectRectForSingle($$.svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
	          }
	      }).on("mouseout", isMouse ? hide : null), isMouse || $$.svg.on("touchstart", hide);
	    }
	  },
	  updateRadarShape: function updateRadarShape(durationForExit) {
	    var $$ = this,
	        targets = $$.data.targets,
	        points = $$.getCache(radar_cacheKey),
	        areas = $$.radars.shapes.selectAll("polygon").data(targets),
	        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
	    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", $$.color).style("stroke", $$.color).attr("points", function (d) {
	      return points[d.id].join(" ");
	    });
	  },

	  /**
	   * Get data point x coordinate
	   * @param {Object} d Data object
	   * @return {Number}
	   * @private
	   */
	  radarCircleX: function radarCircleX(d) {
	    return this.getCache(radar_cacheKey)[d.id][d.index][0];
	  },

	  /**
	   * Get data point y coordinate
	   * @param {Object} d Data object
	   * @return {Number}
	   * @private
	   */
	  radarCircleY: function radarCircleY(d) {
	    return this.getCache(radar_cacheKey)[d.id][d.index][1];
	  }
	});
	// CONCATENATED MODULE: ./src/internals/text.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initializes the text
	   * @private
	   */
	  initText: function initText() {
	    var $$ = this;
	    $$.main.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartTexts), $$.mainText = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
	  },

	  /**
	   * Update chartText
	   * @private
	   * @param {Object} $$.data.targets
	   */
	  updateTargetsForText: function updateTargetsForText(targets) {
	    var $$ = this,
	        classChartText = $$.classChartText.bind($$),
	        classTexts = $$.classTexts.bind($$),
	        classFocus = $$.classFocus.bind($$),
	        mainTextUpdate = $$.main.select(".".concat(config_classes.chartTexts)).selectAll(".".concat(config_classes.chartText)).data(targets).attr("class", function (d) {
	      return classChartText(d) + classFocus(d);
	    }),
	        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
	    mainTextEnter.append("g").attr("class", classTexts);
	  },

	  /**
	   * Update text
	   * @private
	   * @param {Number} Fade-out transition duration
	   */
	  updateText: function updateText(durationForExit) {
	    var _this = this,
	        $$ = this,
	        config = $$.config,
	        dataFn = $$.labelishData.bind($$),
	        classText = $$.classText.bind($$);

	    $$.mainText = $$.main.selectAll(".".concat(config_classes.texts)).selectAll(".".concat(config_classes.text)).data(function (d) {
	      return _this.isRadarType(d) ? d.values : dataFn(d);
	    }), $$.mainText.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $$.mainText = $$.mainText.enter().append("text").merge($$.mainText).attr("class", classText).attr("text-anchor", function (d) {
	      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
	    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
	      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
	      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
	    });
	  },
	  updateTextColor: function updateTextColor(d) {
	    var color,
	        $$ = this,
	        labelColors = $$.config.data_labels_colors;
	    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
	  },

	  /**
	   * Redraw chartText
	   * @param {Function} x Positioning function for x
	   * @param {Function} y Positioning function for y
	   * @param {Boolean} forFlow
	   * @param {Boolean} withTransition transition is enabled
	   * @private
	   */
	  redrawText: function redrawText(x, y, forFlow, withTransition) {
	    var $$ = this,
	        t = getRandom(),
	        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
	    // need to return 'true' as of being pushed to the redraw list
	    // ref: getRedrawList()
	    return $$.mainText.each(function (d, i) {
	      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

	      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x.bind(this)(d, i)).attr("y", y.bind(this)(d, i)).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
	    }), !0;
	  },

	  /**
	   * Gets the getBoundingClientRect value of the element
	   * @private
	   * @param {HTMLElement|d3.selection} element
	   * @param {String} className
	   * @returns {Object} value of element.getBoundingClientRect()
	   */
	  getTextRect: function getTextRect(element, className) {
	    var $$ = this,
	        base = element.node ? element.node() : element;
	    /text/i.test(base.tagName) || (base = base.querySelector("text"));
	    var text = base.textContent,
	        cacheKey = "$".concat(text.replace(/\W/g, "_")),
	        rect = $$.getCache(cacheKey);
	    return rect || ($$.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
	      rect = getBoundingRect(v.node());
	    }).remove(), $$.addCache(cacheKey, rect)), rect;
	  },

	  /**
	   * Gets the x or y coordinate of the text
	   * @param {Object} indices Indices values
	   * @param {Boolean} forX whether or not to x
	   * @returns {Number} coordinates
	   * @private
	   */
	  generateXYForText: function generateXYForText(indices, forX) {
	    var $$ = this,
	        types = Object.keys(indices),
	        points = {},
	        getter = forX ? $$.getXForText : $$.getYForText;
	    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
	      points[v] = $$["generateGet".concat(capitalize(v), "Points")](indices[v], !1);
	    }), function (d, i) {
	      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
	      return getter.call($$, points[type](d, i), d, this);
	    };
	  },

	  /**
	   * Get centerized text position for bar type data.label.text
	   * @private
	   * @param {Object} d Data object
	   * @param {Array} points Data points position
	   * @param {HTMLElement} textElement Data label text element
	   * @returns {Number} Position value
	   */
	  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated;

	    if (config.data_labels.centered && $$.isBarType(d)) {
	      var rect = getBoundingRect(textElement),
	          isPositive = d.value >= 0;

	      if (isRotated) {
	        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
	        return isPositive ? -w - 3 : w + 2;
	      }

	      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
	      return isPositive ? h : -h - 2;
	    }

	    return 0;
	  },

	  /**
	   * Get data.labels.position value
	   * @param {String} id Data id value
	   * @param {String} type x | y
	   * @return {Number} Position value
	   * @private
	   */
	  getTextPos: function getTextPos(id, type) {
	    var pos = this.config.data_labels_position;
	    return (id in pos ? pos[id] : pos)[type] || 0;
	  },

	  /**
	   * Gets the x coordinate of the text
	   * @private
	   * @param {Object} points
	   * @param {Object} data
	   * @param {HTMLElement} element
	   * @returns {Number} x coordinate
	   */
	  getXForText: function getXForText(points, d, textElement) {
	    var xPos,
	        padding,
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated;
	    // show labels regardless of the domain if value is null
	    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > $$.width) {
	      var _getBoundingRect = getBoundingRect(textElement),
	          width = _getBoundingRect.width;

	      xPos = $$.width - width;
	    } else xPos < 0 && (xPos = 4);
	    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
	  },

	  /**
	   * Gets the y coordinate of the text
	   * @private
	   * @param {Object} points
	   * @param {Object} data
	   * @param {HTMLElement} element
	   * @returns {Number} y coordinate
	   */
	  getYForText: function getYForText(points, d, textElement) {
	    var yPos,
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        r = config.point_r,
	        rect = getBoundingRect(textElement),
	        baseY = 3;
	    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !$$.hasPositiveValue && $$.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
	      var diff = -baseY * 2;
	      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
	    } // show labels regardless of the domain if value is null

	    if (d.value === null && !isRotated) {
	      var boxHeight = rect.height;
	      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
	    }

	    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
	  },

	  /**
	   * Calculate if two or more text nodes are overlapping
	   * Mark overlapping text nodes with "text-overlapping" class
	   * @private
	   * @param {number} id
	   * @param {ChartInternal} $$
	   * @param {string} selector
	   */
	  markOverlapped: function markOverlapped(id, $$, selector) {
	    var textNodes = $$.arcs.selectAll(selector),
	        filteredTextNodes = textNodes.filter(function (node) {
	      return node.data.id !== id;
	    }),
	        textNode = textNodes.filter(function (node) {
	      return node.data.id === id;
	    }),
	        translate = getTranslation(textNode.node()),
	        calcHypo = function (x, y) {
	      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
	    };

	    textNode.node() && filteredTextNodes.each(function () {
	      var coordinate = getTranslation(this),
	          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
	          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
	          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 10);
	      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
	    });
	  },

	  /**
	   * Calculate if two or more text nodes are overlapping
	   * Remove "text-overlapping" class on selected text nodes
	   * @private
	   * @param {ChartInternal} $$
	   * @param {string} selector
	   */
	  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
	    $$.arcs.selectAll(selector).each(function () {
	      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
	    });
	  }
	});
	// CONCATENATED MODULE: ./src/internals/type.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */

	 // defined chart types as category

	var TYPES = {
	  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
	  AreaRange: ["area-spline-range", "area-line-range"],
	  Arc: ["pie", "donut", "gauge", "radar"],
	  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
	  Step: ["step", "area-step"],
	  Spline: ["spline", "area-spline", "area-spline-range"]
	};
	extend(ChartInternal_ChartInternal.prototype, {
	  setTargetType: function setTargetType(targetIds, type) {
	    var $$ = this,
	        config = $$.config;
	    $$.mapToTargetIds(targetIds).forEach(function (id) {
	      $$.withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
	    }), targetIds || (config.data_type = type);
	  },
	  hasType: function hasType(type, targetsValue) {
	    var $$ = this,
	        types = $$.config.data_types,
	        targets = targetsValue || $$.data.targets,
	        has = !1;
	    return targets && targets.length ? targets.forEach(function (target) {
	      var t = types[target.id];
	      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
	    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
	      types[id] === type && (has = !0);
	    }) : has = $$.config.data_type === type, has;
	  },

	  /**
	   * Check if contains given chart types
	   * @param {String} type Type key
	   * @param {Object} targets
	   * @param {Array} exclude Excluded types
	   * @return {boolean}
	   * @private
	   */
	  hasTypeOf: function hasTypeOf(type, targets) {
	    var _this = this,
	        exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	    return !TYPES[type].filter(function (v) {
	      return exclude.indexOf(v) === -1;
	    }).every(function (v) {
	      return !_this.hasType(v, targets);
	    });
	  },

	  /**
	   * Check if given data is certain chart type
	   * @param {Object} d Data object
	   * @param {String} type chart type
	   * @return {Boolean}
	   * @private
	   */
	  isTypeOf: function isTypeOf(d, type) {
	    var id = isString(d) ? d : d.id,
	        dataType = this.config.data_types[id];
	    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
	  },

	  /**
	   * Check if contains arc types chart
	   * @param {Object} targets
	   * @param {Array} exclude Excluded types
	   * @return {boolean}
	   * @private
	   */
	  hasArcType: function hasArcType(targets, exclude) {
	    return this.hasTypeOf("Arc", targets, exclude);
	  },
	  hasMultiArcGauge: function hasMultiArcGauge() {
	    return this.hasType("gauge") && this.config.gauge_type === "multi";
	  },
	  isLineType: function isLineType(d) {
	    var id = isString(d) ? d : d.id;
	    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
	  },
	  isStepType: function isStepType(d) {
	    return this.isTypeOf(d, TYPES.Step);
	  },
	  isSplineType: function isSplineType(d) {
	    return this.isTypeOf(d, TYPES.Spline);
	  },
	  isAreaType: function isAreaType(d) {
	    return this.isTypeOf(d, TYPES.Area);
	  },
	  isAreaRangeType: function isAreaRangeType(d) {
	    return this.isTypeOf(d, TYPES.AreaRange);
	  },
	  isBarType: function isBarType(d) {
	    return this.isTypeOf(d, "bar");
	  },
	  isBubbleType: function isBubbleType(d) {
	    return this.isTypeOf(d, "bubble");
	  },
	  isScatterType: function isScatterType(d) {
	    return this.isTypeOf(d, "scatter");
	  },
	  isPieType: function isPieType(d) {
	    return this.isTypeOf(d, "pie");
	  },
	  isGaugeType: function isGaugeType(d) {
	    return this.isTypeOf(d, "gauge");
	  },
	  isDonutType: function isDonutType(d) {
	    return this.isTypeOf(d, "donut");
	  },
	  isRadarType: function isRadarType(d) {
	    return this.isTypeOf(d, "radar");
	  },
	  isArcType: function isArcType(d) {
	    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
	  },
	  // determine if is 'circle' data point
	  isCirclePoint: function isCirclePoint() {
	    var config = this.config,
	        pattern = config.point_pattern;
	    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
	  },
	  lineData: function lineData(d) {
	    return this.isLineType(d) ? [d] : [];
	  },
	  arcData: function arcData(d) {
	    return this.isArcType(d.data) ? [d] : [];
	  },
	  barData: function barData(d) {
	    return this.isBarType(d) ? d.values : [];
	  },

	  /**
	   * Get data adapt for data label showing
	   * @param {Object} d Data object
	   * @return {Array}
	   * @private
	   */
	  labelishData: function labelishData(d) {
	    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
	  },
	  barLineBubbleData: function barLineBubbleData(d) {
	    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
	  },
	  // https://github.com/d3/d3-shape#curves
	  isInterpolationType: function isInterpolationType(type) {
	    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
	  }
	});
	// CONCATENATED MODULE: ./src/internals/grid.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	 // Grid position and text anchor helpers

	var getGridTextAnchor = function (d) {
	  return isValue(d.position) || "end";
	},
	    getGridTextDx = function (d) {
	  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
	},
	    getGridTextX = function (isX, width, height) {
	  return function (d) {
	    var x = isX ? 0 : width;
	    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
	  };
	};

	extend(ChartInternal_ChartInternal.prototype, {
	  initGrid: function initGrid() {
	    var $$ = this;
	    $$.xgrid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]), $$.initGridLines(), $$.initFocusGrid();
	  },
	  initGridLines: function initGridLines() {
	    var $$ = this,
	        config = $$.config;
	    (config.grid_x_lines.length || config.grid_y_lines.length) && ($$.gridLines = $$.main.insert("g", ".".concat(config_classes.chart).concat(config.grid_lines_front ? " + *" : "")).attr("clip-path", $$.clipPathForGrid).attr("class", "".concat(config_classes.grid, " ").concat(config_classes.gridLines)), $$.gridLines.append("g").attr("class", config_classes.xgridLines), $$.gridLines.append("g").attr("class", config_classes.ygridLines), $$.xgridLines = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
	  },
	  updateXGrid: function updateXGrid(withoutUpdate) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        xgridData = $$.generateGridData(config.grid_x_type, $$.x),
	        tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0,
	        pos = function (d) {
	      return ($$.zoomScale || $$.x)(d) + tickOffset * (isRotated ? -1 : 1);
	    };

	    $$.xgridAttr = isRotated ? {
	      "x1": 0,
	      "x2": $$.width,
	      "y1": pos,
	      "y2": pos
	    } : {
	      "x1": pos,
	      "x2": pos,
	      "y1": 0,
	      "y2": $$.height
	    }, $$.xgrid = $$.main.select(".".concat(config_classes.xgrids)).selectAll(".".concat(config_classes.xgrid)).data(xgridData), $$.xgrid.exit().remove(), $$.xgrid = $$.xgrid.enter().append("line").attr("class", config_classes.xgrid).merge($$.xgrid), withoutUpdate || $$.xgrid.each(function () {
	      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
	      Object.keys($$.xgridAttr).forEach(function (id) {
	        grid.attr(id, $$.xgridAttr[id]).style("opacity", function () {
	          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? $$.height : 0) ? "0" : "1";
	        });
	      });
	    });
	  },
	  updateYGrid: function updateYGrid() {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks),
	        pos = function (d) {
	      return Math.ceil($$.y(d));
	    };

	    $$.ygrid = $$.main.select(".".concat(config_classes.ygrids)).selectAll(".".concat(config_classes.ygrid)).data(gridValues), $$.ygrid.exit().remove(), $$.ygrid = $$.ygrid.enter().append("line").attr("class", config_classes.ygrid).merge($$.ygrid), $$.ygrid.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : $$.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? $$.height : pos), $$.smoothLines($$.ygrid, "grid");
	  },
	  updateGrid: function updateGrid(duration) {
	    var $$ = this;
	    // hide if arc type
	    $$.gridLines || $$.initGridLines(), $$.grid.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
	  },

	  /**
	   * Update X Grid lines
	   * @param {Number} duration
	   * @private
	   */
	  updateXGridLines: function updateXGridLines(duration) {
	    var $$ = this,
	        main = $$.main,
	        config = $$.config,
	        isRotated = config.axis_rotated;
	    config.grid_x_show && $$.updateXGrid(), $$.xgridLines = main.select(".".concat(config_classes.xgridLines)).selectAll(".".concat(config_classes.xgridLine)).data(config.grid_x_lines), $$.xgridLines.exit().transition().duration(duration).style("opacity", "0").remove();
	    // enter
	    var xgridLine = $$.xgridLines.enter().append("g");
	    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), $$.xgridLines = xgridLine.merge($$.xgridLines), $$.xgridLines.attr("class", function (d) {
	      return "".concat(config_classes.xgridLine, " ").concat(d["class"] || "").trim();
	    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
	      return d.text;
	    }).transition().style("opacity", "1");
	  },

	  /**
	   * Update Y Grid lines
	   * @param {Number} duration
	   * @private
	   */
	  updateYGridLines: function updateYGridLines(duration) {
	    var $$ = this,
	        main = $$.main,
	        config = $$.config,
	        isRotated = config.axis_rotated;
	    config.grid_y_show && $$.updateYGrid(), $$.ygridLines = main.select(".".concat(config_classes.ygridLines)).selectAll(".".concat(config_classes.ygridLine)).data(config.grid_y_lines), $$.ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
	    // enter
	    var ygridLine = $$.ygridLines.enter().append("g");
	    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), $$.ygridLines = ygridLine.merge($$.ygridLines);
	    // update
	    var yv = $$.yv.bind($$);
	    $$.ygridLines.attr("class", function (d) {
	      return "".concat(config_classes.ygridLine, " ").concat(d["class"] || "").trim();
	    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : $$.width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? $$.height : yv).transition().style("opacity", "1"), $$.ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, $$.width, $$.height)).attr("y", yv).text(function (d) {
	      return d.text;
	    }).transition().style("opacity", "1");
	  },
	  redrawGrid: function redrawGrid(withTransition) {
	    var $$ = this,
	        isRotated = $$.config.axis_rotated,
	        xv = $$.xv.bind($$),
	        lines = $$.xgridLines.select("line"),
	        texts = $$.xgridLines.select("text");
	    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : $$.height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, $$.width, $$.height)).attr("y", xv).text(function (d) {
	      return d.text;
	    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
	  },
	  initFocusGrid: function initFocusGrid() {
	    var $$ = this,
	        config = $$.config,
	        isFront = config.grid_front,
	        className = ".".concat(config_classes[isFront && $$.gridLines ? "gridLines" : "chart"]).concat(isFront ? " + *" : "");
	    $$.grid = $$.main.insert("g", className).attr("clip-path", $$.clipPathForGrid).attr("class", config_classes.grid), config.grid_x_show && $$.grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && $$.grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && ($$.grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && $$.grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
	  },

	  /**
	   * Show grid focus line
	   * @param {Array} selectedData
	   * @private
	   */
	  showGridFocus: function showGridFocus(selectedData) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        dataToShow = selectedData.filter(function (d) {
	      return d && isValue($$.getBaseValue(d));
	    });

	    // Hide when bubble/scatter/stanford plot exists
	    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
	      var focusEl = $$.main.selectAll("line.".concat(config_classes.xgridFocus, ", line.").concat(config_classes.ygridFocus)),
	          isEdge = config.grid_focus_edge && !config.tooltip_grouped,
	          xx = $$.xx.bind($$);
	      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
	        var xy,
	            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	            pos = {
	          x: xx(d),
	          y: $$.getYScale(d.id)(d.value)
	        };
	        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
	        pos.x, // y1
	        isEdge ? pos.y : $$.width, // x2
	        pos.x // y2
	        ] : [pos.x, isEdge ? pos.y : null, pos.x, $$.height];else {
	          var isY2 = $$.axis.getId(d.id) === "y2";
	          xy = isRotated ? [pos.y, // x1
	          isEdge && !isY2 ? pos.x : null, // y1
	          pos.y, // x2
	          isEdge && isY2 ? pos.x : $$.height // y2
	          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : $$.width, pos.y];
	        }
	        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
	          return el.attr(v, xy[i]);
	        });
	      }), $$.smoothLines(focusEl, "grid");
	    }
	  },
	  hideGridFocus: function hideGridFocus() {
	    var $$ = this;
	    $$.inputType === "mouse" && $$.main.selectAll("line.".concat(config_classes.xgridFocus, ", line.").concat(config_classes.ygridFocus)).style("visibility", "hidden");
	  },
	  updateGridFocus: function updateGridFocus() {
	    var $$ = this,
	        xgridFocus = $$.grid.select("line.".concat(config_classes.xgridFocus));

	    if (!($$.inputType === "touch")) {
	      var _isRotated = $$.config.axis_rotated;
	      xgridFocus.attr("x1", _isRotated ? 0 : -10).attr("x2", _isRotated ? $$.width : -10).attr("y1", _isRotated ? -10 : 0).attr("y2", _isRotated ? -10 : $$.height);
	    } else if (!xgridFocus.empty()) {
	      var d = xgridFocus.datum();
	      d && $$.showGridFocus([d]);
	    } // need to return 'true' as of being pushed to the redraw list
	    // ref: getRedrawList()


	    return !0;
	  },
	  generateGridData: function generateGridData(type, scale) {
	    var $$ = this,
	        tickNum = $$.main.select(".".concat(config_classes.axisX)).selectAll(".tick").size(),
	        gridData = [];

	    if (type === "year") {
	      var xDomain = $$.getXDomain(),
	          firstYear = xDomain[0].getFullYear(),
	          lastYear = xDomain[1].getFullYear();

	      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date("".concat(i, "-01-01 00:00:00")));
	    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
	      return (d + "").indexOf(".") < 0;
	    }));

	    return gridData;
	  },
	  getGridFilterToRemove: function getGridFilterToRemove(params) {
	    return params ? function (line) {
	      var found = !1;
	      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
	        ("value" in param && line.value === param.value || "class" in param && line["class"] === param["class"]) && (found = !0);
	      }), found;
	    } : function () {
	      return !0;
	    };
	  },
	  removeGridLines: function removeGridLines(params, forX) {
	    var $$ = this,
	        config = $$.config,
	        toRemove = $$.getGridFilterToRemove(params),
	        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
	        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
	    $$.main.select(".".concat(classLines)).selectAll(".".concat(classLine)).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
	    var gridLines = "grid_".concat(forX ? "x" : "y", "_lines");
	    config[gridLines] = config[gridLines].filter(function toShow(line) {
	      return !toRemove(line);
	    });
	  }
	});
	// CONCATENATED MODULE: ./src/internals/tooltip.js



	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initializes the tooltip
	   * @private
	   */
	  initTooltip: function initTooltip() {
	    var $$ = this,
	        config = $$.config,
	        bindto = config.tooltip_contents.bindto;

	    // Show tooltip if needed
	    if ($$.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $$.tooltip.empty() && ($$.tooltip = $$.selectChart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
	      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
	        var i,
	            val,
	            targets = $$.data.targets[0];

	        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

	        config.tooltip_init_x = i;
	      }

	      $$.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
	        return $$.addName(d.values[config.tooltip_init_x]);
	      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
	    }

	    $$.bindTooltipResizePos();
	  },

	  /**
	   * Get the tooltip HTML string
	   * @param  {...any} args
	   * @private
	   * @return {String} Formatted HTML string
	   */
	  getTooltipHTML: function getTooltipHTML() {
	    for (var _config$tooltip_conte, _$$, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

	    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$ = $$).getTooltipContent.apply(_$$, args);
	  },

	  /**
	   * Returns the tooltip content(HTML string)
	   * @param {Object} d data
	   * @param {Function} defaultTitleFormat Default title format
	   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
	   * @param {Function} color Color function
	   * @returns {String} html
	   * @private
	   */
	  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
	    var $$ = this,
	        config = $$.config,
	        titleFormat = config.tooltip_format_title || defaultTitleFormat,
	        nameFormat = config.tooltip_format_name || function (name) {
	      return name;
	    },
	        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
	      return "".concat((ratio * 100).toFixed(2), "%");
	    } : defaultValueFormat),
	        order = config.tooltip_order,
	        getRowValue = function (row) {
	      return $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
	    },
	        getBgColor = $$.levelColor ? function (row) {
	      return $$.levelColor(row.value);
	    } : function (row) {
	      return color(row);
	    },
	        contents = config.tooltip_contents,
	        tplStr = contents.template,
	        targetIds = $$.mapToTargetIds();

	    if (order === null && $$.isGrouped()) {
	      // for stacked data, order should aligned with the visually displayed data
	      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
	        return i2.id;
	      }).reverse();
	      d.sort(function (a, b) {
	        var v1 = a ? a.value : null,
	            v2 = b ? b.value : null;
	        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
	      });
	    } else if (/^(asc|desc)$/.test(order)) {
	      d.sort(function (a, b) {
	        var v1 = a ? getRowValue(a) : null,
	            v2 = b ? getRowValue(b) : null;
	        return order === "asc" ? v1 - v2 : v2 - v1;
	      });
	    } else isFunction(order) && d.sort(order);

	    var text,
	        row,
	        param,
	        value,
	        i,
	        tpl = $$.getTooltipContentTemplate(tplStr),
	        len = d.length;

	    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
	      if (isUndefined(text)) {
	        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
	        text = tplProcess(tpl[0], {
	          CLASS_TOOLTIP: config_classes.tooltip,
	          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">".concat(title, "</th></tr>") : ""
	        });
	      }

	      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(_toConsumableArray(param)))), $$.isAreaRangeType(row)) {
	        var _map = ["high", "low"].map(function (v) {
	          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(_toConsumableArray(param))));
	        }),
	            _map2 = _slicedToArray(_map, 2),
	            high = _map2[0],
	            low = _map2[1];

	        value = "<b>Mid:</b> ".concat(value, " <b>High:</b> ").concat(high, " <b>Low:</b> ").concat(low);
	      }

	      if (value !== undefined) {
	        var _ret = function () {
	          // Skip elements when their name is set to null
	          if (row.name === null) return "continue";
	          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(_toConsumableArray(param)))),
	              color = getBgColor(row),
	              contentValue = {
	            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
	            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:".concat(color, "\" width=\"10\" height=\"10\"></rect></svg>"),
	            NAME: name,
	            VALUE: value
	          };

	          if (tplStr && isObject(contents.text)) {
	            var index = targetIds.indexOf(row.id);
	            Object.keys(contents.text).forEach(function (key) {
	              contentValue[key] = contents.text[key][index];
	            });
	          }

	          text += tplProcess(tpl[1], contentValue);
	        }();

	        if (_ret === "continue") continue;
	      }
	    }

	    return "".concat(text, "</table>");
	  },

	  /**
	   * Get the content template string
	   * @param {String} tplStr
	   * @return {String} Template string
	   * @private
	   */
	  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
	    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">".concat(this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>", "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>")).replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
	  },

	  /**
	   * Returns the position of the tooltip
	   * @param {Object} dataToShow data
	   * @param {String} tWidth Width value of tooltip element
	   * @param {String} tHeight Height value of tooltip element
	   * @param {HTMLElement} element
	   * @returns {Object} top, left value
	   * @private
	   */
	  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
	    var $$ = this,
	        config = $$.config,
	        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
	        svgLeft = $$.getSvgLeft(!0),
	        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
	        _d3Mouse2 = _slicedToArray(_d3Mouse, 2),
	        left = _d3Mouse2[0],
	        top = _d3Mouse2[1],
	        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight(!0),
	        chartLeft = $$.getCurrentPaddingLeft(!0),
	        size = 20;

	    // Determine tooltip position
	    if (top += size, $$.hasArcType()) {
	      var raw = $$.inputType === "touch" || $$.hasType("radar");
	      raw || (top += hasGauge ? $$.height : $$.height / 2, left += ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2);
	    } else {
	      var dataScale = $$.x(dataToShow[0].x);
	      config.axis_rotated ? (top = dataScale + size, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + chartLeft + size + ($$.zoomScale ? left : dataScale));
	    } // when tooltip left + tWidth > chart's width


	    left + tWidth + 15 > chartRight && (left -= tWidth + chartLeft), top + tHeight > $$.currentHeight && (top -= hasGauge ? tHeight * 3 : tHeight + 30);
	    var pos = {
	      top: top,
	      left: left
	    }; // make sure to not be positioned out of viewport

	    return Object.keys(pos).forEach(function (v) {
	      pos[v] < 0 && (pos[v] = 0);
	    }), pos;
	  },

	  /**
	   * Show the tooltip
	   * @private
	   * @param {Object} selectedData
	   * @param {HTMLElement} element
	   */
	  showTooltip: function showTooltip(selectedData, element) {
	    var $$ = this,
	        config = $$.config,
	        bindto = config.tooltip_contents.bindto,
	        forArc = $$.hasArcType(null, ["radar"]),
	        dataToShow = selectedData.filter(function (d) {
	      return d && isValue($$.getBaseValue(d));
	    });

	    if (dataToShow.length !== 0 && config.tooltip_show) {
	      var datum = $$.tooltip.datum(),
	          _ref = datum || {},
	          _ref$width = _ref.width,
	          width = _ref$width === void 0 ? 0 : _ref$width,
	          _ref$height = _ref.height,
	          height = _ref$height === void 0 ? 0 : _ref$height,
	          dataStr = JSON.stringify(selectedData);

	      if (!datum || datum.current !== dataStr) {
	        var index = selectedData.concat().sort()[0].index;
	        callFn(config.tooltip_onshow, $$, $$.api, selectedData), $$.tooltip.html($$.getTooltipHTML(selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
	        .datum(datum = {
	          index: index,
	          current: dataStr,
	          width: width = $$.tooltip.property("offsetWidth"),
	          height: height = $$.tooltip.property("offsetHeight")
	        }), callFn(config.tooltip_onshown, $$, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
	      }

	      if (!bindto) {
	        var fnPos = config.tooltip_position || $$.tooltipPosition,
	            pos = fnPos.call(this, dataToShow, width, height, element); // Get tooltip dimensions

	        ["top", "left"].forEach(function (v) {
	          var value = pos[v];
	          $$.tooltip.style(v, "".concat(value, "px")), v !== "left" || datum.xPosInPercent || (datum.xPosInPercent = value / $$.currentWidth * 100);
	        });
	      }
	    }
	  },

	  /**
	   * Adjust tooltip position on resize event
	   * @private
	   */
	  bindTooltipResizePos: function bindTooltipResizePos() {
	    var $$ = this,
	        resizeFunction = $$.resizeFunction,
	        tooltip = $$.tooltip;
	    resizeFunction.add(function () {
	      if (tooltip.style("display") === "block") {
	        var currentWidth = $$.currentWidth,
	            _tooltip$datum = tooltip.datum(),
	            width = _tooltip$datum.width,
	            xPosInPercent = _tooltip$datum.xPosInPercent,
	            _value = currentWidth / 100 * xPosInPercent,
	            diff = currentWidth - (_value + width);

	        diff < 0 && (_value += diff), tooltip.style("left", "".concat(_value, "px"));
	      }
	    });
	  },

	  /**
	   * Hide the tooltip
	   * @param {Boolean} force Force to hide
	   * @private
	   */
	  hideTooltip: function hideTooltip(force) {
	    var $$ = this,
	        api = $$.api,
	        config = $$.config,
	        tooltip = $$.tooltip;

	    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
	      var selectedData = JSON.parse(this.tooltip.datum().current);
	      // hide tooltip
	      callFn(config.tooltip_onhide, $$, api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
	      .datum(null), callFn(config.tooltip_onhidden, $$, api, selectedData);
	    }
	  },

	  /**
	   * Toggle display for linked chart instances
	   * @param {Boolean} show true: show, false: hide
	   * @param {Number} index x Axis index
	   * @private
	   */
	  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
	    var $$ = this;

	    if ($$.config.tooltip_linked) {
	      var linkedName = $$.config.tooltip_linked_name;
	      ($$.api.internal.charts || []).forEach(function (c) {
	        if (c !== $$.api) {
	          var _config = c.internal.config,
	              isLinked = _config.tooltip_linked,
	              name = _config.tooltip_linked_name,
	              isInDom = browser_doc.body.contains(c.element);

	          if (isLinked && linkedName === name && isInDom) {
	            var data = c.internal.tooltip.data()[0],
	                isNotSameIndex = index !== (data && data.index);

	            // prevent throwing error for non-paired linked indexes
	            try {
	              show && isNotSameIndex ? c.tooltip.show({
	                index: index
	              }) : !show && c.tooltip.hide();
	            } catch (e) {}
	          }
	        }
	      });
	    }
	  }
	});
	// CONCATENATED MODULE: ./src/internals/legend.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initialize the legend.
	   * @private
	   */
	  initLegend: function initLegend() {
	    var $$ = this,
	        config = $$.config;
	    $$.legendItemTextBox = {}, $$.legendHasRendered = !1, $$.legend = $$.svg.append("g"), config.legend_show ? ($$.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.legend.style("visibility", "hidden"), $$.hiddenLegendIds = $$.mapToIds($$.data.targets));
	  },

	  /**
	   * Update legend element
	   * @param {Array} targetIds ID's of target
	   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
	   * @param {Object} transitions Return value of the generateTransitions
	   * @private
	   */
	  updateLegend: function updateLegend(targetIds, options, transitions) {
	    var $$ = this,
	        config = $$.config,
	        optionz = options || {
	      withTransform: !1,
	      withTransitionForTransform: !1,
	      withTransition: !1
	    };
	    // toggle legend state
	    // Update size and scale
	    // Update g positions
	    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemHidden, function (id) {
	      return !$$.isTargetToShow(id);
	    }), $$.updateScales(!1, !$$.zoomScale), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), $$.legendHasRendered = !0;
	  },

	  /**
	   * Update legend using template option
	   * @private
	   */
	  updateLegendTemplate: function updateLegendTemplate() {
	    var $$ = this,
	        config = $$.config,
	        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
	        template = config.legend_contents_template;

	    if (!wrapper.empty()) {
	      var targets = $$.mapToIds($$.data.targets),
	          ids = [],
	          html = "";
	      targets.forEach(function (v) {
	        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
	          COLOR: $$.color(v),
	          TITLE: v
	        });
	        content && (ids.push(v), html += content);
	      });
	      var legendItem = wrapper.html(html).selectAll(function () {
	        return this.childNodes;
	      }).data(ids);
	      $$.setLegendItem(legendItem), $$.legend = wrapper;
	    }
	  },

	  /**
	   * Update the size of the legend.
	   * @private
	   * @param {Obejct} size S
	   */
	  updateSizeForLegend: function updateSizeForLegend(size) {
	    var $$ = this,
	        config = $$.config,
	        width = size.width,
	        height = size.height,
	        insetLegendPosition = {
	      top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
	      left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : $$.currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
	    };
	    $$.margin3 = {
	      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - height,
	      right: NaN,
	      bottom: 0,
	      left: $$.isLegendRight ? $$.currentWidth - width : $$.isLegendInset ? insetLegendPosition.left : 0
	    };
	  },

	  /**
	   * Transform Legend
	   * @private
	   * @param {Boolean} whether or not to transition.
	   */
	  transformLegend: function transformLegend(withTransition) {
	    var $$ = this;
	    (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate("legend"));
	  },

	  /**
	   * Update the legend step
	   * @private
	   * @param {Number} step
	   */
	  updateLegendStep: function updateLegendStep(step) {
	    this.legendStep = step;
	  },

	  /**
	   * Update legend item width
	   * @private
	   * @param {Number} width
	   */
	  updateLegendItemWidth: function updateLegendItemWidth(w) {
	    this.legendItemWidth = w;
	  },

	  /**
	   * Update legend item height
	   * @private
	   * @param {Number} height
	   */
	  updateLegendItemHeight: function updateLegendItemHeight(h) {
	    this.legendItemHeight = h;
	  },

	  /**
	   * Update legend item color
	   * @private
	   * @param {String} id Corresponding data ID value
	   * @param {String} color Color value
	   */
	  updateLegendItemColor: function updateLegendItemColor(id, color) {
	    this.legend.select(".".concat(config_classes.legendItem, "-").concat(id, " line")).style("stroke", color);
	  },

	  /**
	   * Get the width of the legend
	   * @private
	   * @return {Number} width
	   */
	  getLegendWidth: function getLegendWidth() {
	    var $$ = this;
	    return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
	  },

	  /**
	   * Get the height of the legend
	   * @return {Number} height
	   * @private
	   */
	  getLegendHeight: function getLegendHeight() {
	    var $$ = this;
	    return $$.config.legend_show ? $$.isLegendRight ? $$.currentHeight : Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1) : 0;
	  },

	  /**
	   * Get the opacity of the legend
	   * @private
	   * @param {Object} d3.Select
	   * @returns {Number} opacity
	   */
	  opacityForLegend: function opacityForLegend(legendItem) {
	    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
	  },

	  /**
	   * Get the opacity of the legend that is unfocused
	   * @private
	   * @param {Object} legendItem, d3.Select
	   * @returns {Number} opacity
	   */
	  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
	    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
	  },

	  /**
	   * Toggles the focus of the legend
	   * @private
	   * @param {Array} ID's of target
	   * @param {Boolean} whether or not to focus.
	   */
	  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
	    var $$ = this,
	        targetIdz = $$.mapToTargetIds(targetIds);
	    $$.legend.selectAll(".".concat(config_classes.legendItem)).filter(function (id) {
	      return targetIdz.indexOf(id) >= 0;
	    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
	      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
	    });
	  },

	  /**
	   * Revert the legend to its default state
	   * @private
	   */
	  revertLegend: function revertLegend() {
	    var $$ = this;
	    $$.legend.selectAll(".".concat(config_classes.legendItem)).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
	      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
	    });
	  },

	  /**
	   * Shows the legend
	   * @private
	   * @param {Array} ID's of target
	   */
	  showLegend: function showLegend(targetIds) {
	    var $$ = this,
	        config = $$.config;
	    config.legend_show || (config.legend_show = !0, $$.legend.style("visibility", "visible"), !$$.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
	      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
	    });
	  },

	  /**
	   * Hide the legend
	   * @private
	   * @param {Array} ID's of target
	   */
	  hideLegend: function hideLegend(targetIds) {
	    var $$ = this,
	        config = $$.config;
	    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, $$.legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), $$.legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
	  },

	  /**
	   * Clear the LegendItemTextBox cache.
	   * @private
	   */
	  clearLegendItemTextBoxCache: function clearLegendItemTextBoxCache() {
	    this.legendItemTextBox = {};
	  },

	  /**
	   * Set legend item style & bind events
	   * @private
	   * @param {d3.selection} item
	   */
	  setLegendItem: function setLegendItem(item) {
	    var $$ = this,
	        config = $$.config,
	        isTouch = $$.inputType === "touch",
	        hasGauge = $$.hasType("gauge");
	    item.attr("class", function (id) {
	      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	          itemClass = !node.empty() && node.attr("class") || "";
	      return itemClass + $$.generateClass(config_classes.legendItem, id);
	    }).style("visibility", function (id) {
	      return $$.isLegendToShow(id) ? "visible" : "hidden";
	    }).style("cursor", "pointer").on("click", function (id) {
	      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
	    }), isTouch || item.on("mouseout", function (id) {
	      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, ".".concat(config_classes.gaugeValue)), $$.api.revert());
	    }).on("mouseover", function (id) {
	      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, ".".concat(config_classes.gaugeValue)), !$$.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
	    });
	  },

	  /**
	   * Update the legend
	   * @param {Array} targetIds ID's of target
	   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
	  	 * @private
	   */
	  updateLegendElement: function updateLegendElement(targetIds, options) {
	    var xForLegend,
	        yForLegend,
	        background,
	        $$ = this,
	        config = $$.config,
	        posMin = 10,
	        tileWidth = config.legend_item_tile_width + 5,
	        maxWidth = 0,
	        maxHeight = 0,
	        totalLength = 0,
	        offsets = {},
	        widths = {},
	        heights = {},
	        margins = [0],
	        steps = {},
	        step = 0,
	        isLegendRightOrInset = $$.isLegendRight || $$.isLegendInset,
	        targetIdz = targetIds.filter(function (id) {
	      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
	    }),
	        withTransition = options.withTransition,
	        getTextBox = function (textElement, id) {
	      return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement, config_classes.legendItem)), $$.legendItemTextBox[id];
	    },
	        updatePositions = function (textElement, id, index) {
	      var margin,
	          isLast = index === targetIdz.length - 1,
	          box = getTextBox(textElement, id),
	          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
	          itemHeight = box.height + 4,
	          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
	          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
	          updateValues = function (id2, withoutStep) {
	        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = $$.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
	      };

	      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
	      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
	      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
	      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
	        return widths[id2] = maxWidth;
	      }), Object.keys(heights).forEach(function (id2) {
	        return heights[id2] = maxHeight;
	      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
	        return updateValues(id2);
	      })) : updateValues(id, !0)) : updateValues(id);
	    };

	    $$.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), $$.isLegendRight ? (xForLegend = function (id) {
	      return maxWidth * steps[id];
	    }, yForLegend = function (id) {
	      return margins[steps[id]] + offsets[id];
	    }) : $$.isLegendInset ? (xForLegend = function (id) {
	      return maxWidth * steps[id] + 10;
	    }, yForLegend = function (id) {
	      return margins[steps[id]] + offsets[id];
	    }) : (xForLegend = function (id) {
	      return margins[steps[id]] + offsets[id];
	    }, yForLegend = function (id) {
	      return maxHeight * steps[id];
	    });

	    var xForLegendText = function (id, i) {
	      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
	    },
	        xForLegendRect = function (id, i) {
	      return xForLegend(id, i);
	    },
	        x1ForLegendTile = function (id, i) {
	      return xForLegend(id, i) - 2;
	    },
	        x2ForLegendTile = function (id, i) {
	      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
	    },
	        yForLegendText = function (id, i) {
	      return yForLegend(id, i) + 9;
	    },
	        yForLegendRect = function (id, i) {
	      return yForLegend(id, i) - 5;
	    },
	        yForLegendTile = function (id, i) {
	      return yForLegend(id, i) + 4;
	    },
	        pos = -200,
	        l = $$.legend.selectAll(".".concat(config_classes.legendItem)).data(targetIdz).enter().append("g");

	    $$.setLegendItem(l), l.append("text").text(function (id) {
	      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
	    }).each(function (id, i) {
	      updatePositions(this, id, i);
	    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
	    var usePoint = $$.config.legend_usePoint;

	    if (usePoint) {
	      var ids = [];
	      l.append(function (d) {
	        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
	        ids.indexOf(d) === -1 && ids.push(d);
	        var point = pattern[ids.indexOf(d) % pattern.length];
	        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
	      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
	        return $$.color(d);
	      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
	        var node = selection[idx],
	            nodeName = node.nodeName.toLowerCase();
	        return nodeName === "use" ? "#".concat($$.datetimeId, "-point-").concat(data) : undefined;
	      });
	    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


	    background = $$.legend.select(".".concat(config_classes.legendBackground, " rect")), $$.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = $$.legend.insert("g", ".".concat(config_classes.legendItem)).attr("class", config_classes.legendBackground).append("rect"));
	    var texts = $$.legend.selectAll("text").data(targetIdz).text(function (id) {
	      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
	    }) // MEMO: needed for update
	    .each(function (id, i) {
	      updatePositions(this, id, i);
	    });
	    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
	    var rects = $$.legend.selectAll("rect.".concat(config_classes.legendItemEvent)).data(targetIdz);

	    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
	      return widths[id];
	    }).attr("height", function (id) {
	      return heights[id];
	    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
	      var tiles = $$.legend.selectAll(".".concat(config_classes.legendItemPoint)).data(targetIdz);
	      (withTransition ? tiles.transition() : tiles).each(function () {
	        var radius,
	            width,
	            height,
	            nodeName = this.nodeName.toLowerCase(),
	            pointR = $$.config.point_r,
	            x = "x",
	            y = "y",
	            xOffset = 2,
	            yOffset = 2.5;

	        if (nodeName === "circle") {
	          var size = pointR * .2;
	          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
	        } else if (nodeName === "rect") {
	          var _size = pointR * 2.5;

	          width = _size, height = _size, yOffset = 3;
	        }

	        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
	          return x1ForLegendTile(d) + xOffset;
	        }).attr(y, function (d) {
	          return yForLegendTile(d) - yOffset;
	        }).attr("r", radius).attr("width", width).attr("height", height);
	      });
	    } else {
	      var _tiles = $$.legend.selectAll("line.".concat(config_classes.legendItemTile)).data(targetIdz);

	      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
	        return $$.levelColor($$.cache[id].values[0].value);
	      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
	    }

	    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
	  }
	});
	// CONCATENATED MODULE: ./src/internals/title.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	/**
	 * Get the text position
	 * @param {String} pos right, left or center
	 * @param {Number} width chart width
	 * @return {String|Number} text-anchor value or position in pixel
	 * @private
	 */

	var getTextPos = function () {
	  var position,
	      pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "left",
	      width = arguments.length > 1 ? arguments[1] : undefined,
	      isNum = isNumber(width);
	  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
	};

	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initializes the title
	   * @private
	   */
	  initTitle: function initTitle() {
	    var $$ = this;

	    if ($$.config.title_text) {
	      $$.title = $$.svg.append("g");
	      var text = $$.title.append("text").style("text-anchor", getTextPos($$.config.title_position)).attr("class", config_classes.title);
	      setTextValue(text, $$.config.title_text, [.3, 1.5]);
	    }
	  },

	  /**
	   * Redraw title
	   * @private
	   */
	  redrawTitle: function redrawTitle() {
	    var $$ = this;

	    if ($$.title) {
	      var y = $$.yForTitle.call($$);
	      /g/i.test($$.title.node().tagName) ? $$.title.attr("transform", "translate(".concat(getTextPos($$.config.title_position, $$.currentWidth), ", ").concat(y, ")")) : $$.title.attr("x", $$.xForTitle.call($$)).attr("y", y);
	    }
	  },

	  /**
	   * Returns the x attribute value of the title
	   * @private
	   * @returns {Number} x attribute value
	   */
	  xForTitle: function xForTitle() {
	    var x,
	        $$ = this,
	        config = $$.config,
	        position = config.title_position || "left",
	        textRectWidth = $$.getTextRect($$.title, config_classes.title).width;
	    return /(right|center)/.test(position) ? (x = $$.currentWidth - textRectWidth, position.indexOf("right") >= 0 ? x = $$.currentWidth - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = ($$.currentWidth - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
	  },

	  /**
	   * Returns the y attribute value of the title
	   * @private
	   * @returns {Number} y attribute value
	   */
	  yForTitle: function yForTitle() {
	    var $$ = this;
	    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.title, config_classes.title).height;
	  },

	  /**
	   * Get title padding
	   * @private
	   * @returns {Number} padding value
	   */
	  getTitlePadding: function getTitlePadding() {
	    var $$ = this;
	    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
	  }
	});
	// CONCATENATED MODULE: ./src/internals/clip.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(ChartInternal_ChartInternal.prototype, {
	  initClip: function initClip() {
	    var $$ = this; // MEMO: clipId needs to be unique because it conflicts when multiple charts exist

	    // Define 'clip-path' attribute values
	    $$.clipId = "".concat($$.datetimeId, "-clip"), $$.clipIdForXAxis = "".concat($$.clipId, "-xaxis"), $$.clipIdForYAxis = "".concat($$.clipId, "-yaxis"), $$.clipIdForGrid = "".concat($$.clipId, "-grid"), $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis), $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
	  },
	  getClipPath: function getClipPath(id) {
	    var $$ = this,
	        config = $$.config;
	    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
	    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
	    return "url(".concat(isIE9 ? "" : browser_doc.URL.split("#")[0], "#").concat(id, ")");
	  },
	  appendClip: function appendClip(parent, id) {
	    return parent.append("clipPath").attr("id", id).append("rect");
	  },
	  getAxisClipX: function getAxisClipX(forHorizontal) {
	    // axis line width + padding for left
	    var left = Math.max(30, this.margin.left);
	    return forHorizontal ? -(1 + left) : -(left - 1);
	  },
	  getAxisClipY: function getAxisClipY(forHorizontal) {
	    return forHorizontal ? -20 : -this.margin.top;
	  },
	  getXAxisClipX: function getXAxisClipX() {
	    var $$ = this;
	    return $$.getAxisClipX(!$$.config.axis_rotated);
	  },
	  getXAxisClipY: function getXAxisClipY() {
	    var $$ = this;
	    return $$.getAxisClipY(!$$.config.axis_rotated);
	  },
	  getYAxisClipX: function getYAxisClipX() {
	    var $$ = this;
	    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
	  },
	  getYAxisClipY: function getYAxisClipY() {
	    var $$ = this;
	    return $$.getAxisClipY($$.config.axis_rotated);
	  },
	  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
	    var $$ = this,
	        left = Math.max(30, $$.margin.left),
	        right = Math.max(30, $$.margin.right);
	    // width + axis line width + padding for left/right
	    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
	  },
	  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
	    // less than 20 is not enough to show the axis label 'outer' without legend
	    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
	  },
	  getXAxisClipWidth: function getXAxisClipWidth() {
	    var $$ = this;
	    return $$.getAxisClipWidth(!$$.config.axis_rotated);
	  },
	  getXAxisClipHeight: function getXAxisClipHeight() {
	    var $$ = this;
	    return $$.getAxisClipHeight(!$$.config.axis_rotated);
	  },
	  getYAxisClipWidth: function getYAxisClipWidth() {
	    var $$ = this;
	    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
	  },
	  getYAxisClipHeight: function getYAxisClipHeight() {
	    var $$ = this;
	    return $$.getAxisClipHeight($$.config.axis_rotated);
	  },
	  updateXAxisTickClip: function updateXAxisTickClip() {
	    var $$ = this,
	        newXAxisHeight = $$.getHorizontalAxisHeight("x");

	    if ($$.defs && !$$.clipXAxisTickTexts) {
	      var clipId = "".concat($$.clipId, "-xaxisticktexts");
	      $$.clipXAxisTickTexts = $$.appendClip($$.defs, clipId), $$.clipPathForXAxisTickTexts = $$.getClipPath(clipId), $$.clipIdForXAxisTickTexts = clipId;
	    }

	    !$$.config.axis_x_tick_multiline && $$.getAxisTickRotate("x") && newXAxisHeight !== $$.xAxisHeight && ($$.setXAxisTickClipWidth(), $$.setXAxisTickTextClipPathWidth()), $$.xAxisHeight = newXAxisHeight;
	  },
	  setXAxisTickClipWidth: function setXAxisTickClipWidth() {
	    var $$ = this,
	        config = $$.config,
	        xAxisTickRotate = $$.getAxisTickRotate("x");

	    if (!config.axis_x_tick_multiline && xAxisTickRotate) {
	      var sinRotation = Math.sin(Math.PI / 180 * Math.abs(xAxisTickRotate));
	      $$.xAxisTickClipPathMaxWidth = ($$.getHorizontalAxisHeight("x") - 20) / sinRotation;
	    } else $$.xAxisTickClipPathMaxWidth = null;
	  },
	  setXAxisTickTextClipPathWidth: function setXAxisTickTextClipPathWidth() {
	    var $$ = this;
	    $$.svg && $$.svg.select("#".concat($$.clipIdForXAxisTickTexts, " rect")).attr("width", $$.xAxisTickClipPathMaxWidth).attr("height", 30);
	  }
	});
	// CONCATENATED MODULE: ./src/internals/region.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */
	 // selection




	extend(ChartInternal_ChartInternal.prototype, {
	  initRegion: function initRegion() {
	    var $$ = this;
	    $$.region = $$.main.append("g").attr("clip-path", $$.clipPath).attr("class", config_classes.regions);
	  },
	  updateRegion: function updateRegion(duration) {
	    var $$ = this,
	        config = $$.config;
	    // hide if arc type
	    // select <g> element
	    $$.region.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.mainRegion = $$.main.select(".".concat(config_classes.regions)).selectAll(".".concat(config_classes.region)).data(config.regions), $$.mainRegion.exit().transition().duration(duration).style("opacity", "0").remove(), $$.mainRegion = $$.mainRegion.enter().append("g").merge($$.mainRegion).attr("class", $$.classRegion.bind($$)), $$.mainRegion.append("rect").style("fill-opacity", "0");
	  },
	  redrawRegion: function redrawRegion(withTransition) {
	    var $$ = this,
	        regions = $$.mainRegion.select("rect");
	    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
	      return isValue(d.opacity) ? d.opacity : "0.1";
	    }).on("end", function () {
	      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
	    })];
	  },
	  getRegionXY: function getRegionXY(type, d) {
	    var scale,
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        isX = type === "x",
	        key = "start",
	        pos = 0;
	    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], pos = scale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, pos = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
	  },
	  regionX: function regionX(d) {
	    return this.getRegionXY("x", d);
	  },
	  regionY: function regionY(d) {
	    return this.getRegionXY("y", d);
	  },
	  getRegionSize: function getRegionSize(type, d) {
	    var scale,
	        $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        isWidth = type === "width",
	        start = $$[isWidth ? "regionX" : "regionY"](d),
	        key = "end",
	        end = $$[type];
	    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (scale = $$[d.axis], end = scale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (scale = $$.zoomScale || $$.x, end = scale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
	  },
	  regionWidth: function regionWidth(d) {
	    return this.getRegionSize("width", d);
	  },
	  regionHeight: function regionHeight(d) {
	    return this.getRegionSize("height", d);
	  },
	  isRegionOnX: function isRegionOnX(d) {
	    return !d.axis || d.axis === "x";
	  }
	});
	// CONCATENATED MODULE: ./src/interactions/drag.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Called when dragging.
	   * Data points can be selected.
	   * @private
	   * @param {Object} mouse Object
	   */
	  drag: function drag(mouse) {
	    var $$ = this,
	        config = $$.config,
	        main = $$.main;

	    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
	    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
	    ) {
	        var _$$$dragStart = _slicedToArray($$.dragStart, 2),
	            sx = _$$$dragStart[0],
	            sy = _$$$dragStart[1],
	            _mouse = _slicedToArray(mouse, 2),
	            mx = _mouse[0],
	            my = _mouse[1],
	            minX = Math.min(sx, mx),
	            maxX = Math.max(sx, mx),
	            minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my),
	            maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

	        main.select(".".concat(config_classes.dragarea)).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).filter(function (d) {
	          return config.data_selection_isselectable(d);
	        }).each(function (d, i) {
	          var toggle,
	              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	              isSelected = shape.classed(config_classes.SELECTED),
	              isIncluded = shape.classed(config_classes.INCLUDED),
	              isWithin = !1;

	          if (shape.classed(config_classes.circle)) {
	            var x = shape.attr("cx") * 1,
	                y = shape.attr("cy") * 1;
	            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
	          } else if (shape.classed(config_classes.bar)) {
	            var _getPathBox = getPathBox(this),
	                _x = _getPathBox.x,
	                y = _getPathBox.y,
	                width = _getPathBox.width,
	                height = _getPathBox.height;

	            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
	          } else // line/area selection not supported yet
	            return;

	          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
	        });
	      }
	  },

	  /**
	   * Called when the drag starts.
	   * Adds and Shows the drag area.
	   * @private
	   * @param {Object} mouse Object
	   */
	  dragstart: function dragstart(mouse) {
	    var $$ = this,
	        config = $$.config;
	    $$.hasArcType() || !config.data_selection_enabled || ($$.dragStart = mouse, $$.main.select(".".concat(config_classes.chart)).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
	  },

	  /**
	   * Called when the drag finishes.
	   * Removes the drag area.
	   * @private
	   */
	  dragend: function dragend() {
	    var $$ = this,
	        config = $$.config;
	    $$.hasArcType() || !config.data_selection_enabled || ($$.main.select(".".concat(config_classes.dragarea)).transition().duration(100).style("opacity", "0").remove(), $$.main.selectAll(".".concat(config_classes.shape)).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
	  },
	  setDragStatus: function setDragStatus(isDragging) {
	    this.dragging = isDragging;
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
	var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(12);

	// CONCATENATED MODULE: ./src/internals/selection.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Select a point
	   * @private
	   * @param {Object} target point
	   * @param {Object} data
	   * @param {Number} index
	   */
	  selectPoint: function selectPoint(target, d, i) {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
	        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
	        r = $$.pointSelectR.bind($$);
	    // add selected-circle on low layer g
	    callFn(config.data_onselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).data([d]).enter().append("circle").attr("class", function () {
	      return $$.generateClass(config_classes.selectedCircle, i);
	    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
	      return $$.pointSelectR(d2) * 1.4;
	    }).transition().duration(100).attr("r", r);
	  },

	  /**
	   * Unelect a point
	   * @private
	   * @param {Object} target point
	   * @param {Object} data
	   * @param {Number} index
	   */
	  unselectPoint: function unselectPoint(target, d, i) {
	    var $$ = this;
	    // remove selected-circle from low layer g
	    callFn($$.config.data_onunselected, $$.api, d, target.node()), $$.main.select(".".concat(config_classes.selectedCircles).concat($$.getTargetSelectorSuffix(d.id))).selectAll(".".concat(config_classes.selectedCircle, "-").concat(i)).transition().duration(100).attr("r", 0).remove();
	  },

	  /**
	   * Toggles the selection of points
	   * @private
	   * @param {Boolean} whether or not to select.
	   * @param {Object} target point
	   * @param {Object} data
	   * @param {Number} index
	   */
	  togglePoint: function togglePoint(selected, target, d, i) {
	    var method = "".concat(selected ? "" : "un", "selectPoint");
	    this[method](target, d, i);
	  },

	  /**
	   * Select a path
	   * @private
	   * @param {Object} target path
	   * @param {Object} data
	   */
	  selectPath: function selectPath(target, d) {
	    var $$ = this,
	        config = $$.config;
	    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
	      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
	    });
	  },

	  /**
	   * Unelect a path
	   * @private
	   * @param {Object} target path
	   * @param {Object} data
	   */
	  unselectPath: function unselectPath(target, d) {
	    var $$ = this,
	        config = $$.config;
	    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
	      return $$.color(d);
	    });
	  },

	  /**
	   * Toggles the selection of lines
	   * @private
	   * @param {Boolean} whether or not to select.
	   * @param {Object} target shape
	   * @param {Object} data
	   * @param {Number} index
	   */
	  togglePath: function togglePath(selected, target, d, i) {
	    this["".concat(selected ? "" : "un", "selectPath")](target, d, i);
	  },

	  /**
	   * Returns the toggle method of the target
	   * @private
	   * @param {Object} target shape
	   * @param {Object} data
	   * @returns {Function} toggle method
	   */
	  getToggle: function getToggle(that, d) {
	    var $$ = this;
	    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
	    $$.togglePoint;
	  },

	  /**
	   * Toggles the selection of shapes
	   * @private
	   * @param {Object} target shape
	   * @param {Object} data
	   * @param {Number} index
	   */
	  toggleShape: function toggleShape(that, d, i) {
	    var toggledShape,
	        $$ = this,
	        config = $$.config,
	        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
	        isSelected = shape.classed(config_classes.SELECTED),
	        toggle = $$.getToggle(that, d).bind($$);

	    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
	      if (!config.data_selection_multiple) {
	        var selector = ".".concat(config_classes.shapes);
	        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), $$.main.selectAll(selector).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
	          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
	          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
	        });
	      }

	      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
	    }
	  }
	});
	// CONCATENATED MODULE: ./src/interactions/subchart.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */





	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initialize the brush.
	   * @private
	   */
	  initBrush: function initBrush() {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated;
	    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

	    // set "brush" event
	    var lastDomain,
	        timeout,
	        brushHandler = function () {
	      $$.redrawForBrush();
	    },
	        getBrushSize = function () {
	      var brush = $$.svg.select(".".concat(config_classes.brush, " .overlay")),
	          brushSize = {
	        width: 0,
	        height: 0
	      };
	      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
	    };

	    // set the brush extent
	    $$.brush.on("start", function () {
	      $$.inputType === "touch" && $$.hideTooltip(), brushHandler();
	    }).on("brush", brushHandler).on("end", function () {
	      lastDomain = $$.x.orgDomain();
	    }), $$.brush.updateResize = function () {
	      var _this = this;

	      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
	        var selection = _this.getSelection();

	        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map($$.subX.orgScale()));
	      }, 0);
	    }, $$.brush.update = function () {
	      var extent = this.extent()();
	      return extent[1].filter(function (v) {
	        return isNaN(v);
	      }).length === 0 && $$.context && $$.context.select(".".concat(config_classes.brush)).call(this), this;
	    }, $$.brush.scale = function (scale) {
	      var h = config.subchart_size_height || getBrushSize(),
	          extent = $$.getExtent();
	      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
	      // when extent updates, brush selection also be re-applied
	      // https://github.com/d3/d3/issues/2918
	      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
	        return [v, i > 0 ? h : i];
	      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
	    }, $$.brush.getSelection = function () {
	      return $$.context ? $$.context.select(".".concat(config_classes.brush)) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([]);
	    };
	  },

	  /**
	   * Initialize the subchart.
	   * @private
	   */
	  initSubchart: function initSubchart() {
	    var $$ = this,
	        config = $$.config,
	        visibility = config.subchart_show ? "visible" : "hidden",
	        clipId = "".concat($$.clipId, "-subchart"),
	        clipPath = $$.getClipPath(clipId);
	    $$.clipIdForSubchart = clipId, $$.appendClip($$.defs, clipId), $$.initBrush(), $$.context = $$.svg.append("g").attr("transform", $$.getTranslate("context"));
	    var context = $$.context;
	    // Define g for chart area
	    // Define g for bar chart area
	    // Define g for line chart area
	    // Add extent rect for Brush
	    // ATTENTION: This must be called AFTER chart added
	    // Add Axis
	    context.style("visibility", visibility), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartBars), context.select(".".concat(config_classes.chart)).append("g").attr("class", config_classes.chartLines), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), $$.axes.subx = context.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subx")).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
	  },

	  /**
	   * Update sub chart
	   * @private
	   * @param {Object} $$.data.targets
	   */
	  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
	    var $$ = this,
	        context = $$.context,
	        config = $$.config,
	        classChartBar = $$.classChartBar.bind($$),
	        classBars = $$.classBars.bind($$),
	        classChartLine = $$.classChartLine.bind($$),
	        classLines = $$.classLines.bind($$),
	        classAreas = $$.classAreas.bind($$);

	    if (config.subchart_show) {
	      // -- Bar --//
	      var contextBarUpdate = context.select(".".concat(config_classes.chartBars)).selectAll(".".concat(config_classes.chartBar)).data(targets).attr("class", classChartBar),
	          contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);
	      contextBarEnter.append("g").attr("class", classBars);
	      // -- Line --//
	      var contextLineUpdate = context.select(".".concat(config_classes.chartLines)).selectAll(".".concat(config_classes.chartLine)).data(targets).attr("class", classChartLine),
	          contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);
	      // Lines for each data
	      // Area
	      // -- Brush --//
	      contextLineEnter.append("g").attr("class", classLines), $$.hasType("area") && contextLineEnter.append("g").attr("class", classAreas), context.selectAll(".".concat(config_classes.brush, " rect")).attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
	    }
	  },

	  /**
	   * Update the bar of the sub chart
	   * @private
	   * @param {Object} durationForExit
	   */
	  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
	    var $$ = this;
	    $$.contextBar = $$.context.selectAll(".".concat(config_classes.bars)).selectAll(".".concat(config_classes.bar)).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
	  },

	  /**
	   * Redraw the bar of the subchart
	   * @private
	   * @param {String} path in subchart bar
	   * @param {Boolean} whether or not to transition.
	   * @param {Number} transition duration
	   */
	  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
	    var contextBar = withTransition ? this.contextBar.transition(getRandom()).duration(duration) : this.contextBar;
	    contextBar.attr("d", drawBarOnSub).style("opacity", "1");
	  },

	  /**
	   * Update the line of the sub chart
	   * @private
	   * @param {Number} Fade-out transition duration
	   */
	  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
	    var $$ = this;
	    $$.contextLine = $$.context.selectAll(".".concat(config_classes.lines)).selectAll(".".concat(config_classes.line)).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
	  },

	  /**
	   * Redraw the line of the subchart
	   * @private
	   * @param {String} path in subchart line
	   * @param {Boolean} whether or not to transition
	   * @param {Number} transition duration
	   */
	  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
	    var contextLine = withTransition ? this.contextLine.transition(getRandom()).duration(duration) : this.contextLine;
	    contextLine.attr("d", drawLineOnSub).style("opacity", "1");
	  },

	  /**
	   * Update the area of the sub chart
	   * @private
	   * @param {Number} Fade-out transition duration
	   */
	  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
	    var $$ = this;
	    $$.contextArea = $$.context.selectAll(".".concat(config_classes.areas)).selectAll(".".concat(config_classes.area)).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
	      return $$.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
	    }).merge($$.contextArea).style("opacity", "0");
	  },

	  /**
	   * Redraw the area of the subchart
	   * @private
	   * @param {String} path in subchart line
	   * @param {Boolean} whether or not to transition
	   * @param {Number} transition duration
	   */
	  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
	    var contextArea = withTransition ? this.contextArea.transition(getRandom()).duration(duration) : this.contextArea;
	    contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
	  },

	  /**
	   * Redraw subchart.
	   * @private
	   * @param {Boolean} withSubchart whether or not to show subchart
	   * @param {Number} duration duration
	   * @param {Object} shape Shape's info
	   */
	  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
	    var $$ = this,
	        config = $$.config;
	    $$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
	      var name = capitalize(v),
	          draw = $$["generateDraw".concat(name)](shape.indices[v], !0);
	      $$["update".concat(name, "ForSubchart")](duration), $$["redraw".concat(name, "ForSubchart")](draw, duration, duration);
	    })));
	  },

	  /**
	   * Redraw the brush.
	   * @private
	   */
	  redrawForBrush: function redrawForBrush() {
	    var $$ = this;
	    $$.redraw({
	      withTransition: !1,
	      withY: $$.config.zoom_rescale,
	      withSubchart: !1,
	      withUpdateXDomain: !0,
	      withDimension: !1
	    }), $$.config.subchart_onbrush.call($$.api, $$.x.orgDomain());
	  },

	  /**
	   * Transform context
	   * @private
	   * @param {Boolean} indicates transition is enabled
	   * @param {Object} The return value of the generateTransitions method of Axis.
	   */
	  transformContext: function transformContext(withTransition, transitions) {
	    var subXAxis,
	        $$ = this;
	    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select(".".concat(config_classes.axisX)), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subx"));
	  },

	  /**
	   * Get extent value
	   * @private
	   * @returns {Array} default extent
	   */
	  getExtent: function getExtent() {
	    var $$ = this,
	        extent = $$.config.axis_x_extent;
	    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), $$.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
	      return $$.subX($$.parseDate(v));
	    }))), extent;
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
	var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(13);

	// CONCATENATED MODULE: ./src/interactions/zoom.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */







	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Initialize zoom.
	   * @private
	   */
	  initZoom: function initZoom() {
	    var $$ = this;
	    $$.zoomScale = null, $$.generateZoom(), $$.initZoomBehaviour();
	  },

	  /**
	   * Bind zoom event
	   * @param {Boolean} bind Weather bind or unbound
	   * @private
	   */
	  bindZoomEvent: function bindZoomEvent() {
	    var bind = !(arguments.length > 0 && arguments[0] !== undefined) || arguments[0],
	        $$ = this,
	        zoomEnabled = $$.config.zoom_enabled;
	    $$.redrawEventRect();
	    var eventRects = $$.main.select(".".concat(config_classes.eventRects));
	    zoomEnabled && bind ? !$$.config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
	  },

	  /**
	   * Generate zoom
	   * @private
	   */
	  generateZoom: function generateZoom() {
	    var $$ = this,
	        config = $$.config,
	        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
	    // get zoom extent

	    /**
	     * Update scale according zoom transform value
	     * @param {Object} transform
	     * @private
	     */
	    zoom.orgScaleExtent = function () {
	      var extent = config.zoom_extent || [1, 10];
	      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
	    }, zoom.updateScaleExtent = function () {
	      var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
	          extent = this.orgScaleExtent();
	      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
	    }, zoom.updateTransformScale = function (transform) {
	      $$.orgXScale && $$.orgXScale.range($$.x.range());
	      // rescale from the original scale
	      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"]($$.orgXScale || $$.x),
	          domain = $$.trimXDomain(newScale.domain()),
	          rescale = config.zoom_rescale;
	      newScale.domain(domain, $$.orgXDomain), $$.zoomScale = $$.getCustomizedScale(newScale), $$.xAxis.scale($$.zoomScale), rescale && (!$$.orgXScale && ($$.orgXScale = $$.x.copy()), $$.x.domain(domain));
	    }, $$.zoom = zoom;
	  },

	  /**
	   * 'start' event listener
	   * @private
	   */
	  onZoomStart: function onZoomStart() {
	    var $$ = this,
	        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
	    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
	  },

	  /**
	   * 'zoom' event listener
	   * @private
	   */
	  onZoom: function onZoom() {
	    var $$ = this,
	        config = $$.config,
	        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
	        sourceEvent = event.sourceEvent;

	    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && ($$.zoomScale || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
	      var isMousemove = sourceEvent.type === "mousemove",
	          isZoomOut = sourceEvent.wheelDelta < 0,
	          transform = event.transform;
	      !isMousemove && isZoomOut && $$.x.domain().every(function (v, i) {
	        return v !== $$.orgXDomain[i];
	      }) && $$.x.domain($$.orgXDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && $$.x.orgDomain()[0] === $$.orgXDomain[0] && $$.x.domain([$$.orgXDomain[0] - 1e-10, $$.x.orgDomain()[1]]), $$.redraw({
	        withTransition: !1,
	        withY: config.zoom_rescale,
	        withSubchart: !1,
	        withEventRect: !1,
	        withDimension: !1
	      }), $$.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, $$.zoomScale.domain());
	    }
	  },

	  /**
	   * 'end' event listener
	   * @private
	   */
	  onZoomEnd: function onZoomEnd() {
	    var $$ = this,
	        startEvent = $$.zoom.startEvent,
	        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
	    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
	    // if click, do nothing. otherwise, click interaction will be canceled.
	    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn($$.config.zoom_onzoomend, $$.api, $$[$$.zoomScale ? "zoomScale" : "subX"].domain()));
	  },

	  /**
	   * Get zoom domain
	   * @returns {Array} zoom domain
	  	 * @private
	   */
	  getZoomDomain: function getZoomDomain() {
	    var $$ = this,
	        config = $$.config,
	        _$$$orgXDomain = _slicedToArray($$.orgXDomain, 2),
	        min = _$$$orgXDomain[0],
	        max = _$$$orgXDomain[1];

	    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
	  },

	  /**
	   * Update zoom
	   * @param {Boolean} force Force unzoom
	   * @private
	   */
	  updateZoom: function updateZoom(force) {
	    var $$ = this;

	    if ($$.zoomScale) {
	      var zoomDomain = $$.zoomScale.domain(),
	          xDomain = $$.subX.domain(),
	          delta = .015,
	          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
	      (force || isfullyShown) && ($$.xAxis.scale($$.subX), $$.x.domain($$.subX.orgDomain()), $$.zoomScale = null);
	    }
	  },

	  /**
	   * Attach zoom event on <rect>
	   * @private
	   */
	  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
	    var $$ = this,
	        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
	    eventRects.call(behaviour).on("dblclick.zoom", null);
	  },

	  /**
	   * Initialize the drag behaviour used for zooming.
	   * @private
	   */
	  initZoomBehaviour: function initZoomBehaviour() {
	    var $$ = this,
	        config = $$.config,
	        isRotated = config.axis_rotated,
	        start = 0,
	        end = 0,
	        zoomRect = null,
	        prop = {
	      axis: isRotated ? "y" : "x",
	      attr: isRotated ? "height" : "width",
	      index: isRotated ? 1 : 0
	    };
	    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
	      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.main.append("rect").attr("clip-path", $$.clipPath).attr("class", config_classes.zoomBrush).attr("width", isRotated ? $$.width : 0).attr("height", isRotated ? 0 : $$.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
	    }).on("drag", function () {
	      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
	    }).on("end", function () {
	      var _ref,
	          scale = $$.zoomScale || $$.x;

	      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
	        return scale.invert(v);
	      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
	        var _event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
	            _ref2 = "clientX" in _event ? [_event.clientX, _event.clientY] : [_event.x, _event.y],
	            _ref3 = _slicedToArray(_ref2, 2),
	            x = _ref3[0],
	            y = _ref3[1],
	            target = browser_doc.elementFromPoint(x, y);

	        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
	      }
	    });
	  },
	  setZoomResetButton: function setZoomResetButton() {
	    var $$ = this,
	        config = $$.config,
	        resetButton = config.zoom_resetButton;
	    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.selectChart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
	      isFunction(resetButton.onclick) && resetButton.onclick(this), $$.api.unzoom.call($$);
	    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
	  }
	});
	// CONCATENATED MODULE: ./src/internals/color.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */






	/**
	 * Set pattern's background color
	 * (it adds a <rect> element to simulate bg-color)
	 * @param {SVGPatternElement} pattern SVG pattern element
	 * @param {String} color Color string
	 * @param {String} id ID to be set
	 * @return {{id: string, node: SVGPatternElement}}
	 * @private
	 */

	var colorizePattern = function (pattern, color, id) {
	  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
	  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
	    id: id,
	    node: node.node()
	  };
	},
	    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
	// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Get color pattern from CSS file
	   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
	   * @return {Array}
	   * @private
	   */
	  getColorFromCss: function getColorFromCss() {
	    var body = browser_doc.body,
	        pattern = body["__colorPattern__"];

	    if (!pattern) {
	      var span = browser_doc.createElement("span");
	      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
	      var content = win.getComputedStyle(span).backgroundImage;
	      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
	        return v.trim().replace(/[\"'\s]/g, "");
	      }).filter(Boolean), body["__colorPattern__"] = pattern);
	    }

	    return pattern;
	  },
	  generateColor: function generateColor() {
	    var $$ = this,
	        config = $$.config,
	        colors = config.data_colors,
	        callback = config.data_color,
	        ids = [],
	        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
	        originalColorPattern = pattern;

	    if (isFunction(config.color_tiles)) {
	      var tiles = config.color_tiles(),
	          colorizedPatterns = pattern.map(function (p, index) {
	        var color = p.replace(/[#\(\)\s,]/g, ""),
	            id = "".concat($$.datetimeId, "-pattern-").concat(color, "-").concat(index);
	        return colorizePattern(tiles[index % tiles.length], p, id);
	      }); // Add background color to patterns

	      pattern = colorizedPatterns.map(function (p) {
	        return "url(#".concat(p.id, ")");
	      }), $$.patterns = colorizedPatterns;
	    }

	    return function (d) {
	      var color,
	          id = d.id || d.data && d.data.id || d,
	          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !$$.config.data_types[id];
	      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
	    };
	  },
	  generateLevelColor: function generateLevelColor() {
	    var $$ = this,
	        config = $$.config,
	        colors = config.color_pattern,
	        threshold = config.color_threshold,
	        asValue = threshold.unit === "value",
	        max = threshold.max || 100,
	        values = threshold.values && threshold.values.length ? threshold.values : [];
	    return notEmpty(threshold) ? function (value) {
	      var v = asValue ? value : value * 100 / max,
	          color = colors[colors.length - 1];

	      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
	        color = colors[i];
	        break;
	      }

	      return color;
	    } : null;
	  },

	  /**
	   * Set the data over color.
	   * When is out, will restore in its previous color value
	   * @param {Boolean} isOver true: set overed color, false: restore
	   * @param {Number|Object} d target index or data object for Arc type
	   * @private
	   */
	  setOverColor: function setOverColor(isOver, d) {
	    var $$ = this,
	        config = $$.config,
	        onover = config.color_onover,
	        color = isOver ? onover : $$.color;
	    isObject(color) ? color = function (_ref) {
	      var id = _ref.id;
	      return id in onover ? onover[id] : $$.color(id);
	    } : isString(color) && (color = function () {
	      return onover;
	    }), isObject(d) ? $$.main.selectAll(".".concat(config_classes.arc).concat($$.getTargetSelectorSuffix(d.id))).style("fill", color(d)) : $$.main.selectAll(".".concat(config_classes.shape, "-").concat(d)).style("fill", color);
	  }
	});
	// CONCATENATED MODULE: ./src/internals/format.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	var getFormat = function ($$, typeValue, v) {
	  var config = $$.config,
	      type = "axis_".concat(typeValue, "_tick_format"),
	      format = config[type] ? config[type] : $$.defaultValueFormat;
	  return format(v);
	};

	extend(ChartInternal_ChartInternal.prototype, {
	  getYFormat: function getYFormat(forArc) {
	    var $$ = this,
	        formatForY = $$.yFormat,
	        formatForY2 = $$.y2Format;
	    return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function (v, ratio, id) {
	      var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;
	      return format.call($$, v, ratio);
	    };
	  },
	  yFormat: function yFormat(v) {
	    return getFormat(this, "y", v);
	  },
	  y2Format: function y2Format(v) {
	    return getFormat(this, "y2", v);
	  },
	  defaultValueFormat: function defaultValueFormat(v) {
	    return isValue(v) ? +v : "";
	  },
	  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
	    return "".concat((ratio * 100).toFixed(1), "%");
	  },
	  dataLabelFormat: function dataLabelFormat(targetId) {
	    var $$ = this,
	        dataLabels = $$.config.data_labels,
	        defaultFormat = function (v) {
	      return isValue(v) ? +v : "";
	    },
	        format = defaultFormat;

	    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
	      return "";
	    }), format;
	  }
	});
	// CONCATENATED MODULE: ./src/internals/cache.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Add cache
	   * @param {String} key
	   * @param {*} value
	   * @param {Boolean} isDataType
	   * @private
	   */
	  addCache: function addCache(key, value) {
	    var isDataType = !!(arguments.length > 2 && arguments[2] !== undefined) && arguments[2];
	    this.cache[key] = isDataType ? this.cloneTarget(value) : value;
	  },

	  /**
	   * Remove cache
	   * @param {String|Array} key
	   * @private
	   */
	  removeCache: function removeCache(key) {
	    var _this = this;

	    toArray(key).forEach(function (v) {
	      return delete _this.cache[v];
	    });
	  },

	  /**
	   * Get cahce
	   * @param {String|Array} key
	   * @param {Boolean} isDataType
	   * @return {*}
	   * @private
	   */
	  getCache: function getCache(key) {
	    var isDataType = !!(arguments.length > 1 && arguments[1] !== undefined) && arguments[1];

	    if (isDataType) {
	      var targets = [];

	      for (var id, i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

	      return targets;
	    }

	    return this.cache[key] || null;
	  },

	  /**
	   * reset cached data
	   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
	   * @private
	  	 */
	  resetCache: function resetCache(all) {
	    var $$ = this;

	    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
	  }
	});
	// CONCATENATED MODULE: ./src/internals/class.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(ChartInternal_ChartInternal.prototype, {
	  generateClass: function generateClass(prefix, targetId) {
	    return " ".concat(prefix, " ").concat(prefix + this.getTargetSelectorSuffix(targetId));
	  },
	  classText: function classText(d) {
	    return this.generateClass(config_classes.text, d.index);
	  },
	  classTexts: function classTexts(d) {
	    return this.generateClass(config_classes.texts, d.id);
	  },
	  classShape: function classShape(d) {
	    return this.generateClass(config_classes.shape, d.index);
	  },
	  classShapes: function classShapes(d) {
	    return this.generateClass(config_classes.shapes, d.id);
	  },
	  generateExtraLineClass: function generateExtraLineClass() {
	    var $$ = this,
	        classes = $$.config.line_classes || [],
	        ids = [];
	    return function (d) {
	      var id = d.id || d.data && d.data.id || d;
	      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
	    };
	  },
	  classLine: function classLine(d) {
	    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
	  },
	  classLines: function classLines(d) {
	    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
	  },
	  classCircle: function classCircle(d) {
	    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
	  },
	  classCircles: function classCircles(d) {
	    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
	  },
	  classBar: function classBar(d) {
	    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
	  },
	  classBars: function classBars(d) {
	    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
	  },
	  classArc: function classArc(d) {
	    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
	  },
	  classArcs: function classArcs(d) {
	    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
	  },
	  classArea: function classArea(d) {
	    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
	  },
	  classAreas: function classAreas(d) {
	    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
	  },
	  classRegion: function classRegion(d, i) {
	    return "".concat(this.generateClass(config_classes.region, i), " ").concat("class" in d ? d["class"] : "");
	  },
	  classEvent: function classEvent(d) {
	    return this.generateClass(config_classes.eventRect, d.index);
	  },
	  classTarget: function classTarget(id) {
	    var additionalClassSuffix = this.config.data_classes[id],
	        additionalClass = "";
	    return additionalClassSuffix && (additionalClass = " ".concat(config_classes.target, "-").concat(additionalClassSuffix)), this.generateClass(config_classes.target, id) + additionalClass;
	  },
	  classFocus: function classFocus(d) {
	    return this.classFocused(d) + this.classDefocused(d);
	  },
	  classFocused: function classFocused(d) {
	    return " ".concat(this.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
	  },
	  classDefocused: function classDefocused(d) {
	    return " ".concat(this.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
	  },
	  classChartText: function classChartText(d) {
	    return config_classes.chartText + this.classTarget(d.id);
	  },
	  classChartLine: function classChartLine(d) {
	    return config_classes.chartLine + this.classTarget(d.id);
	  },
	  classChartBar: function classChartBar(d) {
	    return config_classes.chartBar + this.classTarget(d.id);
	  },
	  classChartArc: function classChartArc(d) {
	    return config_classes.chartArc + this.classTarget(d.data.id);
	  },
	  classChartRadar: function classChartRadar(d) {
	    return config_classes.chartRadar + this.classTarget(d.id);
	  },
	  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
	    return targetId || targetId === 0 ? "-".concat(targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
	  },
	  selectorTarget: function selectorTarget(id, prefix) {
	    return "".concat(prefix || "", ".").concat(config_classes.target + this.getTargetSelectorSuffix(id));
	  },
	  selectorTargets: function selectorTargets(idsValue, prefix) {
	    var $$ = this,
	        ids = idsValue || [];
	    return ids.length ? ids.map(function (id) {
	      return $$.selectorTarget(id, prefix);
	    }) : null;
	  },
	  selectorLegend: function selectorLegend(id) {
	    return ".".concat(config_classes.legendItem + this.getTargetSelectorSuffix(id));
	  },
	  selectorLegends: function selectorLegends(ids) {
	    var $$ = this;
	    return ids && ids.length ? ids.map(function (id) {
	      return $$.selectorLegend(id);
	    }) : null;
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.focus.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	extend(Chart_Chart.prototype, {
	  /**
	   * This API highlights specified targets and fade out the others.<br><br>
	   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
	   * @method focus
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} targetIdsValue Target ids to be highlighted.
	   * @example
	   *  // data1 will be highlighted and the others will be faded out
	   *  chart.focus("data1");
	   *
	   * // data1 and data2 will be highlighted and the others will be faded out
	   * chart.focus(["data1", "data2"]);
	   *
	   * // all targets will be highlighted
	   * chart.focus();
	   */
	  focus: function focus(targetIdsValue) {
	    var $$ = this.internal,
	        targetIds = $$.mapToTargetIds(targetIdsValue),
	        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
	    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, ".".concat(config_classes.gaugeValue))), $$.toggleFocusLegend(targetIds, !0), $$.focusedTargetIds = targetIds, $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
	      return targetIds.indexOf(id) < 0;
	    });
	  },

	  /**
	   * This API fades out specified targets and reverts the others.<br><br>
	   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
	   * @method defocus
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} Target ids to be faded out.
	   * @example
	   * // data1 will be faded out and the others will be reverted.
	   * chart.defocus("data1");
	   *
	   * // data1 and data2 will be faded out and the others will be reverted.
	   * chart.defocus(["data1", "data2"]);
	   *
	   * // all targets will be faded out.
	   * chart.defocus();
	   */
	  defocus: function defocus(targetIdsValue) {
	    var $$ = this.internal,
	        targetIds = $$.mapToTargetIds(targetIdsValue),
	        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
	    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, ".".concat(config_classes.gaugeValue))), $$.toggleFocusLegend(targetIds, !1), $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
	      return targetIds.indexOf(id) < 0;
	    }), $$.defocusedTargetIds = targetIds;
	  },

	  /**
	   * This API reverts specified targets.<br><br>
	   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
	   * @method revert
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} Target ids to be reverted
	   * @example
	   * // data1 will be reverted.
	   * chart.revert("data1");
	   *
	   * // data1 and data2 will be reverted.
	   * chart.revert(["data1", "data2"]);
	   *
	   * // all targets will be reverted.
	   * chart.revert();
	   */
	  revert: function revert(targetIdsValue) {
	    var $$ = this.internal,
	        targetIds = $$.mapToTargetIds(targetIdsValue),
	        candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
	    // should be for all targets
	    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), $$.config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
	      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
	    }).classed(config_classes.legendItemFocused, !1)), $$.focusedTargetIds = [], $$.defocusedTargetIds = [];
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.show.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Show/Hide data series
	   * @private
	   */
	  _showHide: function _showHide(show, targetIdsValue, options) {
	    var $$ = this.internal,
	        targetIds = $$.mapToTargetIds(targetIdsValue);
	    $$["".concat(show ? "remove" : "add", "HiddenTargetIds")](targetIds);
	    var targets = $$.svg.selectAll($$.selectorTargets(targetIds)),
	        opacity = show ? "1" : "0";
	    targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
	      targets.style("opacity", null).style("opacity", opacity);
	    }), options.withLegend && $$["".concat(show ? "show" : "hide", "Legend")](targetIds), $$.redraw({
	      withUpdateOrgXDomain: !0,
	      withUpdateXDomain: !0,
	      withLegend: !0
	    });
	  },

	  /**
	   * Show data series on chart
	   * @method show
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} [targetIdsValue=all] The target id value.
	   * @param {Object} [options] The object can consist with following members:<br>
	   *
	   *    | Key | Type | default | Description |
	   *    | --- | --- | --- | --- |
	   *    | withLegend | Boolean | false | whether or not display legend |
	   *
	   * @example
	   * // show 'data1'
	   * chart.show("data1");
	   *
	   * // show 'data1' and 'data3'
	   * chart.show(["data1", "data3"]);
	   */
	  show: function show(targetIdsValue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    this._showHide(!0, targetIdsValue, options);
	  },

	  /**
	   * Hide data series from chart
	   * @method hide
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} [targetIdsValue=all] The target id value.
	   * @param {Object} [options] The object can consist with following members:<br>
	   *
	   *    | Key | Type | default | Description |
	   *    | --- | --- | --- | --- |
	   *    | withLegend | Boolean | false | whether or not display legend |
	   *
	   * @example
	   * // hide 'data1'
	   * chart.hide("data1");
	   *
	   * // hide 'data1' and 'data3'
	   * chart.hide(["data1", "data3"]);
	   */
	  hide: function hide(targetIdsValue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    this._showHide(!1, targetIdsValue, options);
	  },

	  /**
	   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
	   * @method toggle
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} [targetIdsValue=all] The target id value.
	   * @param {Object} [options] The object can consist with following members:<br>
	   *
	   *    | Key | Type | default | Description |
	   *    | --- | --- | --- | --- |
	   *    | withLegend | Boolean | false | whether or not display legend |
	   *
	   * @example
	   * // toggle 'data1'
	   * chart.toggle("data1");
	   *
	   * // toggle 'data1' and 'data3'
	   * chart.toggle(["data1", "data3"]);
	   */
	  toggle: function toggle(targetIds) {
	    var _this = this,
	        options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        $$ = this.internal,
	        targets = {
	      show: [],
	      hide: []
	    };

	    // sort show & hide target ids
	    // perform show & hide task separately
	    // https://github.com/naver/billboard.js/issues/454
	    $$.mapToTargetIds(targetIds).forEach(function (id) {
	      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
	    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
	      return _this.hide(targets.hide, options);
	    }, 0);
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.zoom.js


	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	/**
	 * Check if the given domain is within zoom range
	 * @param {Array} domain
	 * @return {Boolean}
	 * @private
	 */

	var withinRange = function (domain, range) {
	  var _range = _slicedToArray(range, 2),
	      min = _range[0],
	      max = _range[1];

	  return domain.every(function (v, i) {
	    return i === 0 ? v >= min : v <= max;
	  });
	},
	    api_zoom_zoom = function (domainValue) {
	  var resultDomain,
	      $$ = this.internal,
	      domain = domainValue;

	  if ($$.config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
	    var isTimeSeries = $$.isTimeSeries();

	    if (isTimeSeries && (domain = domain.map(function (x) {
	      return $$.parseDate(x);
	    })), $$.config.subchart_show) {
	      var xScale = $$.zoomScale || $$.x;
	      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
	    } else $$.x.domain(domain), $$.zoomScale = $$.x, $$.xAxis.scale($$.zoomScale), resultDomain = $$.zoomScale.orgDomain();

	    $$.redraw({
	      withTransition: !0,
	      withY: $$.config.zoom_rescale,
	      withDimension: !1
	    }), $$.setZoomResetButton(), callFn($$.config.zoom_onzoom, $$.api, resultDomain);
	  } else resultDomain = $$.zoomScale ? $$.zoomScale.domain() : $$.x.orgDomain();

	  return resultDomain;
	};
	/**
	 * Zoom by giving x domain.
	 * - **NOTE:**
	 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
	 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
	 * @method zoom
	 * @instance
	 * @memberof Chart
	 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
	 * @return {Array} domain value in array
	 * @example
	 *  // Zoom to specified domain
	 *  chart.zoom([10, 20]);
	 *
	 *  // Get the current zoomed domain
	 *  chart.zoom();
	 */


	extend(api_zoom_zoom, {
	  /**
	   * Enable and disable zooming.
	   * @method zoom․enable
	   * @instance
	   * @memberof Chart
	   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
	   * @example
	   *  // Enable zooming using the mouse wheel
	   *  chart.zoom.enable(true);
	   *  // Or
	   *  chart.zoom.enable("wheel");
	   *
	   *  // Enable zooming by dragging
	   *  chart.zoom.enable("drag");
	   *
	   *  // Disable zooming
	   *  chart.zoom.enable(false);
	   */
	  enable: function enable() {
	    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "wheel",
	        $$ = this.internal,
	        config = $$.config,
	        enableType = enabled;
	    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
	      type: enabled
	    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
	  },

	  /**
	   * Set or get x Axis maximum zoom range value
	   * @method zoom․max
	   * @instance
	   * @memberof Chart
	   * @param {Number} [max] maximum value to set for zoom
	   * @return {Number} zoom max value
	   * @example
	   *  // Set maximum range value
	   *  chart.zoom.max(20);
	   */
	  max: function max(_max) {
	    var $$ = this.internal,
	        config = $$.config;
	    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [$$.orgXDomain[1], _max])), config.zoom_x_max;
	  },

	  /**
	   * Set or get x Axis minimum zoom range value
	   * @method zoom․min
	   * @instance
	   * @memberof Chart
	   * @param {Number} [min] minimum value to set for zoom
	   * @return {Number} zoom min value
	   * @example
	   *  // Set minimum range value
	   *  chart.zoom.min(-1);
	   */
	  min: function min(_min) {
	    var $$ = this.internal,
	        config = $$.config;
	    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [$$.orgXDomain[0], _min])), config.zoom_x_min;
	  },

	  /**
	   * Set zoom range
	   * @method zoom․range
	   * @instance
	   * @memberof Chart
	   * @param {Object} [range]
	   * @return {Object} zoom range value
	   * {
	   *   min: 0,
	   *   max: 100
	   * }
	   * @example
	   *  chart.zoom.range({
	   *      min: 10,
	   *      max: 100
	   *  });
	   */
	  range: function range(_range2) {
	    var zoom = this.zoom;

	    if (isObject(_range2)) {
	      var min = _range2.min,
	          max = _range2.max;
	      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
	    }

	    return {
	      min: zoom.min(),
	      max: zoom.max()
	    };
	  }
	}), extend(Chart_Chart.prototype, {
	  zoom: api_zoom_zoom,

	  /**
	   * Unzoom zoomed area
	   * @method unzoom
	   * @instance
	   * @memberof Chart
	   * @example
	   *  chart.unzoom();
	   */
	  unzoom: function unzoom() {
	    var $$ = this.internal,
	        config = $$.config;

	    if ($$.zoomScale) {
	      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
	      // reset transform
	      var eventRects = $$.main.select(".".concat(config_classes.eventRects));
	      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
	        withTransition: !0,
	        withUpdateXDomain: !0,
	        withUpdateOrgXDomain: !0,
	        withY: config.zoom_rescale
	      });
	    }
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.load.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Load data to the chart.<br><br>
	   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
	   * - <b>Note:</b>
	   *   - unload should be used if some data needs to be unloaded simultaneously.
	   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
	   *   - done will be called after data loaded, but it's not after rendering.
	   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
	   * @method load
	   * @instance
	   * @memberof Chart
	   * @param {Object} args The object can consist with following members:<br>
	   *
	   *    | Key | Description |
	   *    | --- | --- |
	   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
	   *    | data | Data objects to be loaded. Checkout the example. |
	   *    | names | Same as data.names() |
	   *    | xs | Same as data.xs option  |
	   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
	   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
	   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
	   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
	   *    | headers |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |
	   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |
	   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |
	   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
	   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
	   *    | done | The specified function will be called after data loaded.|
	   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
	   * @example
	   * // Load data1 and unload data2 and data3
	   * chart.load({
	   *     columns: [
	   *        ["data1", 100, 200, 150, ...],
	   *        ...
	   *    ],
	   *    unload: ["data2", "data3"],
	   *    url: "...",
	   *    done: function() { ... }
	   * });
	   * @example
	   * // myAPI.json
	   * // {
	   * //   "data1": [220, 240, 270, 250, 280],
	   * //   "data2": [180, 150, 300, 70, 120]
	   * // }
	   *
	   * chart.load({
	   *     url: './data/myAPI.json',
	   *     mimeType: "json",
	   *
	   *     // set request header if is needed
	   *     headers: {
	   *       "Content-Type": "text/json"
	   *     }
	   * });
	   * @example
	   * chart.load({
	   *     data: [
	   *       // equivalent as: columns: [["data1", 30, 200, 100]]
	   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
	   *
	   *       // or
	   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
	   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
	   *     ]
	   * });
	   * @example
	   * chart.load({
	   *     json: [
	   *          {name: "www.site1.com", upload: 800, download: 500, total: 400},
	   *     ],
	   *     keys: {
	   *         x: "name",
	   *         value: ["upload", "download"]
	   *     }
	   * });
	   */
	  load: function load(args) {
	    var $$ = this.internal,
	        config = $$.config;
	    // update xs if specified
	    // update names if exists
	    // update classes if exists
	    // update axes if exists
	    // update colors if exists
	    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
	      config.data_classes[id] = args.classes[id];
	    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
	      config.data_axes[id] = args.axes[id];
	    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
	      config.data_colors[id] = args.colors[id];
	    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
	      return $$.loadFromArgs(args);
	    }) : $$.loadFromArgs(args);
	  },

	  /**
	   * Unload data to the chart.<br><br>
	   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
	   * - <b>Note:</b>
	   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
	   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
	   * @method unload
	   * @instance
	   * @memberof Chart
	   * @param {Object} args
	   *  | key | Type | Description |
	   *  | --- | --- | --- |
	   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
	   *  | done | Fuction | Callback after data is unloaded. |
	   * @example
	   *  // Unload data2 and data3
	   *  chart.unload({
	   *    ids: ["data2", "data3"],
	   *    done: function() {
	   *       // called after the unloaded
	   *    }
	   *  });
	   */
	  unload: function unload(argsValue) {
	    var $$ = this.internal,
	        args = argsValue || {};
	    isArray(args) ? args = {
	      ids: args
	    } : isString(args) && (args = {
	      ids: [args]
	    });
	    var ids = $$.mapToTargetIds(args.ids);
	    $$.unload(ids, function () {
	      $$.redraw({
	        withUpdateOrgXDomain: !0,
	        withUpdateXDomain: !0,
	        withLegend: !0
	      }), $$.removeCache(ids), args.done && args.done();
	    });
	  }
	});
	// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
	var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(14);

	// CONCATENATED MODULE: ./src/api/api.flow.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */







	extend(Chart_Chart.prototype, {
	  /**
	   * Flow data to the chart.<br><br>
	   * By this API, you can append new data points to the chart.
	   * @method flow
	   * @instance
	   * @memberof Chart
	   * @param {Object} args The object can consist with following members:<br>
	   *
	   *    | Key | Type | Description |
	   *    | --- | --- | --- |
	   *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
	   *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
	   *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
	   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
	   *    | length | Number | The lower x edge will move by the number of this argument |
	   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
	   *    | done | Function | The specified function will be called when flow ends |
	   *
	   * - **NOTE:**
	   *   - If json, rows and columns given, the data will be loaded.
	   *   - If data that has the same target id is given, the chart will be appended.
	   *   - Otherwise, new target will be added. One of these is required when calling.
	   *   - If json specified, keys is required as well as data.json.
	   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
	   * @example
	   * // 2 data points will be apprended to the tail and popped from the head.
	   * // After that, 4 data points will be appended and no data points will be poppoed.
	   * chart.flow({
	   *  columns: [
	   *    ["x", "2018-01-11", "2018-01-21"],
	   *    ["data1", 500, 200],
	   *    ["data2", 100, 300],
	   *    ["data3", 200, 120]
	   *  ],
	   *  to: "2013-01-11",
	   *  done: function () {
	   *    chart.flow({
	   *      columns: [
	   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
	   *        ["data1", 200, 300, 100, 250],
	   *        ["data2", 100, 90, 40, 120],
	   *        ["data3", 100, 100, 300, 500]
	   *      ],
	   *      length: 2,
	      *      duration: 1500
	   *    });
	   *  }
	   * });
	   */
	  flow: function flow(args) {
	    var data,
	        domain,
	        diff,
	        to,
	        $$ = this.internal,
	        length = 0,
	        tail = 0;

	    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
	      var notfoundIds = [],
	          orgDataCount = $$.getMaxDataCount(),
	          targets = $$.convertDataToTargets(data, !0);
	      $$.data.targets.forEach(function (t) {
	        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
	          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

	          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

	          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
	          break;
	        }

	        found || notfoundIds.push(t.id);
	      }), $$.data.targets.forEach(function (t) {
	        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
	          tail = t.values[t.values.length - 1].index + 1;

	          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
	            id: t.id,
	            index: tail + _j4,
	            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
	            value: null
	          });
	        }
	      }), $$.data.targets.length && targets.forEach(function (t) {
	        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
	          id: t.id,
	          index: i,
	          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
	          value: null
	        });

	        t.values.forEach(function (v) {
	          v.index += tail, $$.isTimeSeries() || (v.x += tail);
	        }), t.values = missing.concat(t.values);
	      }), $$.data.targets = $$.data.targets.concat(targets);
	      // add remained
	      // check data count because behavior needs to change when it"s only one
	      // const dataCount = $$.getMaxDataCount();
	      var baseTarget = $$.data.targets[0],
	          baseValue = baseTarget.values[0];
	      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
	        v.x < to && length++;
	      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
	        flow: {
	          index: baseValue.index,
	          length: length,
	          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
	          done: args.done,
	          orgDataCount: orgDataCount
	        },
	        withLegend: !0,
	        withTransition: orgDataCount > 1,
	        withTrimXDomain: !1,
	        withUpdateXAxis: !0
	      });
	    }
	  }
	}), extend(ChartInternal_ChartInternal.prototype, {
	  /**
	   * Generate flow
	   * @memberof ChartInternal
	   * @private
	   * @param {Object} args
	   * @return {Function}
	   */
	  generateFlow: function generateFlow(args) {
	    var $$ = this,
	        config = $$.config;
	    return function () {
	      var translateX,
	          targets = args.targets,
	          flow = args.flow,
	          _args$shape$type = args.shape.type,
	          drawBar = _args$shape$type.bar,
	          drawLine = _args$shape$type.line,
	          drawArea = _args$shape$type.area,
	          _args$shape$pos = args.shape.pos,
	          cx = _args$shape$pos.cx,
	          cy = _args$shape$pos.cy,
	          xForText = _args$shape$pos.xForText,
	          yForText = _args$shape$pos.yForText,
	          xv = args.xv,
	          duration = args.duration,
	          scaleX = 1,
	          flowIndex = flow.index,
	          flowLength = flow.length,
	          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
	          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
	          orgDomain = $$.x.domain(),
	          durationForFlow = flow.duration || duration,
	          done = flow.done || function () {},
	          wait = $$.generateWait(),
	          xgrid = $$.xgrid || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          xgridLines = $$.xgridLines || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          mainRegion = $$.mainRegion || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          mainText = $$.mainText || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          mainBar = $$.mainBar || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          mainLine = $$.mainLine || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          mainArea = $$.mainArea || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
	          mainCircle = $$.mainCircle || Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);

	      $$.flowing = !0, $$.data.targets.forEach(function (d) {
	        d.values.splice(0, flowLength);
	      });
	      // update x domain to generate axis elements for flow
	      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

	      $$.updateXGrid && $$.updateXGrid(!0), flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : $$.isTimeSeries() ? translateX = $$.x(orgDomain[0]) - $$.x(domain[0]) : translateX = $$.x(flowStart.x) - $$.x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = $$.x(orgDomain[0]) - $$.x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
	      var transform = "translate(".concat(translateX, ",0) scale(").concat(scaleX, ",1)");
	      $$.hideGridFocus();
	      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
	      wait.add([$$.axes.x.transition(gt).call(function (g) {
	        return $$.xAxis.setTransition(gt).create(g);
	      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
	        var isRotated = config.axis_rotated; // remove flowed elements

	        if (flowLength) {
	          for (var target = {
	            shapes: [],
	            texts: [],
	            eventRects: []
	          }, i = 0; i < flowLength; i++) target.shapes.push(".".concat(config_classes.shape, "-").concat(i)), target.texts.push(".".concat(config_classes.text, "-").concat(i)), target.eventRects.push(".".concat(config_classes.eventRect, "-").concat(i));

	          ["shapes", "texts", "eventRects"].forEach(function (v) {
	            $$.svg.selectAll(".".concat(config_classes[v])).selectAll(target[v]).remove();
	          }), $$.svg.select(".".concat(config_classes.xgrid)).remove();
	        } // draw again for removing flowed elements and reverting attr


	        if (xgrid.size() && xgrid.attr("transform", null).attr($$.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? $$.width : xv), xgridLines.select("text").attr("x", isRotated ? $$.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
	          var xFunc = function (d) {
	            return cx(d) - config.point_r;
	          },
	              yFunc = function (d) {
	            return cy(d) - config.point_r;
	          };

	          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
	          .attr("cy", cy);
	        }
	        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), $$.flowing = !1;
	      });
	    };
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.selection.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	extend(Chart_Chart.prototype, {
	  /**
	   * Get selected data points.<br><br>
	   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
	   * @method selected
	   * @instance
	   * @memberof Chart
	   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
	   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
	   * @example
	   *  // all selected data points will be returned.
	   *  chart.selected();
	   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
	   *
	   *  // all selected data points of data1 will be returned.
	   *  chart.selected("data1");
	   */
	  selected: function selected(targetId) {
	    var $$ = this.internal,
	        dataPoint = [];
	    return $$.main.selectAll(".".concat(config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll(".".concat(config_classes.shape)).filter(function () {
	      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
	    }).each(function (d) {
	      return dataPoint.push(d);
	    }), dataPoint;
	  },

	  /**
	   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
	   * @method select
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} [ids] id value to get selected.
	   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
	   * @param {Boolean} [resetOther] Unselect already selected.
	   * @example
	   *  // select all data points
	   *  chart.select();
	   *
	   *  // select all from 'data2'
	   *  chart.select("data2");
	   *
	   *  // select all from 'data1' and 'data2'
	   *  chart.select(["data1", "data2"]);
	   *
	   *  // select from 'data1', indices 2 and unselect others selected
	   *  chart.select("data1", [2], true);
	   *
	   *  // select from 'data1', indices 0, 3 and 5
	   *  chart.select("data1", [0, 3, 5]);
	   */
	  select: function select(ids, indices, resetOther) {
	    var $$ = this.internal,
	        config = $$.config;
	    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
	      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	          id = d.data ? d.data.id : d.id,
	          toggle = $$.getToggle(this, d).bind($$),
	          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
	          isTargetIndex = !indices || indices.indexOf(i) >= 0,
	          isSelected = shape.classed(config_classes.SELECTED);
	      // line/area selection not supported yet
	      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
	    });
	  },

	  /**
	   * Set data points to be un-selected.
	   * @method unselect
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} [ids] id value to be unselected.
	   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
	   * @example
	   *  // unselect all data points
	   *  chart.unselect();
	   *
	   *  // unselect all from 'data1'
	   *  chart.unselect("data1");
	   *
	   *  // unselect from 'data1', indices 2
	   *  chart.unselect("data1", [2]);
	   */
	  unselect: function unselect(ids, indices) {
	    var $$ = this.internal,
	        config = $$.config;
	    config.data_selection_enabled && $$.main.selectAll(".".concat(config_classes.shapes)).selectAll(".".concat(config_classes.shape)).each(function (d, i) {
	      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
	          id = d.data ? d.data.id : d.id,
	          toggle = $$.getToggle(this, d).bind($$),
	          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
	          isTargetIndex = !indices || indices.indexOf(i) >= 0,
	          isSelected = shape.classed(config_classes.SELECTED);
	      // line/area selection not supported yet
	      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
	    });
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.transform.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	/**
	 * Change the type of the chart.
	 * @private
	 * @param {String|Array} targetIds
	 * @param {String} type
	 * @param {Object} optionsForRedraw
	 */

	function transformTo(targetIds, type, optionsForRedraw) {
	  var $$ = this,
	      options = optionsForRedraw || {
	    withTransitionForAxis: !$$.hasArcType()
	  };
	  // this is needed when transforming to arc
	  options.withTransitionForTransform = !1, $$.transiting = !1, $$.setTargetType(targetIds, type), $$.updateTargets($$.data.targets), $$.updateAndRedraw(options);
	}

	extend(Chart_Chart.prototype, {
	  /**
	   * Change the type of the chart.
	   * @method transform
	   * @instance
	   * @memberof Chart
	   * @param {String} type Specify the type to be transformed. The types listed in data.type can be used.
	   * @param {String|Array} targetIds Specify targets to be transformed. If not given, all targets will be the candidate.
	   * @example
	   *  // all targets will be bar chart.
	   *  chart.transform("bar");
	   *
	   *  // only data1 will be bar chart.
	   *  chart.transform("bar", "data1");
	   *
	   *  // only data1 and data2 will be bar chart.
	   *  chart.transform("bar", ["data1", "data2"]);
	   */
	  transform: function transform(type, targetIds) {
	    var $$ = this.internal,
	        options = ["pie", "donut"].indexOf(type) >= 0 ? {
	      withTransform: !0
	    } : null;
	    transformTo.bind($$)(targetIds, type, options);
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.group.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Update groups for the targets.
	   * @method groups
	   * @instance
	   * @memberof Chart
	   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
	   * @return {Array} Grouped data names array
	   * @example
	   *  // data1 and data2 will be a new group.
	   *  chart.groups([
	   *     ["data1", "data2"]
	   *  ]);
	   */
	  groups: function groups(_groups) {
	    var $$ = this.internal,
	        config = $$.config;
	    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.grid.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	/**
	 * Update x grid lines.
	 * @method xgrids
	 * @instance
	 * @memberof Chart
	 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
	 * @example
	 *  // Show 2 x grid lines
	 * chart.xgrids([
	 *    {value: 1, text: "Label 1"},
	 *    {value: 4, text: "Label 4"}
	 * ]);
	 */

	var xgrids = function (grids) {
	  var $$ = this.internal,
	      config = $$.config;
	  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
	};

	extend(xgrids, {
	  /**
	   * Add x grid lines.<br>
	   * This API adds new x grid lines instead of replacing like xgrids.
	   * @method xgrids․add
	   * @instance
	   * @memberof Chart
	   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
	   * @example
	   *  // Add a new x grid line
	   * chart.xgrids.add(
	   *   {value: 4, text: "Label 4"}
	   * );
	   *
	   * // Add new x grid lines
	   * chart.xgrids.add([
	   *   {value: 2, text: "Label 2"},
	   *   {value: 4, text: "Label 4"}
	   * ]);
	   */
	  add: function add(grids) {
	    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
	  },

	  /**
	   * Remove x grid lines.<br>
	   * This API removes x grid lines.
	   * @method xgrids․remove
	   * @instance
	   * @memberof Chart
	   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
	   * @example
	   * // x grid line on x = 2 will be removed
	   * chart.xgrids.remove({value: 2});
	   *
	   * // x grid lines that have 'grid-A' will be removed
	   * chart.xgrids.remove({
	   *   class: "grid-A"
	   * });
	   *
	   * // all of x grid lines will be removed
	   * chart.xgrids.remove();
	   */
	  remove: function remove(params) {
	    // TODO: multiple
	    this.internal.removeGridLines(params, !0);
	  }
	});

	/**
	 * Update y grid lines.
	 * @method ygrids
	 * @instance
	 * @memberof Chart
	 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
	 * @example
	 *  // Show 2 y grid lines
	 * chart.ygrids([
	 *    {value: 100, text: "Label 1"},
	 *    {value: 400, text: "Label 4"}
	 * ]);
	 */
	var ygrids = function (grids) {
	  var $$ = this.internal,
	      config = $$.config;
	  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
	};

	extend(ygrids, {
	  /**
	   * Add y grid lines.<br>
	   * This API adds new y grid lines instead of replacing like ygrids.
	   * @method ygrids․add
	   * @instance
	   * @memberof Chart
	   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
	   * @example
	   *  // Add a new x grid line
	   * chart.ygrids.add(
	   *   {value: 400, text: "Label 4"}
	   * );
	   *
	   * // Add new x grid lines
	   * chart.ygrids.add([
	   *   {value: 200, text: "Label 2"},
	   *   {value: 400, text: "Label 4"}
	   * ]);
	   */
	  add: function add(grids) {
	    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
	  },

	  /**
	   * Remove y grid lines.<br>
	   * This API removes x grid lines.
	   * @method ygrids․remove
	   * @instance
	   * @memberof Chart
	   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
	   * @example
	   * // y grid line on y = 200 will be removed
	   * chart.ygrids.remove({value: 200});
	   *
	   * // y grid lines that have 'grid-A' will be removed
	   * chart.ygrids.remove({
	   *   class: "grid-A"
	   * });
	   *
	   * // all of y grid lines will be removed
	   * chart.ygrids.remove();
	   */
	  remove: function remove(params) {
	    // TODO: multiple
	    this.internal.removeGridLines(params, !1);
	  }
	}), extend(Chart_Chart.prototype, {
	  xgrids: xgrids,
	  ygrids: ygrids
	});
	// CONCATENATED MODULE: ./src/api/api.region.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	/**
	 * Update regions.
	 * @method regions
	 * @instance
	 * @memberof Chart
	 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
	 * @return {Array} regions
	 * @example
	 * // Show 2 regions
	 * chart.regions([
	 *    {axis: "x", start: 5, class: "regionX"},
	 *    {axis: "y", end: 50, class: "regionY"}
	 * ]);
	 */

	var api_region_regions = function (_regions) {
	  var $$ = this.internal,
	      config = $$.config;
	  return _regions ? (config.regions = _regions, $$.redrawWithoutRescale(), _regions) : config.regions;
	};

	extend(api_region_regions, {
	  /**
	   * Add new region.<br><br>
	   * This API adds new region instead of replacing like regions.
	   * @method regions․add
	   * @instance
	   * @memberof Chart
	   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
	   * @return {Array} regions
	   * @example
	   * // Add a new region
	   * chart.regions.add(
	   *    {axis: "x", start: 5, class: "regionX"}
	   * );
	   *
	   * // Add new regions
	   * chart.regions.add([
	   *    {axis: "x", start: 5, class: "regionX"},
	   *    {axis: "y", end: 50, class: "regionY"}
	   *]);
	   */
	  add: function add(regions) {
	    var $$ = this.internal,
	        config = $$.config;
	    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
	  },

	  /**
	   * Remove regions.<br><br>
	   * This API removes regions.
	   * @method regions․remove
	   * @instance
	   * @memberof Chart
	   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
	   * @return {Array} regions Removed regions
	   * @example
	   * // regions that have 'region-A' or 'region-B' will be removed.
	   * chart.regions.remove({
	   *   classes: [
	   *     "region-A", "region-B"
	   *   ]
	   * });
	   *
	   * // all of regions will be removed.
	   * chart.regions.remove();
	   */
	  remove: function remove(optionsValue) {
	    var $$ = this.internal,
	        config = $$.config,
	        options = optionsValue || {},
	        duration = getOption(options, "duration", config.transition_duration),
	        classes = getOption(options, "classes", [config_classes.region]),
	        regions = $$.main.select(".".concat(config_classes.regions)).selectAll(classes.map(function (c) {
	      return ".".concat(c);
	    }));
	    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
	      var found = !1;
	      return !region["class"] || (region["class"].split(" ").forEach(function (c) {
	        classes.indexOf(c) >= 0 && (found = !0);
	      }), !found);
	    }), config.regions = regions) : config.regions = [], regions;
	  }
	}), extend(Chart_Chart.prototype, {
	  regions: api_region_regions
	});
	// CONCATENATED MODULE: ./src/api/api.data.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	/**
	 * Get data loaded in the chart.
	 * @method data
	 * @instance
	 * @memberof Chart
	 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
	 * @return {Array} Data objects
	 * @example
	 * // Get only data1 data
	 * chart.data("data1");
	 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
	 *
	 * // Get data1 and data2 data
	 * chart.data(["data1", "data2"]);
	 *
	 * // Get all data
	 * chart.data();
	 */

	var api_data_data = function (targetIds) {
	  var targets = this.internal.data.targets;

	  if (!isUndefined(targetIds)) {
	    var ids = isArray(targetIds) ? targetIds : [targetIds];
	    return targets.filter(function (t) {
	      return ids.some(function (v) {
	        return v === t.id;
	      });
	    });
	  }

	  return targets;
	};

	extend(api_data_data, {
	  /**
	   * Get data shown in the chart.
	   * @method data․shown
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
	   * @return {Array} Data objects
	   * @example
	   * // Get shown data by filtering to include only data1 data
	   * chart.data.shown("data1");
	   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
	   *
	   * // Get shown data by filtering to include data1 and data2 data
	   * chart.data.shown(["data1", "data2"]);
	   *
	   * // Get all shown data
	   * chart.data.shown();
	   */
	  shown: function shown(targetIds) {
	    return this.internal.filterTargetsToShow(this.data(targetIds));
	  },

	  /**
	   * Get values of the data loaded in the chart.
	   * @method data․values
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
	   * @return {Array} Data values
	   * @example
	   * // Get data1 values
	   * chart.data.values("data1");
	   * // --> [10, 20, 30, 40]
	   */
	  values: function (targetId) {
	    var flat = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1],
	        values = null;

	    if (targetId) {
	      var targets = this.data(targetId);
	      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
	        var dataValue = v.values.map(function (d) {
	          return d.value;
	        });
	        flat ? values = values.concat(dataValue) : values.push(dataValue);
	      }));
	    }

	    return values;
	  },

	  /**
	   * Get and set names of the data loaded in the chart.
	   * @method data․names
	   * @instance
	   * @memberof Chart
	   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
	   * @return {Object} Corresponding names according its key value, if specified names values.
	   * @example
	   * // Get current names
	   * chart.data.names();
	   * // --> {data1: "test1", data2: "test2"}
	   *
	   * // Update names
	   * chart.data.names({
	   *  data1: "New Name 1",
	   *  data2: "New Name 2"
	   *});
	   */
	  names: function names(_names) {
	    return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes("names", _names);
	  },

	  /**
	   * Get and set colors of the data loaded in the chart.
	   * @method data․colors
	   * @instance
	   * @memberof Chart
	   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
	   * @return {Object} Corresponding data color value according its key value.
	   * @example
	   * // Get current colors
	   * chart.data.colors();
	   * // --> {data1: "#00c73c", data2: "#fa7171"}
	   *
	   * // Update colors
	   * chart.data.colors({
	   *  data1: "#FFFFFF",
	   *  data2: "#000000"
	   * });
	   */
	  colors: function colors(_colors) {
	    return this.internal.updateDataAttributes("colors", _colors);
	  },

	  /**
	   * Get and set axes of the data loaded in the chart.
	   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
	   * @method data․axes
	   * @instance
	   * @memberof Chart
	   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
	   * @return {Object} Corresponding axes value for data, if specified axes value.
	   * @example
	   * // Get current axes
	   * chart.data.axes();
	   * // --> {data1: "y"}
	   *
	   * // Update axes
	   * chart.data.axes({
	   *  data1: "y",
	   *  data2: "y2"
	   * });
	   */
	  axes: function axes(_axes) {
	    return this.internal.updateDataAttributes("axes", _axes);
	  },

	  /**
	   * Get the minimum data value bound to the chart
	   * @method data․min
	   * @instance
	   * @memberof Chart
	   * @return {Array} Data objects
	   * @example
	   * // Get current axes
	   * chart.data.min();
	   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
	   */
	  min: function min() {
	    return this.internal.getMinMaxData().min;
	  },

	  /**
	   * Get the maximum data value bound to the chart
	   * @method data․max
	   * @instance
	   * @memberof Chart
	   * @return {Array} Data objects
	   * @example
	   * // Get current axes
	   * chart.data.max();
	   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
	   */
	  max: function max() {
	    return this.internal.getMinMaxData().max;
	  }
	}), extend(Chart_Chart.prototype, {
	  data: api_data_data
	});
	// CONCATENATED MODULE: ./src/api/api.category.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Set specified category name on category axis.
	   * @method category
	   * @instance
	   * @memberof Chart
	   * @param {Number} i index of category to be changed
	   * @param {String} category category value to be changed
	   * @example
	   * chart.category(2, "Category 3");
	   */
	  category: function category(i, _category) {
	    var $$ = this.internal,
	        config = $$.config;
	    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
	  },

	  /**
	   * Set category names on category axis.
	   * @method categories
	   * @instance
	   * @memberof Chart
	   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
	   * @example
	   * chart.categories([
	   *      "Category 1", "Category 2", ...
	   * ]);
	   */
	  categories: function categories(_categories) {
	    var $$ = this.internal,
	        config = $$.config;
	    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.color.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Get the color
	   * @method color
	   * @instance
	   * @memberof Chart
	   * @param {String} id id to get the color
	   * @example
	   * chart.color("data1");
	   */
	  color: function color(id) {
	    return this.internal.color(id); // more patterns
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.x.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Get and set x values for the chart.
	   * @method x
	   * @instance
	   * @memberof Chart
	   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
	   * @return {Object} xs
	   * @example
	   *  // Get current x values
	   *  chart.x();
	   *
	   *  // Update x values for all targets
	   *  chart.x([100, 200, 300, 400, ...]);
	   */
	  x: function x(_x) {
	    var $$ = this.internal,
	        isCategorized = $$.isCustomX() && $$.isCategorized();
	    return isArray(_x) && (isCategorized ? $$.api.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
	      withUpdateOrgXDomain: !0,
	      withUpdateXDomain: !0
	    }))), isCategorized ? $$.api.categories() : $$.data.xs;
	  },

	  /**
	   * Get and set x values for the chart.
	   * @method xs
	   * @instance
	   * @memberof Chart
	   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
	   * @return {Object} xs
	   * @example
	   *  // Get current x values
	   *  chart.xs();
	   *
	   *  // Update x values for all targets
	   *  chart.xs({
	   *    data1: [10, 20, 30, 40, ...],
	   *    data2: [100, 200, 300, 400, ...]
	   *  });
	   */
	  xs: function xs(_xs) {
	    var $$ = this.internal;
	    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
	      withUpdateOrgXDomain: !0,
	      withUpdateXDomain: !0
	    })), $$.data.xs;
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.axis.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	/**
	 * Set the min/max value
	 * @param {Chart} $$
	 * @param {String} type
	 * @param {Object} value
	 * @return {undefined}
	 * @private
	 */

	var setMinMax = function ($$, type, value) {
	  var config = $$.config,
	      axisX = "axis_x_".concat(type),
	      axisY = "axis_y_".concat(type),
	      axisY2 = "axis_y2_".concat(type);
	  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config[axisX] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
	    withUpdateOrgXDomain: !0,
	    withUpdateXDomain: !0
	  })), undefined;
	},
	    api_axis_getMinMax = function ($$, type) {
	  var config = $$.config;
	  return {
	    x: config["axis_x_".concat(type)],
	    y: config["axis_y_".concat(type)],
	    y2: config["axis_y2_".concat(type)]
	  };
	},
	    api_axis_axis = extend(function () {}, {
	  /**
	   * Get and set axis labels.
	   * @method axis․labels
	   * @instance
	   * @memberof Chart
	   * @param {Object} labels specified axis' label to be updated.
	   * @example
	   * // Update axis' label
	   * chart.axis.labels({
	   *   x: "New X Axis Label",
	   *   y: "New Y Axis Label"
	   * });
	   */
	  labels: function labels(_labels) {
	    var $$ = this.internal;
	    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
	      $$.axis.setLabelText(axisId, _labels[axisId]);
	    }), $$.axis.updateLabels());
	  },

	  /**
	   * Get and set axis min value.
	   * @method axis․min
	   * @instance
	   * @memberof Chart
	   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
	   *     If no argument is given, the min values set on generating option for each axis will be returned.
	   *     If not set any min values on generation, it will return `undefined`.
	   * @example
	   * // Update axis' min
	   * chart.axis.min({
	   *   x: -10,
	   *   y: 1000,
	   *   y2: 100
	   * });
	   */
	  min: function min(_min) {
	    var $$ = this.internal;
	    return arguments.length ? setMinMax($$, "min", _min) : api_axis_getMinMax($$, "min");
	  },

	  /**
	   * Get and set axis max value.
	   * @method axis․max
	   * @instance
	   * @memberof Chart
	   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
	   *     If no argument is given, the max values set on generating option for each axis will be returned.
	   *     If not set any max values on generation, it will return `undefined`.
	   * @example
	   * // Update axis' label
	   * chart.axis.max({
	   *    x: 100,
	   *    y: 1000,
	   *    y2: 10000
	   * });
	   */
	  max: function max(_max) {
	    var $$ = this.internal;
	    return arguments.length ? setMinMax($$, "max", _max) : api_axis_getMinMax($$, "max");
	  },

	  /**
	   * Get and set axis min and max value.
	   * @method axis․range
	   * @instance
	   * @memberof Chart
	   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
	   * @example
	   * // Update axis' label
	   * chart.axis.range({
	   *   min: {
	   *     x: -10,
	   *     y: -1000,
	   *     y2: -10000
	   *   },
	   *   max: {
	   *     x: 100,
	   *     y: 1000,
	   *     y2: 10000
	   *   },
	   * });
	   */
	  range: function range(_range) {
	    var axis = this.axis;
	    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
	      max: axis.max(),
	      min: axis.min()
	    };
	    return undefined;
	  }
	});
	/**
	 * Get the min/max value
	 * @param {Chart} $$
	 * @param {String} type
	 * @return {{x, y, y2}}
	 * @private
	 */


	extend(Chart_Chart.prototype, {
	  axis: api_axis_axis
	});
	// CONCATENATED MODULE: ./src/api/api.legend.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	/**
	 * Define legend
	 * @ignore
	 */

	var legend = extend(function () {}, {
	  /**
	   * Show legend for each target.
	   * @method legend․show
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} targetIds
	   * - If targetIds is given, specified target's legend will be shown.
	   * - If only one target is the candidate, String can be passed.
	   * - If no argument is given, all of target's legend will be shown.
	   * @example
	   * // Show legend for data1.
	   * chart.legend.show("data1");
	   *
	   * // Show legend for data1 and data2.
	   * chart.legend.show(["data1", "data2"]);
	   *
	   * // Show all legend.
	   * chart.legend.show();
	   */
	  show: function show(targetIds) {
	    var $$ = this.internal;
	    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
	      withLegend: !0
	    });
	  },

	  /**
	   * Hide legend for each target.
	   * @method legend․hide
	   * @instance
	   * @memberof Chart
	   * @param {String|Array} targetIds
	   * - If targetIds is given, specified target's legend will be hidden.
	   * - If only one target is the candidate, String can be passed.
	   * - If no argument is given, all of target's legend will be hidden.
	   * @example
	   * // Hide legend for data1.
	   * chart.legend.hide("data1");
	   *
	   * // Hide legend for data1 and data2.
	   * chart.legend.hide(["data1", "data2"]);
	   *
	   * // Hide all legend.
	   * chart.legend.hide();
	   */
	  hide: function hide(targetIds) {
	    var $$ = this.internal;
	    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
	      withLegend: !0
	    });
	  }
	});
	extend(Chart_Chart.prototype, {
	  legend: legend
	});
	// CONCATENATED MODULE: ./src/api/api.chart.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */



	extend(Chart_Chart.prototype, {
	  /**
	   * Resize the chart.
	   * @method resize
	   * @instance
	   * @memberof Chart
	   * @param {Object} size This argument should include width and height in pixels.
	   * @example
	   * // Resize to 640x480
	   * chart.resize({
	   *    width: 640,
	   *    height: 480
	   * });
	   */
	  resize: function resize(size) {
	    var $$ = this.internal,
	        config = $$.config;
	    $$.rendered && (config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0), $$.resizeFunction());
	  },

	  /**
	   * Force to redraw.
	   * @method flush
	   * @instance
	   * @memberof Chart
	   * @param {Boolean} [soft] For soft redraw.
	   * @example
	   * chart.flush();
	   *
	   * // for soft redraw
	   * chart.flush(true);
	   */
	  flush: function flush(soft, _isFromResize) {
	    var $$ = this.internal;
	    $$.rendered ? (_isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.zoomScale = null, soft ? $$.redraw({
	      withTransform: !0,
	      withUpdateXDomain: !0,
	      withUpdateOrgXDomain: !0,
	      withLegend: !0
	    }) : $$.updateAndRedraw({
	      withLegend: !0,
	      withTransition: !1,
	      withTransitionForTransform: !1
	    })) : $$.initToRender(!0);
	  },

	  /**
	   * Reset the chart object and remove element and events completely.
	   * @method destroy
	   * @instance
	   * @memberof Chart
	   * @example
	   * chart.destroy();
	   */
	  destroy: function destroy() {
	    var _this = this,
	        $$ = this.internal;

	    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), $$.svg.select("*").interrupt(), $$.generateResize.timeout && win.clearTimeout($$.generateResize.timeout), win.removeEventListener("resize", $$.resizeFunction), $$.selectChart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
	      key === "internal" && Object.keys($$).forEach(function (k) {
	        $$[k] = null;
	      }), _this[key] = null, delete _this[key];
	    })), null;
	  },

	  /**
	   * Get or set single config option value.
	   * @method config
	   * @instance
	   * @memberof Chart
	   * @param {String} name The option key name.
	   * @param {*} [value] The value accepted for indicated option.
	   * @param {Boolean} [redraw] Set to redraw with the new option changes.
	   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
	   * @example
	   * // Getter
	   * chart.config("gauge.max");
	   *
	   * // Setter
	   * chart.config("gauge.max", 100);
	   *
	   * // Setter & redraw with the new option
	   * chart.config("gauge.max", 100, true);
	   */
	  config: function config(name, value, redraw) {
	    var res,
	        $$ = this.internal,
	        key = name && name.replace(/\./g, "_");
	    return key in $$.config && (isDefined(value) ? ($$.config[key] = value, res = value, redraw && this.flush()) : res = $$.config[key]), res;
	  }
	});
	// CONCATENATED MODULE: ./src/api/api.tooltip.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */


	/**
	 * Define tooltip
	 * @ignore
	 */

	var api_tooltip_tooltip = extend(function () {}, {
	  /**
	   * Show tooltip
	   * @method tooltip․show
	   * @instance
	   * @memberof Chart
	   * @param {Object} args The object can consist with following members:<br>
	   *
	   *    | Key | Type | Description |
	   *    | --- | --- | --- |
	   *    | index | Number | Determine focus by index |
	   *    | x | Number &vert; Date | Determine focus by x Axis index |
	   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
	   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: data id<br>- value {Number}: The corresponding value for tooltip. |
	   *
	   * @example
	   *  // show the 2nd x Axis coordinate tooltip
	   *  chart.tooltip.show({
	   *    index: 1
	   *  });
	   *
	   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
	   *  chart.tooltip.show({
	   *    x: 2,
	   *    mouse: [50, 100]
	   *  });
	   *
	   *  // show tooltip for timeseries x axis
	   *  chart.tooltip.show({
	   *    x: new Date("2018-01-02 00:00")
	   *  });
	   *
	   *  // when data.xs is used
	   *  chart.tooltip.show({
	   *    data: {
	   *        x: 3,  // x Axis value
	   *        id: "data1",  // data id
	   *        value: 500  // data value
	   *    }
	   *  });
	   *
	   *  // when data.xs isn't used, but tooltip.grouped=false is set
	   *  chart.tooltip.show({
	   *    data: {
	   *        index: 3,  // or 'x' key value
	   *        id: "data1",  // data id
	   *        value: 500  // data value
	   *    }
	   *  });
	   */
	  show: function show() {
	    var index,
	        mouse,
	        args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        $$ = this.internal;

	    // determine focus data
	    if (args.mouse && (mouse = args.mouse), args.data) {
	      var y = $$.getYScale(args.data.id)(args.data.value);
	      $$.isMultipleX() ? mouse = [$$.x(args.data.x), y] : (!$$.config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
	    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


	    ($$.inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
	      $$.dispatchEvent(eventName, index, mouse);
	    });
	  },

	  /**
	   * Hide tooltip
	   * @method tooltip․hide
	   * @instance
	   * @memberof Chart
	   */
	  hide: function hide() {
	    var $$ = this.internal; // reset last touch point index

	    $$.inputType === "touch" && $$.callOverOutForTouch(), $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
	  }
	});
	extend(Chart_Chart.prototype, {
	  tooltip: api_tooltip_tooltip
	});
	// CONCATENATED MODULE: ./src/api/api.export.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard.js project is licensed under the MIT license
	 */




	/**
	 * Encode to base64
	 * @param {String} str
	 * @return {String}
	 * @private
	 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
	 */

	var b64EncodeUnicode = function (str) {
	  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
	    return String.fromCharCode("0x".concat(p));
	  }));
	},
	    nodeToSvgDataUrl = function (node, size) {
	  var serializer = new XMLSerializer(),
	      clone = node.cloneNode(!0),
	      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
	    return r.cssText;
	  }).map(function (r) {
	    return r.cssText;
	  });
	  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
	  var nodeXml = serializer.serializeToString(clone),
	      style = browser_doc.createElement("style"); // escape css for XML

	  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
	  var styleXml = serializer.serializeToString(style),
	      dataStr = "<svg xmlns=\"".concat(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, "\" width=\"").concat(size.width, "\" height=\"").concat(size.height, "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t").concat(styleXml, "\n\t\t\t\t").concat(nodeXml.replace(/(url\()[^#]+/g, "$1"), "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
	  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

	  return "data:image/svg+xml;base64,".concat(b64EncodeUnicode(dataStr));
	};
	/**
	 * Convert svg node to data url
	 * @param {HTMLElement} node
	 * @return {String}
	 * @private
	 */


	extend(Chart_Chart.prototype, {
	  /**
	   * Export chart as an image.
	   * - **NOTE:**
	   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
	   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
	   * @method export
	   * @instance
	   * @memberof Chart
	   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
	   * @param {Function} [callback] The callback to be invoked when export is ready.
	   * @return {String} dataURI
	   * @example
	   *  chart.export();
	   *  // --> "data:image/svg+xml;base64,PHN..."
	   *
	   *  // Initialize the download automatically
	   *  chart.export("image/png", dataUrl => {
	   *     const link = document.createElement("a");
	   *
	   *     link.download = `${Date.now()}.png`;
	   *     link.href = dataUrl;
	   *     link.innerHTML = "Download chart as image";
	   *
	   *     document.body.appendChild(link);
	   *  });
	   */
	  "export": function _export(mimeType, callback) {
	    var $$ = this.internal,
	        size = {
	      width: $$.currentWidth,
	      height: $$.currentHeight
	    },
	        svgDataUrl = nodeToSvgDataUrl(this.element, size);

	    if (isFunction(callback)) {
	      var img = new Image();
	      img.crosssOrigin = "Anonymous", img.onload = function () {
	        var canvas = browser_doc.createElement("canvas"),
	            ctx = canvas.getContext("2d");
	        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
	      }, img.src = svgDataUrl;
	    }

	    return svgDataUrl;
	  }
	});
	// CONCATENATED MODULE: ./src/core.js
	/**
	 * Copyright (c) 2017 ~ present NAVER Corp.
	 * billboard project is licensed under the MIT license
	 */























































	var _defaults = {},
	    bb = {
	  /**
	   * Version information
	   * @property {String} version version
	   * @example
	   *    bb.version;  // "1.0.0"
	   * @memberof bb
	   */
	  version: "1.12.10",

	  /**
	   * Generate chart
	   * @param {Options} options chart options
	   * @memberof bb
	   * @return {Chart}
	   * @see {@link Options} for different generation options
	   * @see {@link Chart} for different methods API
	   * @example
	   *  <!-- chart holder -->
	   * <div id="LineChart"></div>
	   * @example
	   *   // generate chart with options
	   *  var chart = bb.generate({
	   *      "bindto": "#LineChart"
	   *      "data": {
	   *          "columns": [
	   *              ["data1", 30, 200, 100, 400, 150, 250],
	   *              ["data2", 50, 20, 10, 40, 15, 25]
	   *           ]
	   *      }
	   *  });
	   *
	   *  // call some API
	   *  // ex) get the data of 'data1'
	   *  chart.data("data1");
	   */
	  generate: function generate(config) {
	    var options = mergeObj({}, _defaults, config),
	        inst = new Chart_Chart(options);
	    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
	  },

	  /**
	   * Set or get global default options.
	   * - **NOTE:**
	   *   - The options values settings are valid within page context only.
	   *   - If is called multiple times, will override the last value.
	   * @param {Options} options chart options
	   * @memberof bb
	   * @return {Options}
	   * @see {@link Options}
	   * @example
	   * // Set same option value as for `.generate()`
	   * bb.defaults({
	   *   data: {
	   *     type: "bar"
	   *   }
	   * });
	   *
	   * bb.defaults();  // {data:{type: "bar"}}
	   *
	   * // data.type defaults to 'bar'
	   * var chart = bb.generate({ ... });
	   */
	  defaults: function defaults(options) {
	    return isObject(options) && (_defaults = options), _defaults;
	  },

	  /**
	   * An array containing instance created
	   * @property {Array} instance instance array
	   * @example
	   *  // generate charts
	   *  var chart1 = bb.generate(...);
	   *  var chart2 = bb.generate(...);
	   *
	   *  bb.instance;  // [ chart1, chart2, ... ]
	   * @memberof bb
	   */
	  instance: [],

	  /**
	   * Namespace for plugins
	   * @property {Object} plugin plugin namespace
	   * @example
	   *  // Stanford diagram plugin
	   *  bb.plugin.stanford;
	   * @memberof bb
	   */
	  plugin: {},

	  /**
	   * Internal chart object
	   * @private
	   */
	  chart: {
	    fn: Chart_Chart.prototype,
	    internal: {
	      fn: ChartInternal_ChartInternal.prototype,
	      axis: {
	        fn: Axis_Axis.prototype
	      }
	    }
	  }
	};
	/**
	 * @namespace bb
	 * @version 1.12.10
	 */


	/* harmony default export */ var core = __webpack_exports__["default"] = (bb);

	/***/ })
	/******/ ]);
	});
	//# sourceMappingURL=billboard.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ })
/******/ ])});;